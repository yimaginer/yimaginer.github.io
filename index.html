<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yimaginer.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="技术，人生，思考，自我">
<meta property="og:type" content="website">
<meta property="og:title" content="Focus2flow">
<meta property="og:url" content="https://yimaginer.github.io/index.html">
<meta property="og:site_name" content="Focus2flow">
<meta property="og:description" content="技术，人生，思考，自我">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="sky">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yimaginer.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Focus2flow</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Focus2flow</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">less is more</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">sky</p>
  <div class="site-description" itemprop="description">技术，人生，思考，自我</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/12/04/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">论文投稿整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-12-04 21:06:16 / 修改时间：21:17:23" itemprop="dateCreated datePublished" datetime="2024-12-04T21:06:16+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>12月份可投论文整理：</p>
<!-- -->

<table>
<thead>
<tr>
<th>会议名称</th>
<th>主页</th>
<th>截稿日期</th>
<th>通知时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ICCCS2025</td>
<td><a target="_blank" rel="noopener" href="https://icccs.org/index.html">https://icccs.org/index.html</a></td>
<td>12月5号</td>
<td>1月5号</td>
<td>抗干扰试验室</td>
</tr>
<tr>
<td>IoTBDS2025</td>
<td><a target="_blank" rel="noopener" href="https://iotbds.scitevents.org/Home.aspx">https://iotbds.scitevents.org/Home.aspx</a></td>
<td>12月13号</td>
<td>1月30号</td>
<td>主题可能不相关</td>
</tr>
<tr>
<td>AINA</td>
<td><a target="_blank" rel="noopener" href="https://voyager.ce.fit.ac.jp/conf/aina/2025/index.php">https://voyager.ce.fit.ac.jp/conf/aina/2025/index.php</a></td>
<td>12月10号</td>
<td>1月10号</td>
<td>Distributed Ledger Technologies and Distributed-Parallel Computing，<strong>Workshop Proposal Due</strong>？</td>
</tr>
<tr>
<td>LATS2025</td>
<td><a target="_blank" rel="noopener" href="https://cas.polito.it/LATS2025/">https://cas.polito.it/LATS2025/</a></td>
<td>12月3号</td>
<td>12月28号</td>
<td></td>
</tr>
<tr>
<td>CSP2025</td>
<td><a target="_blank" rel="noopener" href="https://www.iccsp.org/index.html">https://www.iccsp.org/index.html</a></td>
<td>12月20号</td>
<td>1月20号</td>
<td></td>
</tr>
<tr>
<td>EIDWT-2025</td>
<td><a target="_blank" rel="noopener" href="https://voyager.ce.fit.ac.jp/conf/eidwt/2025/cfp.php">https://voyager.ce.fit.ac.jp/conf/eidwt/2025/cfp.php</a></td>
<td>12月4号</td>
<td>12月5号</td>
<td>不确定是不是 EI</td>
</tr>
<tr>
<td>WCCCT.org</td>
<td><a target="_blank" rel="noopener" href="https://www.wccct.org/index.html">https://www.wccct.org/index.html</a></td>
<td>12月10号</td>
<td>1月5号</td>
<td>比较合适</td>
</tr>
<tr>
<td>DIMVA-25</td>
<td><a target="_blank" rel="noopener" href="https://www.dimva.org/dimva2025/">https://www.dimva.org/dimva2025/</a></td>
<td>12月4号</td>
<td>1月22号</td>
<td>C会</td>
</tr>
<tr>
<td>CODASPY 2025</td>
<td><a target="_blank" rel="noopener" href="https://www.codaspy.org/2025/index.html">https://www.codaspy.org/2025/index.html</a></td>
<td>12月9摘要，12月16论文</td>
<td>1月31号</td>
<td></td>
</tr>
<tr>
<td>ISDA25</td>
<td><a target="_blank" rel="noopener" href="https://www.fsts.ac.ma/isda25/">https://www.fsts.ac.ma/isda25/</a></td>
<td>12月20号</td>
<td>1月15号</td>
<td>高老师</td>
</tr>
</tbody></table>
<p>如何查询一个会议是否是EI:<a target="_blank" rel="noopener" href="https://blog.csdn.net/binbinczsohu/article/details/108219845">https://blog.csdn.net/binbinczsohu/article/details/108219845</a></p>
<p>安全 C 会</p>
<table>
<thead>
<tr>
<th>会名</th>
<th>主页</th>
<th>提交</th>
<th>通知</th>
<th>开会</th>
</tr>
</thead>
<tbody><tr>
<td>EuroS&amp;P</td>
<td><a target="_blank" rel="noopener" href="https://eurosp2025.ieee-security.org/">IEEE European Symposium on Security and Privacy</a></td>
<td>10月24号</td>
<td>2月13</td>
<td>6月30</td>
</tr>
<tr>
<td>Inscrypt</td>
<td><a target="_blank" rel="noopener" href="http://www.icisc.org/">International Conference on Information Security and Cryptology</a></td>
<td>9月22日</td>
<td>10月30</td>
<td>12月20</td>
</tr>
<tr>
<td>HotSec</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SOUPS</td>
<td><a target="_blank" rel="noopener" href="https://www.usenix.org/conference/soups2024/call-for-papers">Symposium On Usable Privacy and Security</a></td>
<td>2月8号</td>
<td>3月21（退），5月13</td>
<td></td>
</tr>
<tr>
<td>SAC</td>
<td>Selected Areasin Cryptography</td>
<td>1月27</td>
<td>3月13</td>
<td>8月12</td>
</tr>
<tr>
<td>PETS</td>
<td><a target="_blank" rel="noopener" href="https://petsymposium.org/2024/paperlist.php">Privacy Enhancing Technologies Symposium</a></td>
<td></td>
<td>全年4次</td>
<td>7月15</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/12/02/%E6%9D%82%E9%A1%B9/Azure%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0%E7%94%B3%E8%AF%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/02/%E6%9D%82%E9%A1%B9/Azure%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0%E7%94%B3%E8%AF%B7/" class="post-title-link" itemprop="url">Azure学生优惠申请</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-02 18:09:20" itemprop="dateCreated datePublished" datetime="2024-12-02T18:09:20+08:00">2024-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:22:15" itemprop="dateModified" datetime="2024-12-04T21:22:15+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Azure 学生优惠申请</p>
<!-- -->



<p>账户认证成功的部署过程：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33177599/article/details/132333921">手把手教你白嫖微软Azure学生免费服务器及配置教程（IPv4+IPv6）_azure ipv6-CSDN博客</a></p>
<p>解决认证无法通过问题：<a target="_blank" rel="noopener" href="https://www.bilibili.com/opus/779661621020590113">如何使用 edu 邮箱申请 Azure 云学生优惠 - 哔哩哔哩 (bilibili.com)</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/" class="post-title-link" itemprop="url">z3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-02 15:41:45" itemprop="dateCreated datePublished" datetime="2024-12-02T15:41:45+08:00">2024-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:18:02" itemprop="dateModified" datetime="2024-12-04T21:18:02+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Z3 介绍</p>
<!-- -->

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Satisfiability Modulo Theories (SMT) problem is <strong>a decision problem for logical formulas</strong> with respect to combinations of background theories such as <strong>arithmetic</strong>, <strong>bit-vectors,</strong> <strong>arrays</strong>, and <strong>uninterpreted functions</strong>。Z3 是一个高效的 SMT 求解器，带有专门的算法求解背景理论，SMT 擅长于和其他软件分析工具如形式化验证和符号执行工具协同使用。这很大程度上归功于 Z3 对软件分析领域常见问题的支持。在一些场景中，这些工具（软件分析工具)提出的部分查询可以根据受支持逻辑中的公式进行转换。对于工具编写人员来说，了解什么是可用的支持逻辑，以及如何解决公式是很有用的。但是与SMT求解器的交互并不总是局限于将查询作为单个公式。它可能需要一系列的交互来获得可用的答案，并且工具编写人员需要了解可用的方法和旋钮。总之，本教程旨在通过示例和理论来回答以下类型的问题：</p>
<ul>
<li><strong>Z3中有哪些可用的特性，它们的设计用途是什么？</strong></li>
<li><strong>Z3中使用的底层算法是什么？</strong></li>
<li><strong>如何在Z3之上编写应用程序？</strong></li>
</ul>
<p>图1显示了Z3从4.8版本开始的整体系统关系图。左上角总结了到Z3的接口。可以通过作为文本文件或管道提供的 SMT-LIB2 脚本与Z3进行交互，也可以使用来自高级编程语言的API调用，这些编程语言是基于 c 的API调用的代理。我们将重点关注使用 Python 前端作为与 Z3接口的一种方式，并在第 2 节中开始描述 Z3 接受的术语和公式的抽象语法。第 3 节描述理论基础，这些理论定义了 z3 的输出公式及符号。第4、5、6节提供了判定公式可满足性的服务。第7节提供了预处理简化和创建子目标的方法。第8节讲解 Z3 还提供了一些不纯粹是可满足性查询的服务。服务允许用户求解可满足性模目标函数以最大化或最小化值。在第4.6.6节中还描述了用于枚举结果（骨干字面量）的专门过程。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202163058605.png" alt="image-20241202163058605"></p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>GitHub 存储库：<a target="_blank" rel="noopener" href="https://github.com/z3prover/z3">https://github.com/z3prover/z3</a></p>
<p>Lvy 使用了 z3 : <a target="_blank" rel="noopener" href="https://github.com/Microsoft/ivy">https://github.com/Microsoft/ivy</a></p>
<p>二进制分析工具包 Angr ： <a target="_blank" rel="noopener" href="https://docs.angr.io/">https://docs.angr.io/</a></p>
<p>Z3 教程：<a target="_blank" rel="noopener" href="https://microsoft.github.io/z3guide">https://microsoft.github.io/z3guide</a></p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>本教程中的材料来自多个来源。一些运行中的例子来自于在SAT和SMT社区中流传的幻灯片。第一个SAT的例子是无耻地从Armin Biere的SAT教程中摘抄的，其他的例子出现在Natarajan Shankar的幻灯片中</p>
<h2 id="Logical-interfaces-to-Z3"><a href="#Logical-interfaces-to-Z3" class="headerlink" title="Logical interfaces to Z3"></a>Logical interfaces to Z3</h2><p>Z3接受简单排序公式作为输入，这些公式可能包含由理论定义的具有预定义含义的符号。本节介绍可以用作Z3输入的逻辑公式。</p>
<p>作为基础，命题公式是由原子变量和逻辑连接词构成的。Z3接受的命题逻辑公式示例为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">Tie, Shirt = Bools(&#x27;Tie Shirt&#x27;)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(Or(Tie, Shirt), </span><br><span class="line">    Or(Not(Tie), Shirt), </span><br><span class="line">    Or(Not(Tie), Not(Shirt)))</span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure>

<p>这个例子引入了两个布尔变量Tie和Shirt。然后创建一个Solver对象并添加三个断言。</p>
<p>调用 s.check() 会产生一个判决结果；这些公式有一个令人满意的赋值。可以使用 s.model() 提取一个令人满意的模型，其中 Tie 为假，Shirt 为真。为方便起见，Z3 的 Python 前端包含一些简写函数。函数 solve 设置求解器，添加断言，检查可满足性，如果可用则打印模型。</p>
<p>命题逻辑是 Z3 处理的一个重要但较小的公式子集。它可以对组合了多个理论中的符号的公式进行推理，例如数组和算术的理论：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z = IntSort()</span><br><span class="line">f = Function(&#x27;f&#x27;, Z, Z)</span><br><span class="line">x, y, z = Ints(&#x27;x y z&#x27;)</span><br><span class="line">A = Array(&#x27;A&#x27;, Z, Z)</span><br><span class="line">fml = Implies(x + 2 == y, f(Store(A, x, 3)[y - 2]) == f(y - x + 1))</span><br><span class="line">solve(Not(fml))</span><br></pre></td></tr></table></figure>

<p>公式 fml 是有效的。它对所有整数 x，y， z，数组A，以及函数 f 的图像都成立。注意，z 甚至没有出现在公式中，但我们在这里声明它，因为我们将使用 z 来表示一个整数变量。注意，我们使用 array[index] 作为 Select（array, index）的简写。我们可以使用以下参数手动验证公式的有效性：整数常量 x 和 y 是使用函数 ints 创建的，该函数创建一个整数常量列表。在 x + 2 &#x3D; y 的假设下，右边的含义很简单等价于 <code>f(Store(A, x, 3)[x]) == f(3)</code></p>
<p>因为我们用 x + 2 替换了 y。对于 f 是什么没有限制，所以只有当 f 的参数相同时，两边与 f 相等才成立。因此，我们需要确定 <code>Store(A, x, 3)[x] == 3</code></p>
<p>左边是数组理论中的一个术语，它捕获了应用映射。Store 将位置 x 处的数组 A 更新为值3。然后……[x]检索索引 x 处的数组内容，在本例中是 3。在双重情况下，fml 的否定是不令人满意的，对 Z3 的调用产生 unsat。</p>
<p>Z3接受的公式通常遵循 SMT-LIB2 标准[4]中描述的格式。这个标准（目前的版本是2.6）定义了一阶多排序逻辑和一组由一系列背景理论定义的逻辑的文本语言。例如，在SMT-LIB2中称为 QF_LIA 的  <em>quantifier-free linear integer arithmetic</em> 的逻辑是一阶逻辑的片段，其中公式是无量词的，变量范围大于整数，解释常数是整数，允许的函数是+，-，整数乘法，除法，余数，带常数的模，允许的关系除了每个理论的一部分相等之外，还有&lt;,&lt;&#x3D;,&gt;&#x3D;,&gt;。作为一个例子，我们提供了一个SMT-LIB和同一个任意公式的Python变体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(set-logic QF_LIA)</span><br><span class="line">(declare-const x Int)</span><br><span class="line">(declare-const y Int)</span><br><span class="line">(assert (&gt; (+ (mod x 4) (* 3 (div y 2))) (- x y)))</span><br><span class="line">(check-sat)</span><br></pre></td></tr></table></figure>

<p>其对应的 python 版本是 <code>solve((x % 4) + 3 * (y / 2) &gt; x - y)</code></p>
<p>还可以提取求解器状态的SMT-LIB2表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">x, y = Ints(&#x27;x y&#x27;)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add((x % 4) + 3 * (y / 2) &gt; x - y)</span><br><span class="line">print(s.sexpr())</span><br></pre></td></tr></table></figure>

<p>产生输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(declare-fun y () Int)</span><br><span class="line">(declare-fun x () Int)</span><br><span class="line">(assert (&gt; (+ (mod x 4) (* 3 (div y 2))) (- x y)))</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>通常，SMT-LIB2 公式使用一组有限的简单排序。它包括内置的 Bool 排序，支持的理论定义了自己的排序，值得注意的Int， Real, bit-vectors （_ BitVec n）对于每一个正的位宽 n，数组(Array Index Elem) 对于每个排序索引和元素，每个排序S的字符串和序列（Seq S）。也可以声明新的排序。他们的领域可能永远不会是空的。因此，如下公式 <strong>is unsatisfiable</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S = DeclareSort(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">s = Const(<span class="string">&#x27;s&#x27;</span>, S)</span><br><span class="line">solve(ForAll(s, s != s))</span><br></pre></td></tr></table></figure>

<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>公式可以包含解释函数和自由函数以及常量的混合。例如，整数常量 0 和 28 被解释，而在前面的例子中使用的常量 x、y 是自由的。常量被视为虚函数。可以声明带参数的函数，例如 f &#x3D; Function（’f’， Z， Z）创建一个带整数参数的函数声明，其范围为整数。具有布尔范围的函数可用于创建公式。</p>
<h3 id="术语和公式"><a href="#术语和公式" class="headerlink" title="术语和公式"></a>术语和公式</h3><p>断言中使用的公式或添加到求解器中的公式是布尔排序的项。否则，在排序匹配的情况下，布尔和非布尔排序的项可能以任何组合混合在一起。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B = BoolSort()</span><br><span class="line">f = Function(&#x27;f&#x27;, B, Z)</span><br><span class="line">g = Function(&#x27;g&#x27;, Z, B)</span><br><span class="line">a = Bool(&#x27;a&#x27;)</span><br><span class="line">solve(g(1+f(a)))</span><br></pre></td></tr></table></figure>

<p>能产生这样的解吗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a = False, f = [else -&gt; 0], g = [else -&gt; True]]</span><br></pre></td></tr></table></figure>

<p>模型将a赋值为False， f  将所有参数映射为0，g 将所有值映射为True。标准的内置逻辑连接词是And、Or、Not、Implies、Xor。双蕴涵是等式的一种特殊情况，因此从Python中，当对布尔值 a 和 b 说a &#x3D;&#x3D; b时，它被视为 a 和 b 的双蕴涵的逻辑公式。</p>
<p>创建表达式后，有一组实用程序可用于遍历表达式。每个函数应用程序都有一个函数声明和一组作为子函数访问的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = Int(&#x27;x&#x27;)</span><br><span class="line">y = Int(&#x27;y&#x27;)</span><br><span class="line">n = x + y &gt;= 3</span><br><span class="line">print(&quot;num args: &quot;, n.num_args())</span><br><span class="line">print(&quot;children: &quot;, n.children())</span><br><span class="line">print(&quot;1st child:&quot;, n.arg(0))</span><br><span class="line">print(&quot;2nd child:&quot;, n.arg(1))</span><br><span class="line">print(&quot;operator: &quot;, n.decl())</span><br><span class="line">print(&quot;op name:  &quot;, n.decl().name())</span><br></pre></td></tr></table></figure>

<h3 id="量词和Lambda绑定"><a href="#量词和Lambda绑定" class="headerlink" title="量词和Lambda绑定"></a>量词和Lambda绑定</h3><p>全称量词和存在量词将变量绑定到量化公式的范围。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve([y == x + 1, ForAll([y], Implies(y &lt;= 0, x &lt; y))]) # no solution</span><br></pre></td></tr></table></figure>

<p>没有解因为不管我们赋给 x 什么值，y  都有一个非正的小于这个值的值。y 的限定值与自由值无关其中 y 被限制为 x + 1。等式约束 y &#x3D;&#x3D; x + 1 也不应被误认为是对  y  的赋值。y  的边界出现并不是 x + 1 的同义词。注意，公式略有不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solve([y == x + 1, ForAll([y], Implies(y &lt;= 0, x &gt; y))]) # [y = 3, x = 2]</span><br></pre></td></tr></table></figure>

<p>有一个解，其中<em>x</em>为1，<em>y</em>的自由出现次数为2。</p>
<p>Z3还支持基于模型构造实例化引擎的基本推理支持。s 在表示数组属性时可能很方便，Z3 使用数组排序来表示 lambda 表达式的排序。因此，memset 的结果是一个从整数到整数的数组，它产生的值 y 在从 lo 到 hi 的范围内，否则表现为范围外的 m。Z3 通过实例化类的主体来推断包含 memset 的无量词公式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m, m1 = Array(&#x27;m&#x27;, Z, Z), Array(&#x27;m1&#x27;, Z, Z)</span><br><span class="line">def memset(lo, hi, y, m):</span><br><span class="line">    return Lambda([x], If(And(lo &lt;= x, x &lt;= hi), y, Select(m, x)))</span><br><span class="line">solve([m1 == memset(1, 700, z, m), Select(m1, 6) != z])</span><br></pre></td></tr></table></figure>

<p>Lambda 绑定对于创建闭包很方便。回想一下 Lambda（[x,y], e）的含义，其中 e 是一个自由出现 x 和 y 的表达式，作为一个函数，它接受两个参数，并将它们的值替换为 e 中的 x 和 y。Z3 使用 Lambda 提升，结合Reynold的去功能化，将关于闭包的推理减少到普遍量化的定义。Z3 将数组视为一般的函数空间。所有一阶可定义函数都可以是数组。通过实例化综合项，可以建立一些二阶定理。因此,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q = Array(&#x27;Q&#x27;, Z, B)</span><br><span class="line">prove(Implies(ForAll(Q, Implies(Select(Q, x), Select(Q, y))), </span><br><span class="line">              x == y))</span><br></pre></td></tr></table></figure>

<p>可证明的。Z3合成一个实例，对应于Q的Lambda（z, z &#x3D;&#x3D; x）。</p>
<h2 id="Theories"><a href="#Theories" class="headerlink" title="Theories"></a>Theories</h2><p>我们将在这里总结Z3中支持的主要理论。在少数情况下，我们将简要介绍用于这些理论的决策程序。希望更深入地了解这些决策过程是如何实现的读者可以参考其中的一些引文。</p>
<h3 id="EUF：Equality-and-Uninterpreted-Functions"><a href="#EUF：Equality-and-Uninterpreted-Functions" class="headerlink" title="EUF：Equality and Uninterpreted Functions"></a>EUF：Equality and Uninterpreted Functions</h3><p>EUF 是一阶谓词逻辑的基本成分，在有理论之前，有常数、函数和谓词符号，以及内在的相等关系。在下面的例子中，f 是一元函数，x 是常数。求解的第一个调用对于一个模型是可行的，其中 x 被解释为 S 中的一个元素，f 是一个恒等函数。第二次调用solve是不可行的；没有模型 f 能将 x 映射到除了它本身以外的任何东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S = DeclareSort(&#x27;S&#x27;)</span><br><span class="line">f = Function(&#x27;f&#x27;, S, S)</span><br><span class="line">x = Const(&#x27;x&#x27;, S)</span><br><span class="line">solve(f(f(x)) == x, f(f(f(x))) == x)</span><br><span class="line">solve(f(f(x)) == x, f(f(f(x))) == x, f(x) != x)</span><br></pre></td></tr></table></figure>

<p>无量词的EUF公式的决策过程通常基于并集查找[59]来维护相等项的等价类。形象地说，一系列相等断言 a &#x3D; b, b &#x3D; c, b &#x3D; s 产生一个等价类，它捕获相等的传递性</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202183753365.png" alt="image-20241202183753365"></p>
<p>可以通过检查与两个不相等项相关联的等价类是否相同来检查不相等的可满足性。因此，加上 a !&#x3D; d 并不产生矛盾，可以通过比较阶级代表和阶级代表来检验。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202183808026.png" alt="image-20241202183808026"></p>
<p>另一方面，当断言 c ！&#x3D; s 时，我们可以推导出冲突，因为断言为不相等的两个项属于同一类。具有联合查找数据结构的类隶属关系在几乎常数时间内平摊。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184543400.png" alt="image-20241202184543400"></p>
<p>当使用函数符号时，仅使用Union-find是不够的，如下例所示：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184629970.png" alt="image-20241202184629970"></p>
<p>在这种情况下，决策过程需要用同余规则进行推理</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184659482.png" alt="image-20241202184659482"></p>
<p>作为解决示例的准备，让我们引入可以用作子项简写的常量。因此，引入常数作为四个复合子项的代表。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184739136.png" alt="image-20241202184739136"></p>
<p>只有相等性信息可用，我们得到等价类：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184808707.png" alt="image-20241202184808707"></p>
<p>自底向上工作，同余规则要求和的类应该合并。因此,</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184857114.png" alt="image-20241202184857114"></p>
<p>暗含以下等价的粗糙集合。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184942465.png" alt="image-20241202184942465"></p>
<p>此时，同余法则可以再应用一次，</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202185054726.png" alt="image-20241202185054726"></p>
<p>生成等价类</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202185110692.png" alt="image-20241202185110692"></p>
<p>v3 和 v4 的类现在被合并了。由于我们的原始公式要求这些是不同的，同余闭包推理确定公式是不可满足的。</p>
<h4 id="同余闭包"><a href="#同余闭包" class="headerlink" title="同余闭包"></a>同余闭包</h4><p>同余闭包可以用于检验等式的可满足性，</p>
<h4 id="EUF-模型"><a href="#EUF-模型" class="headerlink" title="EUF 模型"></a>EUF 模型</h4><p>运行示例的一个令人满意的版本是：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241203093137969.png" alt="image-20241203093137969"></p>
<p>这可以变形为：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241203093224275.png" alt="image-20241203093224275"></p>
<p>然后可以输入 Z3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S = DeclareSort(&#x27;S&#x27;)</span><br><span class="line">a, b, c, d, e, s, t = Consts(&#x27;a b c d e s t&#x27;, S)</span><br><span class="line">f = Function(&#x27;f&#x27;, S, S, S)</span><br><span class="line">g = Function(&#x27;g&#x27;, S, S)</span><br><span class="line">solve([a == b, b == c, d == e, b == s, </span><br><span class="line">       d == t, f(a, g(d)) != f(g(e), b)])</span><br></pre></td></tr></table></figure>

<p>经过求解，产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[s = S!val!0, b = S!val!0, a = S!val!0,</span><br><span class="line"> c = S!val!0, d = S!val!1, e = S!val!1, t = S!val!1,</span><br><span class="line"> f = [(S!val!2, S!val!0) -&gt; S!val!4, else -&gt; S!val!3],</span><br><span class="line"> g = [else -&gt; S!val!2]]</span><br></pre></td></tr></table></figure>

<p>在模型中，值 S!val!0 是一个不同于S!val!1的新常数。f 的图映射了参数 S!val!2， S!val!0 到 S!val!4。所有其他参数都通过else子句映射到S!val!3, else子句被用作解释中未列出的参数的默认解释。S的解释是一个有限集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;S!val!0, S!val!1, S!val!2, S!val!3, S!val!4&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h3><p><a target="_blank" rel="noopener" href="https://z3prover.github.io/papers/programmingz3.html">https://z3prover.github.io/papers/programmingz3.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/29/%E6%9D%82%E9%A1%B9/%E6%A2%85%E7%90%B3%E8%BE%BE%E7%9B%96%E8%8C%A8%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F2024%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E6%BC%94%E8%AE%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/29/%E6%9D%82%E9%A1%B9/%E6%A2%85%E7%90%B3%E8%BE%BE%E7%9B%96%E8%8C%A8%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F2024%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E6%BC%94%E8%AE%B2/" class="post-title-link" itemprop="url">梅琳达盖茨在斯坦福2024毕业典礼上的演讲</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-29 09:23:22" itemprop="dateCreated datePublished" datetime="2024-11-29T09:23:22+08:00">2024-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:21:28" itemprop="dateModified" datetime="2024-12-04T21:21:28+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>梅琳达·盖茨在斯坦福毕业典礼上的演讲</p>
<!-- -->

<p>前几天梅琳达·盖茨在斯坦福毕业典礼上的演讲，挺不错的。</p>
<p>她用了一个充满哲理的故事贯穿其中：</p>
<p>海洋中有两朵浪花，一大一小，正朝着岸边涌去。眼看离岸越来越近，大浪忽然意识到了即将发生的事。它看到前方的浪花一个接一个拍打在岸边，瞬间消失不见。</p>
<p>大浪顿时慌了神，对小浪喊道：”完了完了，我们就要到头了！”</p>
<p>小浪却笑眯眯地说：”别担心，我们不会有事的。”</p>
<p>大浪急了：”你不明白啊！我们马上就要消失了！”</p>
<p>小浪依然淡定自若，说道：”不会的。我用六个字就能告诉你为什么。”</p>
<p>“什么意思？”大浪疑惑地问。</p>
<p>小浪答道：”汝非浪乃水也。”</p>
<p>这个故事形象地描绘了如何在经历巨大的转变时，依旧保持自我本心。</p>
<p>她给斯坦福的毕业生们给了三条人生建议：</p>
<ol>
<li>以全然开放的心态面对人生的重要转变</li>
</ol>
<p>当我们从学校毕业，难免会被各种标签束缚自己，名校毕业会觉得应该去改变世界，普通人会觉得这些离自己太远，其实我们不过就像故事里的大浪、小浪，都不过是水罢了。</p>
<ol>
<li>找到你的“小浪”</li>
</ol>
<p>在那个关于浪花的故事里，小浪才是英雄，因为它帮助大浪用另一种方式看待事物。实际上，那个小浪并不小。它有着独到的见解，有一种大浪自己所没有的洞察。毕业生们，无论你是谁，无论你处于人生的哪个阶段，拥有“小浪”是极其宝贵的。在你人生的不同时期，不同的人会扮演这个角色。</p>
<ol>
<li>建立一个值得信任的关系网</li>
</ol>
<p>生命中，有幸能遇到“小浪”那样的贵人，睿智、看透生活的本质，适当的时候给我们建议，同样我们自己也可以当“小浪”那样的人，给别人建议和帮助。就像梅琳达讲她自己在她的好朋友去世时，帮助她的好朋友 Emmy 度过悲伤，三年前她和比尔盖茨离婚的时候，正是 Emmy 陪在她身边，帮她度过难关。</p>
<p>希望你们能以彻底开放的心态迈向未来，被那些与你同行的更小、更睿智的浪花的智慧和洞察所鼓舞，致力于拓展你们已经开始在周围编织的信任网络。</p>
<p>完整的演讲文稿：</p>
<p>感谢你，Saller 校长，同时向 2024 届的同学们道早安。（观众鼓掌）很荣幸能在这样一个欢乐的时刻和你们及你们的家人在一起。今天，你们即将从斯坦福大学毕业，这是一项了不起的成就。</p>
<p>斯坦福在我家心中总是有着特殊的意义。我爸爸，Ray French，于 1960 年得到奖学金在这里学习机械工程，他在攻读硕士学位时，我妈妈，Elaine French，靠在一家瓶装水公司的工作来支持他们。并且，在晚上和周末，她是我爸爸的实验室助理。我一直珍藏着一张老照片，照片上妈妈怀着我姐姐，她站在工程实验室的风洞旁边，手里拿着剪贴板和秒表。今天，我爸爸和妈妈又回到了这个校园，这次是为了一个非常特别的场合——看着他们的孙女，Phoebe，从改变了我爸爸生活的大学毕业。（观众鼓掌）</p>
<p>而 Phoebe 不是唯一一个跟随他足迹的人。我的大女儿，Jenn，和我的女婿，Nayel，也在这里拿到了学位。祝你父亲节快乐，爸爸，还有在场的所有爸爸们，也感谢妈妈，使这个故事成为可能。（观众鼓掌）</p>
<p>我知道在座的父母非常多，祖父母和亲人也在这里，他们和我及我的家人一样，都为能在这儿感到自豪。毕业生们，你们给了我们很多值得庆祝的事情，也给了我们很多值得钦佩的事情。你们来到这个校园时就已经是才华横溢、雄心勃勃的年轻人了。在校期间，你们还证明了自己能适应环境，以及你们是多么有力的倡导者，为你们信仰的事业而奋斗。</p>
<p>斯坦福是一所要求严格的大学，而你们在这里的时光因周围世界发生的事情变得更具挑战性。从百年一遇的疫情改变了你们的生活和学习方式，到我知道这个校园深深感受到的多场战争。毋庸置疑，你们毕业时的世界与你们入学时的世界完全不同，但你们离开这个校园时，也已经准备好成为我们所需要的领导者，今天标志着你们旅程中的一个重要里程碑。</p>
<p>我坐下后不久，你们会被邀请起立，如果你们能的话。你们将以斯坦福学生的身份听到这个召唤，而以斯坦福毕业生的身份回应这个召唤。随之，你们人生的一个重大转变将开始。最近，我一直在思考人生的转变这个话题。这让我想起心灵导师拉姆·达斯曾经讲过一个发人深省的故事。</p>
<p>海洋中有两朵浪花，一大一小，正朝着岸边涌去。眼看离岸越来越近，大浪忽然意识到了即将发生的事。它看到前方的浪花一个接一个拍打在岸边，瞬间消失不见。大浪顿时慌了神，对小浪喊道：”完了完了，我们就要到头了！” 小浪却笑眯眯地说：”别担心，我们不会有事的。” 大浪急了：”你不明白啊！我们马上就要消失了！” 小浪依然淡定自若，说道：”不会的。我用六个字就能告诉你为什么。” “汝非浪乃水也”（你不仅是浪花，还是水）</p>
<p>我很喜欢这个故事。它形象地描绘了如何在经历巨大的转变时，依旧保持自我本质的状态。我今年 60 岁了，你不可能到这个年纪还没有经历过各种生活的转变。有些变化你主动接受，有些变化你从未预期。有些变化你期待着，有些变化你尽全力抵抗。对我来说，这些变化包括在微软开始我的职业生涯，一个我最亲密的朋友去世，恋爱，成家，开始我为女性和女孩们的工作，以及结束了近 30 年的婚姻和伙伴关系。最近，我做出了重大的职业更迭。每一次转变，都有那么一刻，我会感受到像巨浪般的恐惧，害怕我所熟悉的生活即将改变，但我总是能挺过去，你也一样会的。我明白，真正的挑战从第二天开始，因为我们在第二天做的决定，塑造了我们的自我。所以，除了赞扬你今天的所有成就，我也想给你一些思考，等你明天醒来的时候。</p>
<p>我从自己的经历中学到的三个教训。第一条建议是，以全然开放的心态面对这些转变。大多数时候，我们都是在日常生活的琐事中度过，但在转变的时候，我们会离开熟悉的环境，走进一个全新、开放的空间。面对这些空间，我们有两种方式。你可以向下看，寻找从一个熟悉的事物到另一个的最快路径，或者你也可以鼓起勇气，在这个临界空间停留，看看它有什么可以告诉你的。这就是我理解的开放心态。</p>
<p>我必须承认，年轻的我，总是采取第一种方式去应对变化。我有一份想要达成的目标清单，每完成一个，我就赶紧投入到下一个目标中，因为坦白说，这样会让我感到更少的恐惧。但随着年龄的增长，我学会了欣然接受不确定性的代价。我来举个例子，阐述这在我的生活中是如何体现的。当我 25 年前踏入慈善领域时，这对我来说是一个完全陌生的领域。我在全球健康或开发方面没有任何经验，我知道我还有很多东西需要学习，所以我清楚我需要时刻保持关注。</p>
<p>起初，我们认为基金会的工作主要会集中在疫苗接种上，但当我开始环游世界，亲眼看到项目的执行情况时，我遇到的女性们总是把话题转向别处。“我过去打过的那些针怎么样了？”她们会问我。他们实际上在谈论避孕药。于是，我停下来，倾听她们的诉说。很快，我在几乎所有的旅程中都开始讨论避孕问题，并在回到家后，继续和我的团队进行这些话题的讨论。这些对话带来了更多的讨论。我了解到，当女性可以自主决策，拥有自己的资源，以及规划自己的未来时，社会将会收获巨大的好处。（观众热烈掌声）</p>
<p>于是，我开始将精力集中在那里。现在回望那些早期的旅行，我满怀感激，因为那些与我相遇的女性引领我走上了新的道路，帮助我找到了生活的目标。</p>
<p>我想，作为斯坦福的学生，你们大多数人今天毕业时都怀揣着宏伟的计划：继续深造、推动事业、创办公司、颠覆行业。这些雄心壮志固然可贵，世界也需要你们，但我的建议是：给这些计划留些改变的余地。不要认为你在斯坦福所做的一切已经把你锁定在某一条路上，或某种职业上。要对这样一个事实保持兴奋：你将遇到许多你甚至无法想象的可能性。要愿意让你所学到的东西改变你对自己在这个世界上的使命的看法。请记住，一旦浪花学会用另一个名字称呼自己，一旦它意识到自己不仅仅是浪花，而是水本身，它就获得了自由，可以呈现新的形态。对你们来说也是如此。</p>
<p>这就引出了我的第二个建议，很简短：找到你的小浪。在那个关于浪花的故事里，小浪才是英雄，因为它帮助大浪用另一种方式看待事物。实际上，那个小浪并不小。它有着独到的见解，有一种大浪自己所没有的洞察。毕业生们，无论你是谁，无论你处于人生的哪个阶段，拥有“小浪”是极其宝贵的。在你人生的不同时期，不同的人会扮演这个角色。</p>
<p>在我职业生涯的初期，扮演这个角色的是我的一位同事，名叫 Charlotte。我加入微软的时候，我非常热爱所做的工作，但随着时间的推移，我发现我并不喜欢那里的文化。那里的氛围咄咄逼人、充满攻击性，这与我的性格不符。我是我们那届 MBA 班毕业招聘中唯一的女性，我感到很大压力，要模仿周围的男性。最终，我到了一个想要离开公司的地步。就像故事中的大浪一样，我以为我的事业已经走到了尽头，但 Charlotte 帮我用不同的角度看待这一切。她比我年长一些，经验更为丰富，她已经找到了如何在不失去自我的情况下适应那里的文化。有了 Charlotte 在我身边，我才能想象自己在微软的未来。</p>
<p>所以，毕业生们，我向你们保证，今天在这个体育馆里，一定有人会成为你们的“小浪”，帮助你们塑造并实现自己的理想形象。同样重要的是，这里有人需要你为他们担任这个角色。</p>
<p>这就引出了我今天的最后一条建议。建立一个值得信任的关系网。这个美妙的短语来自传奇商人查理·芒格，他改变了这个校园的面貌，在他的慷慨捐赠下建造了漂亮的学生宿舍。查理曾说过一句名言：文明能达到的最高形式是一个无缝的、值得信赖的关系网，人们完全可靠，彼此正确地信任着对方，一个值得信赖的关系网。这是我们应该追求的目标。作为一个社会，我们并不总是为身边的人负责，或者在分歧或辩论另一边的人负责，尤其是在当下。但我们彼此需要。无论你是谁，在你的人生旅程中都会有需要被他人扶持的时刻，也会有他人需要你扶持的时候。</p>
<p>当我好朋友 John 在 37 岁时去世，我是试图帮助他的妻子 Emmy 度过悲伤的小组成员之一。三年前，当我的婚姻结束时，她是那些帮我度过难关的人之一。我们之间的这种联系非常深厚，但当然，查理谈论的远不止于此。他说的是一个整个社会都建立在这种关系之上，一种强大而互惠的纽带，但要乘以数百万、数十亿倍。</p>
<p>在你们呆在校园的这段时间里，目睹了许多让人心痛的历史，世界仍然离这个愿景很远，但你们也证明了自己已经准备好成为世界所需要的进步力量。是的，你们毕业后将进入一个破碎的世界，但恢复的力量来自于社区。你们已经在这里开始建立这个社区，只有团结一致，你们才能使破碎的事物重新完整。</p>
<p>但首先，你需要毕业，在接下来的几分钟里，当你和你的同学被邀请起立时，我希望你能在这个邀请中听到行动的召唤。我希望你们能想到每一个帮助你们达到今天这个里程碑的人，并发誓要回报他们对你们的投资。最重要的是，我希望你们能以彻底开放的心态迈向未来，被那些与你同行的更小、更睿智的浪花的智慧和洞察所鼓舞，致力于拓展你们已经开始在周围编织的信任网络。</p>
<p>当你们明天醒来，你们将不再是今天的自己，也还没成为未来的自己。我希望你能从中汲取勇气和信心，因为你们这些毕业生就是水本身，是塑造海岸线的力量。你们是多么强大的力量啊！</p>
<p>来自：<a target="_blank" rel="noopener" href="https://baoyu.io/blog/life/2024-stanford-commencement-speech-melinda-french-gates">https://baoyu.io/blog/life/2024-stanford-commencement-speech-melinda-french-gates</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/24/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/symcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/24/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/symcc/" class="post-title-link" itemprop="url">symcc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-24 17:34:02" itemprop="dateCreated datePublished" datetime="2024-11-24T17:34:02+08:00">2024-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:17:35" itemprop="dateModified" datetime="2024-12-04T21:17:35+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Symcc 和 AFL 结合实践：<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/266815.html">https://www.freebuf.com/articles/system/266815.html</a></p>
<p>带你搞懂符号执行的前世今生与最近技术：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/231413">https://www.anquanke.com/post/id/231413</a></p>
<!-- -->

<h3 id="symcc-安装"><a href="#symcc-安装" class="headerlink" title="symcc 安装"></a>symcc 安装</h3><p>symcc 官网：<a target="_blank" rel="noopener" href="https://www.s3.eurecom.fr/tools/symbolic_execution/symcc.html">https://www.s3.eurecom.fr/tools/symbolic_execution/symcc.html</a></p>
<ol>
<li><p>安装前置依赖</p>
<p><code>sudo apt install -y git cargo clang-14 cmake g++ git libz3-dev llvm-14-dev llvm-14-tools ninja-build python3-pip zlib1g-dev &amp;&amp; sudo pip3 install lit</code></p>
</li>
<li><p>拉取 symcc 源码</p>
<p><code>git clone https://github.com/eurecom-s3/symcc.git</code></p>
</li>
<li><p>拉取 z3</p>
</li>
</ol>
<h4 id="symcc-交叉编译问题"><a href="#symcc-交叉编译问题" class="headerlink" title="symcc 交叉编译问题"></a>symcc 交叉编译问题</h4><p>理论上symcc 可以使用 clang 将文件交叉编译到任意 llvm 支持的 architecture, 但是这需要对 backend 以及 dependencies 也进行交叉编译，然后将 backend 链接到目标程序，目前仅可以自动处理在 64 位平台交叉编译 32 位程序的场景，其他情况最好是直接在目标机上编译。</p>
<p>如果你在 64 位机器上编译 32 位程序，首先应该保证你拥有 32 位的依赖（ LLVM 和 Z3） </p>
<p>拥有了 32 位依赖以后，使用 cmake 编译源码时打开 <code>-DTARGET_32BIT=ON</code> , 如果编译系统找不到 32 位版本的 LLVM 和 Z3 , 则需要通过 <code>-DLLVM_32BIT_DIR=/some/path</code> 和 <code>-DZ3_32BIT_DIR=/some/other/path</code> 手动指定。</p>
<p>编译成的 symcc 将会识别 -m32 开关，symcc 调用 clang 编译 32 位工件。</p>
<h3 id="symcc-处理-C-程序问题"><a href="#symcc-处理-C-程序问题" class="headerlink" title="symcc 处理 C++ 程序问题"></a>symcc 处理 C++ 程序问题</h3><p>symcc 处理 c++ 程序时，对于 c++ 库有两种链接方法：</p>
<ol>
<li>使用原始的 C++ 库，此时符号执行到调用库时就要传进去具体(concretized)数字，此时相当于符号执行中断了</li>
<li>使用插桩后的 C++ 库，此时可以实现符号执行全流程追踪，这条路径需要提前编译出来一个插桩的 C++ 库文件，同时对主程序进行编译插桩，不能混合。</li>
</ol>
<p>第一种方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_REGULAR_LIBCXX=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sym++ -o myprogram mysource.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myprogram</span></span><br></pre></td></tr></table></figure>

<p>这种方案其实就是用sym++编译主程序，缺点就是不能跟踪 c++ 标准库中的操作，如 vector。</p>
<p>第二种方案：</p>
<p>首先是编译出插桩的 C++ 标准库，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/llvm/llvm-project.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> libcxx_symcc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> libcxx_symcc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_REGULAR_LIBCXX=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_NO_SYMBOLIC_INPUT=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -G Ninja /path-to-llvm-project/llvm \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;libcxx;libcxxabi&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;X86&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_DISTRIBUTION_COMPONENTS=<span class="string">&quot;cxx;cxxabi;cxx-headers&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_BUILD_TYPE=Release \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_INSTALL_PREFIX=/some/convenient/location \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_C_COMPILER=/path-to-symcc-with-simple-backend/symcc \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_CXX_COMPILER=/path-to-symcc-with-simple-backend/sym++</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ninja distribution</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ninja install-distribution</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unset</span> SYMCC_REGULAR_LIBCXX SYMCC_NO_SYMBOLIC_INPUT</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>export SYMCC_REGULAR_LIBCXX=yes</code> 和 <code>export SYMCC_NO_SYMBOLIC_INPUT=yes</code> 两个环境变量的设置，前者其实避免了chicken-and-egg problem，也就是在编译插桩库阶段不使用插桩库。后者是应为在编译插桩库过程中有很多 helper programs, 不希望对这些函数进行符号分析。</p>
<p>插桩库我们称之为 libc++, 这里插桩库编译出来之后，有一个 backends 的选择问题，不太理解，先做记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A word on the choice of backends: While the instrumented libc++ will work with</span><br><span class="line">both backends, building it currently doesn&#x27;t work with the QSYM backend. Just</span><br><span class="line">use the simple backend for the build process - there is no problem in using the</span><br><span class="line">library with the QSYM backend later. For very interested readers, here is an</span><br><span class="line">explanation of the problem: libc++ is an LLVM project and as such uses LLVM</span><br><span class="line">support code. During the build process, it builds a code-generation tool that is</span><br><span class="line">subsequently invoked (hence the recommendation to set SYMCC_NO_SYMBOLIC_INPUT).</span><br><span class="line">At run-time, the tool loads code built from the LLVM sources we obtained via git</span><br><span class="line">above. Why is this a problem for the QSYM backend? QSYM uses support code from</span><br><span class="line">LLVM as well, which means that the QSYM backend is linked against your system&#x27;s</span><br><span class="line">LLVM libraries. If we build libc++ with the QSYM backend, the code-generation</span><br><span class="line">tool loads the QSYM code at run time and, via dependency resolution, also the</span><br><span class="line">system&#x27;s LLVM installation. The end result is that we have two versions of LLVM</span><br><span class="line">support code in the same process - the system version and the one built from git</span><br><span class="line">- which will most likely collide. Using the simple backend avoids the problem</span><br><span class="line">because it doesn&#x27;t depend on the system installation of LLVM.</span><br></pre></td></tr></table></figure>

<p>然后就可以用插桩库进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_LIBCXX_PATH=/path-provided-as-cmake-install-prefix-for-libcxx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sym++ -o myprogram mysource.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myprogram</span></span><br></pre></td></tr></table></figure>



<h3 id="backend-问题"><a href="#backend-问题" class="headerlink" title="backend 问题"></a>backend 问题</h3><p>backend 在 symcc 的 runtime 插件中有一个文档专门描述，backend 分为 simple_backend 和 qsym_backend，前者是 Z3 的一个 wrapper，后者是 QSYM</p>
<p> 问题是 后端是干嘛的？</p>
<h3 id="symcc-的配置问题"><a href="#symcc-的配置问题" class="headerlink" title="symcc 的配置问题"></a>symcc 的配置问题</h3><p>配置主要分两种：</p>
<ol>
<li>编译源码时配置，影响编译时间和依赖设置，这个主要通过给 cmake 传参进行设置</li>
<li>运行时，运行通过 symcc 编译出的程序时，可以通过环境变量设置可以改变执行和分析过程</li>
</ol>
<p>第一类编译时选项：</p>
<ul>
<li><p>QSYM_BACKEND&#x3D;ON&#x2F;OFF (default OFF): 选择后端</p>
</li>
<li><p>TARGET_32BIT&#x3D;ON&#x2F;OFF (default OFF): 32 位程序编译支持</p>
</li>
<li><p>LLVM_DIR&#x2F;LLVM_32BIT_DIR (default empty): 如果 LLVM 不是默认位置，可以用于指定其位置，给build system 用</p>
</li>
<li><p>Z3_DIR&#x2F;Z3_32BIT_DIR (default empty): 指定Z3位置，给 build system 用</p>
</li>
<li><p>Z3_TRUST_SYSTEM_VERSION (default OFF): 无条件信任 Z3 的版本</p>
<p>运行时</p>
</li>
<li><p>SYMCC_NO_SYMBOLIC_INPUT&#x3D;0&#x2F;1 (default 0): 当被置 1 的时候 input is never marked<br>  as symbolic</p>
</li>
<li><p>SYMCC_OUTPUT_DIR (default “&#x2F;tmp&#x2F;output”): 保存 new inputs 的文件夹</p>
</li>
<li><p>SYMCC_INPUT_FILE (default empty): 默认情况下从标准输入中读取符号</p>
</li>
<li><p>SYMCC_MEMORY_INPUT&#x3D;0&#x2F;1 (default 0): 被置位时允许通过调 symcc_make_symbolic 来communicate symbolic</p>
</li>
<li><p>SYMCC_LOG_FILE (default empty): 后端日志文件</p>
</li>
<li><p>SYMCC_ENABLE_LINEARIZATION&#x3D;0&#x2F;1 (default 0): 开启 QSYM 剪枝</p>
</li>
<li><p>SYMCC_AFL_COVERAGE_MAP (default empty): 使用 AFL 的路径覆盖记录方法来跳过已经执行过的路径（QSYM backend only)</p>
</li>
<li><p>SYMCC_RUNTIME_DIR 和 SYMCC_RUNTIME32_DIR，运行时库所在文件夹</p>
</li>
<li><p>SYMCC_PASS_DIR ： compiler pass 所在文件夹</p>
</li>
<li><p>SYMCC_CLANG 和 SYMCC_CLANGPP： clang 和 clang++ 所在的文件夹</p>
</li>
</ul>
<h3 id="symcc-和-AFL-的配合"><a href="#symcc-和-AFL-的配合" class="headerlink" title="symcc 和 AFL 的配合"></a>symcc 和 AFL 的配合</h3><p>配合方式：</p>
<p>the basic idea is that SymCC and the fuzzer periodically exchange new inputs. SymCC comes with a helper that coordinates the collaboration with the fuzzer.</p>
<p>这里的 helper 在 symcc&#x2F;util&#x2F;symcc_fuzzing_helper 文件夹下，用 rust 语言写成</p>
<ol>
<li>编译生成 symcc_fuzzing_helper <code>cargo install --path util/symcc_fuzzing_helper</code>, 此时在 <code>~/.cargo/bin/symcc_fuzzing_helper</code> 位置会产生 symcc_fuzzing_helper 程序</li>
</ol>
<p>下面是联合使用 afl 和 symcc 的一个示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">                           Testing an example program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Suppose we wanted to search memory-related vulnerabilities in tcpdump&#x27;s</span><br><span class="line">link-layer parsers. The program can be instructed to read from a pcap and print</span><br><span class="line">relevant headers like so:</span><br><span class="line"></span><br><span class="line">$ tcpdump -e -r &lt;pcap_file&gt;</span><br><span class="line"></span><br><span class="line">Compile tcpdump and libpcap, the library it uses for pcap reading, once with</span><br><span class="line">SymCC and once with one of AFL&#x27;s compiler wrappers (e.g., afl-clang). In order</span><br><span class="line">to detect memory corruptions, enable address sanitizer in the AFL-instrumented</span><br><span class="line">version by exporting AFL_USE_ASAN=1 before compiling:</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/the-tcpdump-group/libpcap.git</span><br><span class="line">$ git clone https://github.com/the-tcpdump-group/tcpdump.git</span><br><span class="line"></span><br><span class="line">$ mkdir symcc_build; cd symcc_build</span><br><span class="line">$ cp -r ../&#123;libpcap,tcpdump&#125; .</span><br><span class="line">$ cd libpcap</span><br><span class="line">$ CC=/path/to/symcc ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ../tcpdump</span><br><span class="line">$ CC=/path/to/symcc ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">$ mkdir afl_build; cd afl_build</span><br><span class="line">$ export AFL_USE_ASAN=1</span><br><span class="line">$ cp -r ../&#123;libpcap,tcpdump&#125; .</span><br><span class="line">$ cd libpcap</span><br><span class="line">$ CC=/path/to/afl-clang ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ../tcpdump</span><br><span class="line">$ CC=/path/to/afl-clang ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">Note that we need two copies of the source code because the projects build</span><br><span class="line">in-tree. Also, it is important to place the source code directories next to each</span><br><span class="line">other, so that tcpdump&#x27;s build system can find and statically link the</span><br><span class="line">previously built libpcap.</span><br><span class="line"></span><br><span class="line">Create a corpus of dummy files somewhere (say, in a directory called &quot;corpus&quot;);</span><br><span class="line">for tcpdump, we just start with an empty corpus containing only a dummy file for</span><br><span class="line">AFL:</span><br><span class="line"></span><br><span class="line">$ mkdir corpus</span><br><span class="line">$ echo A &gt; corpus/dummy</span><br><span class="line"></span><br><span class="line">Then launch one AFL master and one AFL secondary instance, both writing their</span><br><span class="line">outputs to the arbitrarily named directory &quot;afl_out&quot;:</span><br><span class="line"></span><br><span class="line">$ afl-fuzz -M afl-master -i corpus -o afl_out -m none -- afl_build/tcpdump/tcpdump -e -r @@</span><br><span class="line">$ afl-fuzz -S afl-secondary -i corpus -o afl_out -m none -- afl_build/tcpdump/tcpdump -e -r @@</span><br><span class="line"></span><br><span class="line">For simplicity, we disable memory limits (with &quot;-m none&quot;); be sure to read AFL&#x27;s</span><br><span class="line">notes on address sanitizer to learn about the implications. Alternatively, you</span><br><span class="line">can compile the target program without address sanitizer, in which case you</span><br><span class="line">don&#x27;t need to disable the memory limit.</span><br><span class="line"></span><br><span class="line">Finally, we can run SymCC using the helper:</span><br><span class="line"></span><br><span class="line">$ ~/.cargo/bin/symcc_fuzzing_helper -o afl_out -a afl-secondary -n symcc -- symcc_build/tcpdump/tcpdump -e -r @@</span><br><span class="line"></span><br><span class="line">It will run SymCC on the most promising inputs generated by the secondary AFL</span><br><span class="line">instance and feed any interesting results back to AFL. In AFL&#x27;s status screen,</span><br><span class="line">you should see the counter &quot;imported&quot; in the &quot;path geometry&quot; section increase</span><br><span class="line">after a short time - this means that the fuzzer instances and SymCC are</span><br><span class="line">exchanging inputs. Crashes will be stored in afl_out/*/crashes as usual.</span><br><span class="line"></span><br><span class="line">It is possible to run SymCC with only an AFL master or only a secondary AFL</span><br><span class="line">instance; see the AFL docs for the implications. Moreover, the number of fuzzer</span><br><span class="line">and SymCC instances can be increased - just make sure that each has a unique</span><br><span class="line">name.</span><br><span class="line"></span><br><span class="line">Note that there are currently a few gotchas with the fuzzing helper:</span><br><span class="line"></span><br><span class="line">1. It expects afl-showmap to be in the same directory as afl-fuzz (which is</span><br><span class="line">   usually the case), and it finds that directory via your afl-fuzz command. If</span><br><span class="line">   afl-fuzz is on your PATH (as we assumed in the example above), all is good</span><br><span class="line">   and you can ignore this point. Otherwise, you need to either call afl-fuzz</span><br><span class="line">   with an absolute path (e.g., /afl/afl-fuzz in the Docker image) or, if you</span><br><span class="line">   use a relative path, start afl-fuzz from the same working directory as the</span><br><span class="line">   fuzzing helper.</span><br><span class="line"></span><br><span class="line">2. The helper needs to know how to call the AFL-instrumented version of the</span><br><span class="line">   target, and it finds that information by scanning your afl-fuzz command. To</span><br><span class="line">   this end, it _requires_ the double dash that we used in the example above to</span><br><span class="line">   separate afl-fuzz options from the target command; if you omit it, you&#x27;ll</span><br><span class="line">   likely get errors from the helper when it tries to run afl-showmap.</span><br></pre></td></tr></table></figure>



<p>使用 symcc 编译样例文件时遇到下面一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tiger@cornerstone:~/papers/symcc/build$ ./symcc -O2 -o foo foo.c</span><br><span class="line">error: unable to load plugin &#x27;/home/tiger/papers/symcc/build/libsymcc.so&#x27;: &#x27;Plugin entry point not found in &#x27;/home/tiger/papers/symcc/build/libsymcc.so&#x27;. Is this a legacy plugin?&#x27;</span><br></pre></td></tr></table></figure>

<p>这里的 plugin 我以为是指子模块编译出来的 libsymcc-rt.so，但是事实上似乎应该是缺少运行时插桩库，果然在完成了后面的插桩库构建时候顺利解决了这个问题。</p>
<h4 id="编译-backend"><a href="#编译-backend" class="headerlink" title="编译 backend"></a>编译 backend</h4><p>simple backend</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir symcc_build_simple </span><br><span class="line">cd symcc_build_simple </span><br><span class="line">CC=clang-14 CXX=clang++-14 cmake -G Ninja \</span><br><span class="line">    -DQSYM_BACKEND=OFF \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=RelWithDebInfo \</span><br><span class="line">    -DZ3_TRUST_SYSTEM_VERSION=on \</span><br><span class="line">    -DLLVM_DIR=/usr/lib/llvm-14/cmake \</span><br><span class="line">    ../ \</span><br><span class="line">    &amp;&amp; ninja check</span><br></pre></td></tr></table></figure>



<p>qsym backend</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir symcc_build_qsym </span><br><span class="line">cd symcc_build_qsym</span><br><span class="line">cmake -G Ninja \</span><br><span class="line">            -DQSYM_BACKEND=ON \</span><br><span class="line">            -DCMAKE_BUILD_TYPE=RelWithDebInfo \</span><br><span class="line">            -DZ3_TRUST_SYSTEM_VERSION=on \</span><br><span class="line">            -DLLVM_DIR=/usr/lib/llvm-14/cmake \</span><br><span class="line">            -DZ3_DIR=/usr/bin/z3 \</span><br><span class="line">            ../ \</span><br><span class="line">            &amp;&amp; ninja check \</span><br><span class="line">            &amp;&amp; cargo install --path ../symcc_source/util/symcc_fuzzing_helper</span><br></pre></td></tr></table></figure>



<h4 id="编译-C-插桩库"><a href="#编译-C-插桩库" class="headerlink" title="编译 C++ 插桩库"></a>编译 C++ 插桩库</h4><blockquote>
<p>方法是用 symcc 编译 llvm 的 libcxx</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">BASE=/home/tiger/papers/symcc</span><br><span class="line">git clone -b llvmorg-14.0.1 --depth 1 https://github.com/llvm/llvm-project.git llvm_source </span><br><span class="line">mkdir libcxx_symcc_install </span><br><span class="line">mkdir libcxx_symcc_build </span><br><span class="line">cd libcxx_symcc_build </span><br><span class="line">export SYMCC_REGULAR_LIBCXX=yes SYMCC_NO_SYMBOLIC_INPUT=yes \</span><br><span class="line">    &amp;&amp; cmake -G Ninja ../llvm_source/llvm \</span><br><span class="line">    	-DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \</span><br><span class="line">        -DLLVM_ENABLE_PROJECTS=&quot;libcxx;libcxxabi&quot; \</span><br><span class="line">        -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \</span><br><span class="line">        -DLLVM_DISTRIBUTION_COMPONENTS=&quot;cxx;cxxabi;cxx-headers&quot; \</span><br><span class="line">        -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=$BASE/libcxx_symcc_install \</span><br><span class="line">        -DCMAKE_C_COMPILER=$BASE/symcc_build_simple/symcc \</span><br><span class="line">        -DCMAKE_CXX_COMPILER=$BASE/symcc_build_simple/sym++ \</span><br><span class="line">    &amp;&amp; ninja distribution &amp;&amp; ninja install-distribution</span><br></pre></td></tr></table></figure>



<p>上面的构建过程报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at /home/tiger/papers/symcc/llvm_source/libcxxabi/src/CMakeLists.txt:179 (add_library):</span><br><span class="line">  The install of the cxxabi_shared target requires changing an RPATH from the</span><br><span class="line">  build tree, but this is not supported with the Ninja generator unless on an</span><br><span class="line">  ELF-based or XCOFF-based platform.  The CMAKE_BUILD_WITH_INSTALL_RPATH</span><br><span class="line">  variable may be set to avoid this relinking step.</span><br></pre></td></tr></table></figure>

<p>CMake错误信息表明在构建过程中遇到了与RPATH（运行时库搜索路径）相关的问题。RPATH是ELF（Executable and Linkable Format）文件中的一种设置，用于指定动态链接器在运行时搜索共享库的路径。错误信息指出，在使用Ninja作为生成器时，除非在ELF或XCOFF（Extended COFF，一种对象文件格式）平台上，否则不支持从构建树中更改RPATH。</p>
<p>这些错误通常发生在尝试安装共享库时，CMake需要更改RPATH以指向安装位置，而不是构建树中的临时位置。以下是一些可能的解决方案：</p>
<ul>
<li>cmake 编译库文件是添加变量 <code>cmake -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON</code></li>
<li>如果构建过程中不想或不能更改 rpath, 可以在构建完成后使用 <code>patchelf --set-rpath /desired/path/to/libs your_executable_or_library</code> 手动设置</li>
<li>也可以在 cmake 脚本 CMakeLists.txt 中手动设置：<code>set_target_properties(your_target PROPERTIES INSTALL_RPATH &quot;/desired/path/to/libs&quot;)</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tiger@cornerstone:/$ ls</span><br><span class="line">bin   dev  home  lib32  libx32      media  opt   root  sbin  srv       sys  usr</span><br><span class="line">boot  etc  lib   lib64  lost+found  mnt    proc  run   snap  swap.img  tmp  var</span><br><span class="line">tiger@cornerstone:/$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>把 afl 添加到系统环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时，只在这个终端中有效</span></span><br><span class="line">export PATH=&quot;/home/tiger/papers/afl:$PATH&quot;</span><br><span class="line">echo $PATH</span><br><span class="line">export PATH=&quot;/home/tiger/papers/symcc/symcc_build_qsym:$PATH&quot;</span><br><span class="line">export PATH=&quot;/home/tiger/.cargo/bin:$PATH&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/22/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/22/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">符号执行综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-22 19:50:15" itemprop="dateCreated datePublished" datetime="2024-11-22T19:50:15+08:00">2024-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:19:07" itemprop="dateModified" datetime="2024-12-04T21:19:07+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从 symQEMU 说起，符号执行综述：</p>
<!-- -->

<ol>
<li>这篇论文主要讲解了 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649774557&idx=1&sn=fda94410040b518fc0baa3e373de1b71&chksm=889369b2bfe4e0a4d2a9d0c583ea9ab1f45ac637d450b0b966afdbfcf902bffdfffe2efd8d61&scene=27">SymQEMU</a> 这个二进制分析工具，对比了其和之前的工作 symcc 以及经典工具 s2e QSYM 之间的差异</li>
<li>这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/hmysn/article/details/124797125">文章</a>以下概念的阐述很清晰且有逻辑：符号执行，动态执行，并行执行，选择符号执行。</li>
<li>一个符号执行的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lqerio/p/15980670.html">综述</a></li>
<li>符号执行工具：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kitsch0x97/article/details/138508887">https://blog.csdn.net/kitsch0x97/article/details/138508887</a></li>
</ol>
<p>如果要理解符号执行是什么，比较合理的顺序是以上三篇文章按照 2 -&gt; 3 -&gt; 1 的顺序阅读。</p>
<h4 id="基础工具研究"><a href="#基础工具研究" class="headerlink" title="基础工具研究"></a>基础工具研究</h4><ul>
<li>s2e</li>
<li>LLVM</li>
<li>KLEE</li>
<li>QEMU</li>
</ul>
<h4 id="SymQEMU"><a href="#SymQEMU" class="headerlink" title="SymQEMU"></a>SymQEMU</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/PrivSSO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/PrivSSO/" class="post-title-link" itemprop="url">PrivSSO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 17:07:02" itemprop="dateCreated datePublished" datetime="2024-11-19T17:07:02+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:19:36" itemprop="dateModified" datetime="2024-12-04T21:19:36+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>PrivSSO</p>
<!-- -->

<ul>
<li><p>PrivSSO is a tuple of five phases: (Initialize, Register, DevBind, Login, DevUnbind). Each of these phases has one or more algorithms presented as follows.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/GoodLuckAC/article/details/125217887">EUF_CMA</a>：一种验证安全性的方法</p>
</li>
<li><p>本文的主要思路是针对之前的 SSO(single-sign-on) 机制以容易泄露用户的订阅信息和访问模式的问题，设计了一种 “混合” 认证机制。一个长期密钥存储在一个保护良好的硬件令牌中，作为“主要”认证因子，保证强安全性。与便携设备绑定的临时密钥作为“日常使用”的 AF,已实现高度便利性。为了保护订阅模式和访问模式不被泄露，文章提出了可修改的令牌生成机制，允许由用户指定 idp sp(serive provider) 可以从中访问到的信息。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/A_Survey_on_Vulnerability_Detection_Tool_%20of_Smart_Contract_Bytecode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/A_Survey_on_Vulnerability_Detection_Tool_%20of_Smart_Contract_Bytecode/" class="post-title-link" itemprop="url">智能合约二进制码漏洞检测工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 17:01:31" itemprop="dateCreated datePublished" datetime="2024-11-19T17:01:31+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:20:49" itemprop="dateModified" datetime="2024-12-04T21:20:49+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>智能合约二进制码漏洞检测工具</p>
<!-- -->

<h3 id="当前工具分类"><a href="#当前工具分类" class="headerlink" title="当前工具分类"></a>当前工具分类</h3><h4 id="code-translation"><a href="#code-translation" class="headerlink" title="code translation"></a>code translation</h4><blockquote>
<p>使用反汇编从二进制码到源码</p>
</blockquote>
<ul>
<li>Disassembly: 二进制码到汇编</li>
<li>Decompilation：汇编到高级语言</li>
</ul>
<h4 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h4><ul>
<li><h5 id="control-glow-analysis"><a href="#control-glow-analysis" class="headerlink" title="control glow analysis"></a>control glow analysis</h5></li>
</ul>
<blockquote>
<p>use a CFG to represent paths trversed through a program during execution</p>
</blockquote>
<ul>
<li><h5 id="pattern-matching"><a href="#pattern-matching" class="headerlink" title="pattern matching"></a>pattern matching</h5></li>
</ul>
<blockquote>
<p>search a given sequence od instructions</p>
</blockquote>
<ul>
<li><h5 id="data-flow-analysis："><a href="#data-flow-analysis：" class="headerlink" title="data flow analysis："></a>data flow analysis：</h5></li>
</ul>
<blockquote>
<p>collecting information about the dependencies and possible ranges of values at various points in a program </p>
</blockquote>
<ul>
<li><h5 id="symbolic-executiom"><a href="#symbolic-executiom" class="headerlink" title="symbolic executiom"></a>symbolic executiom</h5></li>
</ul>
<blockquote>
<p>executing a program at a symbolic level. it treats values as symbols and code instructions as symbolic equations to reason about the logic of code exection.</p>
</blockquote>
<h4 id="Dynamic-Analysis"><a href="#Dynamic-Analysis" class="headerlink" title="Dynamic Analysis"></a>Dynamic Analysis</h4><blockquote>
<p>examining the code by executing it on a real or virtual processor.  on most vulnerability dection tools make use of dynamic analysis to validate the result of static analysis, others take advantage of fuzzing</p>
</blockquote>
<h3 id="智能合约漏洞类型"><a href="#智能合约漏洞类型" class="headerlink" title="智能合约漏洞类型"></a>智能合约漏洞类型</h3><h4 id="general-vulnerability-types"><a href="#general-vulnerability-types" class="headerlink" title="general vulnerability types"></a>general vulnerability types</h4><ul>
<li>interger overflow</li>
<li>premission verification missing</li>
<li>execption handling error</li>
</ul>
<h4 id="unique-vulnerabilities-in-smart-contract"><a href="#unique-vulnerabilities-in-smart-contract" class="headerlink" title="unique vulnerabilities in smart contract"></a>unique vulnerabilities in smart contract</h4><ul>
<li><p>transaction ordering dependency</p>
<blockquote>
<p>由于交易顺序和交易之间的数据依赖关系造成的逻辑错。比如 A 给 B 转账某个数字，而这个数字可以在另一个合约中被改写，第一个提交到第一个执行过程中假如被别的合约改掉了这个数字，则发生错误。本质原因是交易的提交和执行有时间差。</p>
</blockquote>
</li>
<li><p>predictable random number</p>
<blockquote>
<p>用块时间戳或者块号产生伪随机数，攻击者可能在理解了随机数机制之后预测随机数</p>
</blockquote>
</li>
<li><p>reentrancy</p>
<blockquote>
</blockquote>
</li>
<li><p>frozen token</p>
<blockquote>
<p>有些合约要调用外部合约库来传递 token ，而这个被调用的合约库可能已经失效注销，这时候这个调用就会被冻结在合约中。</p>
</blockquote>
</li>
<li><p>fake EOS and fake notice</p>
<blockquote>
<p> A want to transfer a token to B， A will push transfer action to eosio.token and then eosio.token will send a notice to B, triggerint B’s apply function.</p>
</blockquote>
</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="Oyente"><a href="#Oyente" class="headerlink" title="Oyente"></a>Oyente</h4><ul>
<li>static analysis tool based on sysmbolic execution run directly on EVM bytecode</li>
<li>has four modules: CFGBuilder吗， Explore, CoreAnalysis, Validator.</li>
</ul>
<h4 id="Securify"><a href="#Securify" class="headerlink" title="Securify"></a>Securify</h4><ul>
<li>lightweight and scalable security verifier</li>
<li>static analysis tool based on symbolic abstraction and pattern matching</li>
<li>Bytecode to SSA，then encoding the dependence graph of the contracts in stratified Datalog, then use Datalog solvers to analysze the Datalog code and get <strong>semantic facts</strong> of contract effciently. the semantic facts include data flow dependency and control flow dependency. the compliance and violation patterns are defined in a designed domain-specific language(DSL)</li>
</ul>
<h4 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h4><ul>
<li>base on symbolic execution and taint analysis</li>
<li>disassembling the EVM byteccode，initalize the account then use a couple of  transactions to explore the state space of the contract until an undesierd state is discovered. then  Mythril will calculate the transactions required to reach that state.</li>
</ul>
<h4 id="Manticore"><a href="#Manticore" class="headerlink" title="Manticore"></a>Manticore</h4><ul>
<li>symbolic execution framework for Ethereum smart contracts as well as Linux ELF binaries. </li>
<li>Manticore can execute the contract with <strong>symbolic transactions</strong> where both value and data are symbolic and explore all possible states, generating corresponding concrete inputs for any program state with Z3-Slover</li>
</ul>
<h4 id="teEther"><a href="#teEther" class="headerlink" title="teEther"></a>teEther</h4><ul>
<li>ethereum EVM contracts based on symbolic execution and result validation.</li>
<li>the first step is  to build a CFG，second is to scan the contract for important instructions DELEGATECLL SELFDESTRUCT SSTORE， third step is to explore paths to these instructions, the fourth step is to generate a set of path constraints through symbolic wexecution. fifth is to slove the constraints of these paths to detect the vulnerabilities.</li>
</ul>
<h4 id="MAIAN"><a href="#MAIAN" class="headerlink" title="MAIAN"></a>MAIAN</h4><ul>
<li>based on symbolic execution and result validation</li>
</ul>
<h4 id="ContractFuzzer"><a href="#ContractFuzzer" class="headerlink" title="ContractFuzzer"></a>ContractFuzzer</h4><ul>
<li>two parts: offline instrumentation and online fuzzing</li>
<li>offline instrumention is to instrument the EVM code in order for the fuzzing part to monitor the execution of the contract</li>
<li>online fuzzing : after analyzing the contract, ContractFuzzer extract the information of ABI and EVM bytecode of the contract, whilch help the tool genreate valid fuzzing inputs</li>
</ul>
<h3 id="tools-for-EOSIO-Contracts"><a href="#tools-for-EOSIO-Contracts" class="headerlink" title="tools for EOSIO Contracts"></a>tools for EOSIO Contracts</h3><h4 id="EVulHunter"><a href="#EVulHunter" class="headerlink" title="EVulHunter"></a>EVulHunter</h4><ul>
<li>static analysis tool for EOSIO WASM contracts based on pattern matching.</li>
<li>three modules: CFG bulider(Octopus), WASM Simulator, Detector Engine(two detector for fake EOS and fake notice)</li>
</ul>
<h4 id="EOSafe"><a href="#EOSafe" class="headerlink" title="EOSafe"></a>EOSafe</h4><ul>
<li>a static anasis framework for vulnerability dection in EOSIO WASM smart contracts.</li>
<li>three moudles: Engine, Emulator, Scanner </li>
<li>engine ：symbolic execution of a contract, receiving the CFG and dissembled instructions of the contract as input, execute the code and within basic blocks, exploring all workable path and gathering path costractions. </li>
<li>Emulator:  emulating the side effects of imported functions in the contract.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/11/19/%E6%9D%82%E9%A1%B9/%E4%B8%93%E6%B3%A8%E5%8A%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/19/%E6%9D%82%E9%A1%B9/%E4%B8%93%E6%B3%A8%E5%8A%9B/" class="post-title-link" itemprop="url">专注力</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-19 16:10:21" itemprop="dateCreated datePublished" datetime="2024-11-19T16:10:21+08:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-04 21:21:50" itemprop="dateModified" datetime="2024-12-04T21:21:50+08:00">2024-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>专注力</p>
<!-- -->

<ul>
<li><p>如何提高孩子的专注力? - 米典的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25547062/answer/1326148777">https://www.zhihu.com/question/25547062/answer/1326148777</a></p>
<p>从顶层理解，提高专注力的最重要的理解是：<strong>让自己拿出全力以赴的状态去做事情，拿出下决心要做成的态度去做。</strong></p>
</li>
<li><p>如何提高孩子的专注力? - Jennie真真的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25547062/answer/2274445488">https://www.zhihu.com/question/25547062/answer/2274445488</a></p>
<p>实际操作中可<strong>以使用策略性运动训练专注力</strong>：羽毛球，网球，篮球，跑酷</p>
</li>
<li><p>一些可能会有帮助的思维练习：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMTIxOTk3Ng==&mid=401583322&idx=1&sn=806e7f4ea94c846dd8a973fed4a9136c#rd">https://mp.weixin.qq.com/s?__biz=MzIwMTIxOTk3Ng==&amp;mid=401583322&amp;idx=1&amp;sn=806e7f4ea94c846dd8a973fed4a9136c#rd</a></p>
</li>
<li><p>总的来说，专注力不是靠练习能练出来的，更多的是一种习惯，需要保护自己的专注力（远离各种短视频），也需要做事情能够静下心来，做一事成一事。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yimaginer.github.io/2024/10/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hot%20100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Focus2flow">
      <meta itemprop="description" content="技术，人生，思考，自我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Focus2flow">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hot%20100/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-19 17:39:56" itemprop="dateCreated datePublished" datetime="2024-10-19T17:39:56+08:00">2024-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-22 17:27:45" itemprop="dateModified" datetime="2024-10-22T17:27:45+08:00">2024-10-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hot-100"><a href="#hot-100" class="headerlink" title="hot 100"></a>hot 100</h2><h4 id="1-两数凑-target"><a href="#1-两数凑-target" class="headerlink" title="1. 两数凑 target"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数凑 target</a></h4><p>思路：哈希检测“另一半”的存在性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(target - nums[i]) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            <span class="keyword">else</span> m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>思路：仅仅是字母异位那么排序后一定相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string sort_e = e; ranges::<span class="built_in">sort</span>(sort_e);</span><br><span class="line">            m[sort_e].<span class="built_in">push_back</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans; ans.<span class="built_in">reserve</span>(m.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, value] : m) ans.<span class="built_in">push_back</span>(value);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++ 20 引入的排序方式：<code>ranges::sort(sort_e);</code>, 如果要用算法中的要这样 ： <code>sort(sort_e.begin(),sort_e.end())</code></li>
<li>对一个 hash 遍历可以用这样的方式 <code>for(auto &amp;[_, value] : m)</code></li>
<li>resize 和 reserve 的区别是： 前者增加了size(), 后者增加了 capcity</li>
</ul>
<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><p>题目描述：一个乱序数组，问其中子序列可能组成的最长连续数组的长度是多少？时间复杂度 O(n)</p>
<p>思路：先用哈希表对数组去重，并形成数字的集合，然后遍历 hash 表。从这样一个左边不在集合内的数据开始递增查询其右边元素的存在性，记录子段长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums) hash.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : hash)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(e - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = e; w = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(hash.<span class="built_in">count</span>(t ++)) w ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(w, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="283-移动零到末尾"><a href="#283-移动零到末尾" class="headerlink" title="283. 移动零到末尾"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零到末尾</a></h4><p>题目描述：给一个数组，把其中的零全部移动到末尾，保持非零元素相对顺序不变</p>
<p>思路1：从前往后过一遍，统计前置 0 的量，根据前置零数量防止非零元素 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) cnt ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">swap</span>(nums[i],nums[i - cnt]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路2：快慢指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] != <span class="number">0</span>) nums[l ++] = nums[r];</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n) nums[l ++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>题目描述：一个数组代表板子高度，问两板之间可以存的最多的水的体积</p>
<p>思路：左右指针向中间靠拢，具体的让低板向高板子靠拢，以求得可能会体积增大</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = h.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">            <span class="keyword">if</span>(h[i] &lt; h[j]) ans = <span class="built_in">max</span>(ans, (j - i) * h[i ++]);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, (j - i) * h[j --]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>题目描述：从一个数组中找出三个数，让三个数之和为 0；若有多种情况，用一个 vector&lt;vector<int>&gt; 返回</int></p>
<p>思路：数组排序，然后用 i j k 三个指针， i 用于枚举第一个元素， j k 相向指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums); <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i]; </span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; x == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = x + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span>(s &gt; <span class="number">0</span>) k --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; <span class="number">0</span>) j ++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;x,nums[j],nums[k]&#125;);</span><br><span class="line">                    j ++; k --;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) j ++;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) k --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">empty</span>() || h[i] &gt; t.<span class="built_in">top</span>()) t.<span class="built_in">push</span>(h[i]);</span><br><span class="line">            l[i] = t.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 注意清空操作</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">empty</span>() || h[i] &gt; t.<span class="built_in">top</span>()) t.<span class="built_in">push</span>(h[i]);</span><br><span class="line">            r[i] = t.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">            ans += (<span class="built_in">min</span>(l[i], r[i]) - h[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前后指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; hash; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; !hash.<span class="built_in">count</span>(s[r])) hash.<span class="built_in">insert</span>(s[r ++]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">            <span class="keyword">while</span>(s[l] != s[r])  hash.<span class="built_in">erase</span>(s[l ++]);</span><br><span class="line">            l ++; r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window; <span class="comment">// 维护从下标 left 到下标 right 的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="comment">// 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素</span></span><br><span class="line">            <span class="comment">// 所以要在加入 c 之前，先移出窗口内的 c</span></span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">count</span>(c)) &#123; <span class="comment">// 窗口内有 c</span></span><br><span class="line">                window.<span class="built_in">erase</span>(s[left++]); <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c); <span class="comment">// 加入 c</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">// 更新窗口长度最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>题目描述：给一个字符串 s 和 p , 找出所有 s 中可以异位匹配 p 的起始位置。</p>
<p>思路：暴力，异位匹配等价于 sort 后相等；滑动窗口；快慢指针；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), k = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; <span class="type">int</span> pp[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) pp[p[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            pp[s[r] - <span class="string">&#x27;a&#x27;</span>] --; <span class="comment">// 消耗法</span></span><br><span class="line">            <span class="keyword">while</span>(pp[s[r] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="comment">// 去杂质，去冗余</span></span><br><span class="line">            &#123;</span><br><span class="line">                pp[s[l] - <span class="string">&#x27;a&#x27;</span>] ++; l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s_cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            p_cnt[p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; ++right) &#123;</span><br><span class="line">            <span class="type">int</span> cur_right = s[right] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//窗口右端进入的字符对应序号</span></span><br><span class="line">            s_cnt[cur_right]++;         <span class="comment">//右端进入的字符对应数量+1</span></span><br><span class="line">            <span class="keyword">while</span>(s_cnt[cur_right] &gt; p_cnt[cur_right])&#123;</span><br><span class="line">                <span class="type">int</span> cur_left = s[left] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                s_cnt[cur_left]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> == n)</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定长滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), k = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; </span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 首段</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s_cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>; <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            s_cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            p_cnt[p[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s_cnt == p_cnt) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            s_cnt[s[i - k] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            s_cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(s_cnt == p_cnt) ans.<span class="built_in">push_back</span>(i - k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这道题目要解决的一个问题是 s 串中出现 p 中没有的字符时的情况，两种方法都最这样的字符来者不拒。但是滑动窗口的办法通过 <code>s_cnt == p_cnt</code> 这一个条件就可以解决 “杂质” 问题，快慢指针通过 while 可以达到去杂质的效果。</li>
</ul>
<h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>题目描述：给你一个数组和一个k, 返回和为 k 的子数组的数量</p>
<p>思路：遍历一遍原数组建立前缀和数组，再遍历一遍前缀和数组，统计在前缀和数组的前置位中有多少的 s[i] - k</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(); <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) s[i + <span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(e - k) ? mp[e - k] : <span class="number">0</span>;</span><br><span class="line">            mp[e] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), s = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            s += e;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(s - k) ? mp[s - k] : <span class="number">0</span>;</span><br><span class="line">            mp[s] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>题目描述：给你一个数组和一个窗口宽度 k ,从数组的第 k 个位置开始，返回以该位置为结尾的宽度为 k  的数组中的最大值</p>
<p>思路：利用单调队列，维护一个 k 宽度内递减的队列，则当前窗口内最大值为队首</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 入</span></span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 出</span></span><br><span class="line">            <span class="keyword">if</span>(i - q.<span class="built_in">front</span>() &gt;= k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">// 记录/维护答案(根据队首)</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>单调栈和单调队列的对比<ul>
<li>新来的元素由于位置和值的原因会使得栈中或队中某些数据永远不可能 “出头”， 于是入队时把这部分元素剔除。</li>
<li>使用单调栈意味着<strong>位置考虑范围从当前元素一直到端点</strong>（原因是出栈原因只可能是被当前元素遮蔽），而使用单调队列则意味着<strong>位置考虑范围是从当前元素到某一条件处</strong>（条件在出队处体现）。</li>
</ul>
</li>
<li>单调队列模型<ul>
<li>入（元素进入<strong>队尾</strong>，同时维护队列<strong>单调性</strong>）</li>
<li>出（元素离开<strong>队首</strong>）</li>
<li>记录&#x2F;维护答案（根据<strong>队首</strong>）</li>
</ul>
</li>
<li>单调栈模型<ul>
<li>有选择性入：利用当前元素剔除栈顶元素，有必要的话入栈。</li>
<li>记录&#x2F;维护答案（根据<strong>栈顶</strong>）</li>
</ul>
</li>
</ul>
<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>题目描述：给出字符串 s 和 t,求出 t 的一个最小子串可以包含 t 中所有字符。</p>
<p>思路：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(<span class="type">int</span> cnt_s[], <span class="type">int</span> <span class="type">cnt_t</span>[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt_s[i] &lt; <span class="type">cnt_t</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt_s[i] &lt; <span class="type">cnt_t</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>, ans_right = m;</span><br><span class="line">        <span class="type">int</span> cnt_s[<span class="number">128</span>]&#123;&#125;; <span class="comment">// s 子串字母的出现次数</span></span><br><span class="line">        <span class="type">int</span> <span class="type">cnt_t</span>[<span class="number">128</span>]&#123;&#125;; <span class="comment">// t 中字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) <span class="type">cnt_t</span>[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            cnt_s[s[right]]++; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">is_covered</span>(cnt_s, <span class="type">cnt_t</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ans_right - ans_left) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ans_left = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ans_right = right;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt_s[s[left]]--; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_left &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ans_left, ans_right - ans_left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>, ans_right = m;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                less++; <span class="comment">// 有 less 种字母的出现次数 &lt; t 中的字母出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 右端点字母</span></span><br><span class="line">            cnt[c]--; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 原来窗口内 c 的出现次数比 t 的少，现在一样多</span></span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less == <span class="number">0</span>) &#123; <span class="comment">// 涵盖：所有字母的出现次数都是 &gt;=</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ans_right - ans_left) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ans_left = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ans_right = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> x = s[left]; <span class="comment">// 左端点字母</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// x 移出窗口之前，检查出现次数，</span></span><br><span class="line">                    <span class="comment">// 如果窗口内 x 的出现次数和 t 一样，</span></span><br><span class="line">                    <span class="comment">// 那么 x 移出窗口后，窗口内 x 的出现次数比 t 的少</span></span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[x]++; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_left &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ans_left, ans_right - ans_left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>题目描述：经典的最大子段和问题</p>
<p>思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN; <span class="comment">// 注意答案可以是负数，不能初始化成 0</span></span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            f = <span class="built_in">max</span>(f, <span class="number">0</span>) + x;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN; <span class="type">int</span> min_pre_sum = <span class="number">0</span>， pre_sum = <span class="number">0</span>; <span class="comment">// 初始化有讲究</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> e : nums)</span><br><span class="line">       &#123;</span><br><span class="line">            pre_sum += e; <span class="comment">// 三句话的顺序有讲究：更新了当前位置的 pre_sum 才能更新 ans, ans 要用到当前位置之前的 min_pre_sum， 所以 ans 的更新要在 min_pre_sum 更新之前</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre_sum - min_pre_sum);	</span><br><span class="line">            min_pre_sum = <span class="built_in">min</span>(pre_sum, min_pre_sum);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4><p>题目描述：经典区间合并</p>
<p>思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(intervals); vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ans.<span class="built_in">empty</span>() &amp;&amp; e[<span class="number">0</span>] &lt;= ans.<span class="built_in">back</span>()[<span class="number">1</span>]) <span class="comment">// 合并</span></span><br><span class="line">                ans.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(ans.<span class="built_in">back</span>()[<span class="number">1</span>], e[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>() - k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">end</span>() - k, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> reverse = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) <span class="built_in">swap</span>(nums[i ++], nums[j --]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(); k %= n;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>题目描述：给出一个数组，算出每个位置的除了此位置的其余元素乘积</p>
<p>思路：前后缀；总乘积（无法处理含 0  元素的情况）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            suf[i] = suf[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans[i] = pre[i] * suf[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果一个在范围内的数([1, n])没有放到正确的位置, 就纠正其位置</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) <span class="comment">// 此位置一直处理到合理或换过来一个不在范围内的数字</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 占用了内存空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: nums) <span class="keyword">if</span>(e &gt;=<span class="number">1</span> &amp;&amp; e &lt;= n) hash.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nums[i]&gt; 0 &amp;&amp; nums[i]&lt;= nums.size() &amp;&amp; nums[i]!=i+1 &amp;&amp; nums[nums[i]-1]!=nums[i]</code> 中 nums[i]&gt; 0 &amp;&amp; nums[i]&lt;&#x3D; nums.size() 表示只处理数组中值在 1 - n  之间的元素，nums[i]!&#x3D;i+1 &amp;&amp; nums[nums[i]-1]!&#x3D;nums[i] 表示在 num[i] 没有到位，且目的地处没有被同样的值占据的时候才执行交换</li>
</ul>
<h4 id="73-矩阵原地置零"><a href="#73-矩阵原地置零" class="headerlink" title="73. 矩阵原地置零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵原地置零</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(); <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> row1 = <span class="number">1</span>, col1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;row1 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;col1 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j ++)</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">fill</span>(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>) <span class="built_in">fill</span>(matrix[<span class="number">0</span>].<span class="built_in">begin</span>(), matrix[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="54-螺旋遍历矩阵"><a href="#54-螺旋遍历矩阵" class="headerlink" title="54. 螺旋遍历矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋遍历矩阵</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设边界</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) res.<span class="built_in">push_back</span>(matrix[t][i]); <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= b; i++) res.<span class="built_in">push_back</span>(matrix[i][r]); <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; i--) res.<span class="built_in">push_back</span>(matrix[b][i]); <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= t; i--) res.<span class="built_in">push_back</span>(matrix[i][l]); <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(columns));</span><br><span class="line">        <span class="type">int</span> total = rows * columns;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(total)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order[i] = matrix[row][column];</span><br><span class="line">            visited[row][column] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="48-矩阵顺时针90度"><a href="#48-矩阵顺时针90度" class="headerlink" title="48. 矩阵顺时针90度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 矩阵顺时针90度</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接分析出映射关系，需要借助备份矩阵</span></span><br><span class="line">、<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 深拷贝 matrix -&gt; tmp</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp = matrix;</span><br><span class="line">        <span class="comment">// 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺时针 90 ： 先转置，再行reverse; 先列reverse,再转置</span></span><br><span class="line"><span class="comment">// 逆时针 90 ： 先转置，再列reverse; 先行reverse,再转置</span></span><br></pre></td></tr></table></figure>

<h4 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h4><p>题目描述：一个矩阵，里面的数字行里面是升序的，列里面是升序的，请问如何设计一个搜索算法在其中搜索数字 target</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 还有剩余元素</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到 target</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">                i++; <span class="comment">// 这一行剩余元素全部小于 target，排除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--; <span class="comment">// 这一列剩余元素全部大于 target，排除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="160-链表交叉点"><a href="#160-链表交叉点" class="headerlink" title="160. 链表交叉点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 链表交叉点</a></h4><p>题目描述：找到链表的交叉点</p>
<p>思路：</p>
<ol>
<li>若相交，链表A： a+c, 链表B : b+c. a+c+b+c &#x3D; b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b &#x3D; b+a 。因此相遇处是NULL</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pA) pA = headB; <span class="keyword">else</span> pA = pA-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!pB) pB = headA; <span class="keyword">else</span> pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用哈希表检验是否在集合内</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hash;</span><br><span class="line">        ListNode * p = headA;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;hash.<span class="built_in">insert</span>(p); p = p-&gt;next;&#125;</span><br><span class="line">        p = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;<span class="keyword">if</span>(hash.<span class="built_in">count</span>(p)) <span class="keyword">return</span> p; p = p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>去长</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* h1, ListNode* h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!h1 || !h2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *a = h1, *b = h2;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a-&gt;next != <span class="literal">nullptr</span>) &#123; a = a-&gt;next; lenA ++;&#125;</span><br><span class="line">        <span class="keyword">while</span> (b-&gt;next != <span class="literal">nullptr</span>) &#123; b = b-&gt;next; lenB ++;&#125;</span><br><span class="line">        a = h1; b = h2; <span class="comment">// 去长</span></span><br><span class="line">        <span class="keyword">while</span>(lenA &gt; lenB) &#123;a = a-&gt;next; lenA --;&#125;</span><br><span class="line">        <span class="keyword">while</span>(lenB &gt; lenA) &#123;b = b-&gt;next; lenB --;&#125;</span><br><span class="line">        <span class="keyword">while</span>(a != b) &#123;a = a-&gt; next; b = b-&gt; next;&#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><ul>
<li>双指针法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * cur = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>头插法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode * cur;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cur-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = cur;</span><br><span class="line">            cur = head-&gt;next;</span><br><span class="line">            head-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表为空或者仅一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = <span class="built_in">reverseList</span>(head-&gt;next); <span class="comment">// 只负责向下递，然后把最后一个节点指针通过ret带回到入口;</span></span><br><span class="line">        <span class="comment">// 动作是从倒数第二个节点网往前做，每个节点都是一样动作</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归相当于利用参数压栈，保留了前面方法里的那个 t</li>
</ul>
<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h4><ul>
<li>思路：反转后半段，然后双指针比对</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">        <span class="keyword">auto</span> head2 = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历一遍反转，反转前半段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        ListNode *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            p = slow;</span><br><span class="line">            slow = slow-&gt;next;    <span class="comment">//快慢遍历</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast)  <span class="comment">//奇数个节点时跳过中间节点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;       <span class="comment">//前半部分和后半部分比较</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != slow-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s; ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123; s.<span class="built_in">push</span>(p-&gt;val); p = p-&gt;next;&#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != s.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>(); p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><ul>
<li>快慢指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head; <span class="comment">// 乌龟和兔子同时从起点出发</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 乌龟走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 兔子走两步</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="comment">// 兔子追上乌龟（套圈），说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 访问到了链表末尾，无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hash;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(head)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            hash.<span class="built_in">insert</span>(head); head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II-找环入口"><a href="#142-环形链表-II-找环入口" class="headerlink" title="142. 环形链表 II 找环入口"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II 找环入口</a></h4><ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) <span class="keyword">return</span> head;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>快慢指针：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/?envType=study-plan-v2&envId=top-100-liked">原理讲解</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (slow != head) <span class="comment">// 关键要明白一旦有环，通过这种方式一定可以找到环入口</span></span><br><span class="line">                &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="21-两个有序链表的merge"><a href="#21-两个有序链表的merge" class="headerlink" title="21. 两个有序链表的merge"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 两个有序链表的merge</a></h4><ul>
<li>直观merge</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21.</span> 合并两个有序链表<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* dum = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), * cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 != <span class="literal">nullptr</span> ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//归并模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 两个都存在</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">	<span class="comment">// 剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l2)  <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-链表大数加法"><a href="#2-链表大数加法" class="headerlink" title="2. 链表大数加法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">2. 链表大数加法</a></h4><ul>
<li>迭代方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), * cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || t) <span class="comment">// 只要有一个在就循环这个逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1) t += l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l2) t += l2-&gt;val;</span><br><span class="line">            ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> carry ? <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry) : <span class="literal">nullptr</span>; <span class="comment">// 如果进位了，就额外创建一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            <span class="built_in">swap</span>(l1, l2); <span class="comment">// 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = carry + l1-&gt;val + (l2 ? l2-&gt;val : <span class="number">0</span>); <span class="comment">// 节点值和进位加在一起</span></span><br><span class="line">        l1-&gt;val = sum % <span class="number">10</span>; <span class="comment">// 每个节点保存一个数位</span></span><br><span class="line">        l1-&gt;next = <span class="built_in">addTwoNumbers</span>(l1-&gt;next, (l2 ? l2-&gt;next : <span class="literal">nullptr</span>), sum / <span class="number">10</span>); <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * right = dummy, * left = dummy;</span><br><span class="line">        <span class="keyword">while</span>(n --) right = right-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(right-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样获得处理链表时的边界感？就如同<code>while(right-&gt;next)</code> 这里的条件可以根据需要控制指向最后一个实体元素，也可以指向 nullptr。</li>
</ul>
<h4 id="24-两个一组交换链表中的节点"><a href="#24-两个一组交换链表中的节点" class="headerlink" title="24. 两个一组交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两个一组交换链表中的节点</a></h4><ul>
<li>迭代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * node0 = dummy;</span><br><span class="line">        ListNode * node1 = node0 -&gt; next, *node2, *node3;</span><br><span class="line">        <span class="keyword">while</span>(node1 &amp;&amp; node1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            node2 = node1-&gt;next;</span><br><span class="line">            node3 = node2-&gt;next;</span><br><span class="line"></span><br><span class="line">            node0-&gt;next = node2;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            node1-&gt;next = node3;</span><br><span class="line"></span><br><span class="line">            node0 = node1;</span><br><span class="line">            node1 = node3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>何时需要哨兵 dummy? 可能会改动头结点的时候。</p>
</li>
<li><p>递归</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> node1 = head;</span><br><span class="line">        <span class="keyword">auto</span> node2 = head-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> node3 = node2-&gt;next;</span><br><span class="line"></span><br><span class="line">        node1-&gt;next = <span class="built_in">swapPairs</span>(node3); <span class="comment">// 1 指向递归返回的链表头</span></span><br><span class="line">        node2-&gt;next = node1; <span class="comment">// 2 指向 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node2; <span class="comment">// 返回交换后的链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * cur = head; <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;cur = cur-&gt;next; n ++;&#125; <span class="comment">// 先数出来个数这个处理避免了最后一段的麻烦</span></span><br><span class="line"></span><br><span class="line">        ListNode * tail = dummy;</span><br><span class="line"></span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(; n &gt;= k; n -= k)</span><br><span class="line">        &#123;   <span class="comment">// 段内翻转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) </span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * t = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 段连接</span></span><br><span class="line">            ListNode *<span class="type">new_t</span> = tail-&gt;next;</span><br><span class="line">            <span class="type">new_t</span>-&gt;next = cur;</span><br><span class="line">            tail-&gt;next = pre;</span><br><span class="line">            tail = <span class="type">new_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="138-随机链表深拷贝"><a href="#138-随机链表深拷贝" class="headerlink" title="138. 随机链表深拷贝"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表深拷贝</a></h4><ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node *, Node*&gt; mp; </span><br><span class="line">        Node * dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>), * cur = dummy;</span><br><span class="line">        Node * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            Node * node = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            mp[p] = node;</span><br><span class="line">            cur = cur -&gt; next = node;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dummy-&gt;next; p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;random = mp[p-&gt;random];</span><br><span class="line">            cur = cur-&gt;next; p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>原地方法：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/889447/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/?envType=study-plan-v2&envId=top-100-liked">这里</a></li>
</ul>
<h4 id="148-链表排序"><a href="#148-链表排序" class="headerlink" title="148. 链表排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 链表排序</a></h4><p>链表下的排序算法整理：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/solutions/2400774/ge-chong-pai-xu-suan-fa-jie-jue-mou-pao-9dwmt/?envType=study-plan-v2&envId=top-100-liked">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN);</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = cur-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> p = dummy;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val) p = p-&gt;next;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h4><ul>
<li>小根堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> ListNode*a, <span class="type">const</span> ListNode* b) &#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head: lists) <span class="keyword">if</span>(head) pq.<span class="built_in">push</span>(head);</span><br><span class="line"></span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next) pq.<span class="built_in">push</span>(node-&gt;next);</span><br><span class="line">            cur = cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>priority_queue 默认是大根堆，小根堆要重载</li>
<li>decltype(cmp) 进行模版实例化</li>
</ul>
<h4 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode * root, vector&lt;<span class="type">int</span>&gt; &amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">inorder</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(root || !stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root) &#123;stk.<span class="built_in">push</span>(root); root = root-&gt;left;&#125; <span class="comment">// 左侧路径全部进栈</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Morris 中序遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) </span><br><span class="line">            &#123;</span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right &amp;&amp; predecessor-&gt;right != root) predecessor = predecessor-&gt;right;</span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (!predecessor-&gt;right) &#123;predecessor-&gt;right = root; root = root-&gt;left;&#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;res.<span class="built_in">push_back</span>(root-&gt;val); root = root-&gt;right;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>![image-20241021161319977](.&#x2F;hot 100&#x2F;image-20241021161319977.png)</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">            <span class="type">int</span> sz = Q.<span class="built_in">size</span>(); <span class="comment">// 每次处理一层</span></span><br><span class="line">            <span class="keyword">while</span> (sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode* node = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                sz -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 翻转左子树</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">invertTree</span>(root-&gt;right); <span class="comment">// 翻转右子树</span></span><br><span class="line">        root-&gt;left = right; <span class="comment">// 交换左右儿子</span></span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自顶向下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right); <span class="comment">// 交换左右儿子</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 翻转左子树</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right); <span class="comment">// 翻转右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p == q;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* node) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 下面 +1 后，对于叶子节点就刚好是 0</span></span><br><span class="line">            <span class="type">int</span> l_len = <span class="built_in">dfs</span>(dfs, node-&gt;left) + <span class="number">1</span>; <span class="comment">// 左子树最大链长+1</span></span><br><span class="line">            <span class="type">int</span> r_len = <span class="built_in">dfs</span>(dfs, node-&gt;right) + <span class="number">1</span>; <span class="comment">// 右子树最大链长+1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l_len + r_len); <span class="comment">// 两条链拼成路径</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l_len, r_len); <span class="comment">// 当前子树最大链长</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>转化成了树深度问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = INT_MIN;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>写递归的一开始就需要想明白要返回什么，如此才能在递归逻辑中正确利用子问题的返回值。</li>
</ul>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; cur = &#123;root&#125;;</span><br><span class="line">        <span class="keyword">while</span> (cur.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; nxt; <span class="comment">// 下一层的节点</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : cur) &#123;</span><br><span class="line">                vals.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)  nxt.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) nxt.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = <span class="built_in">move</span>(nxt); <span class="comment">// 下一层节点交接</span></span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans; <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q; q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>(); ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());<span class="comment">// 按层处理</span></span><br><span class="line">            <span class="keyword">while</span>(n --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>分层处理的技巧，就是每一层入口处统计队里的数量</li>
<li>对于树的遍历用到的容器，容器元素放节点，从而方便用节点找左右子树</li>
</ul>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> m = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[m],<span class="built_in">dfs</span>(nums,left,m),<span class="built_in">dfs</span>(nums,m + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/">详细理解</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> left = LLONG_MIN, <span class="type">long</span> <span class="type">long</span> right = LLONG_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &amp;&amp; x &lt; right &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;left, left, x) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right,x,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre = LLONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;left) || root-&gt;val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;LLONG_MAX, LLONG_MIN&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>[l_min, l_max] = <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span>[r_min, r_max] = <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = node-&gt;val;</span><br><span class="line">        <span class="comment">// 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= l_max || x &gt;= r_min) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;LLONG_MIN, LLONG_MAX&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">min</span>(l_min, x), <span class="built_in">max</span>(r_max, x)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root).second != LLONG_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; k)</span> </span>&#123; <span class="comment">// 注意这里改成了引用</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 题目保证节点值非负，用 -1 表示没有找到</span></span><br><span class="line">        <span class="type">int</span> left_res = <span class="built_in">kthSmallest</span>(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span> (left_res != <span class="number">-1</span>) <span class="keyword">return</span> left_res; <span class="comment">// 答案在左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;right, k); <span class="comment">// 右子树会返回答案或者 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* node) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 题目保证节点值非负，用 -1 表示没有找到</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left_res = <span class="built_in">dfs</span>(dfs, node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (left_res != <span class="number">-1</span>) &#123; <span class="comment">// 答案在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> left_res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123; <span class="comment">// 答案就是当前节点</span></span><br><span class="line">                <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, node-&gt;right); <span class="comment">// 右子树会返回答案或者 -1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == ans.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode * pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right) pre = pre-&gt;right; <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                pre-&gt;right = root-&gt;right;   <span class="comment">// 右子树接到左子树最右节点</span></span><br><span class="line">                root-&gt;right = root-&gt;left;   <span class="comment">// 左子树接到右子树的位置</span></span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>待理解的算法：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked</a></li>
</ul>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> left_size = ranges::<span class="built_in">find</span>(inorder, preorder[<span class="number">0</span>]) - inorder.<span class="built_in">begin</span>(); <span class="comment">// 左子树的大小</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre1</span><span class="params">(preorder.begin() + <span class="number">1</span>, preorder.begin() + <span class="number">1</span> + left_size)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre2</span><span class="params">(preorder.begin() + <span class="number">1</span> + left_size, preorder.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in1</span><span class="params">(inorder.begin(), inorder.begin() + left_size)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in2</span><span class="params">(inorder.begin() + <span class="number">1</span> + left_size, inorder.end())</span></span>;</span><br><span class="line">        TreeNode *left = <span class="built_in">buildTree</span>(pre1, in1);</span><br><span class="line">        TreeNode *right = <span class="built_in">buildTree</span>(pre2, in2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>], left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) index[inorder[i]] = i;</span><br><span class="line"></span><br><span class="line">        function&lt;TreeNode*(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> pre_l, <span class="type">int</span> pre_r, <span class="type">int</span> in_l, <span class="type">int</span> in_r) -&gt; TreeNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre_l == pre_r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="type">int</span> left_size = index[preorder[pre_l]] - in_l; <span class="comment">// 左子树的大小</span></span><br><span class="line">            TreeNode *left = <span class="built_in">dfs</span>(pre_l + <span class="number">1</span>, pre_l + <span class="number">1</span> + left_size, in_l, in_l + left_size);</span><br><span class="line">            TreeNode *right = <span class="built_in">dfs</span>(pre_l + <span class="number">1</span> + left_size, pre_r, in_l + <span class="number">1</span> + left_size, in_r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pre_l], left, right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n, <span class="number">0</span>, n); <span class="comment">// 左闭右开区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>后序 + 中序 构建：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2646359/tu-jie-cong-on2-dao-onpythonjavacgojsrus-aob8/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2646359/tu-jie-cong-on2-dao-onpythonjavacgojsrus-aob8/</a></li>
</ul>
<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">int</span> t;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; cnt&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode * node, <span class="type">long</span> <span class="type">long</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        s += node-&gt;val;</span><br><span class="line">        ans += cnt.<span class="built_in">count</span>(s - t) ? cnt[s - t] : <span class="number">0</span>;</span><br><span class="line">        cnt[s] ++;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, s);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, s);</span><br><span class="line">        cnt[s] --;  <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        t = targetSum;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 遇到 p 或 q 就可以返回</span></span><br><span class="line">        TreeNode * left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode * right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">max</span>( root-&gt;val + l, root-&gt;val + r);</span><br><span class="line">        t = <span class="built_in">max</span>(t, root-&gt;val);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(root-&gt;val + l + r,t));</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(); <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123; <span class="built_in">dfs</span>(grid, i, j); cnt++;&#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">inArea</span>(grid, i, j)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]!=<span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">+1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>岛屿问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(); <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123; <span class="type">int</span> a = <span class="built_in">dfs</span>(grid, i, j); cnt = <span class="built_in">max</span>(cnt, a);&#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">inArea</span>(grid, i, j)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i<span class="number">+1</span>, j)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i, j<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><p>题目描述：一个 m 行 n 列矩阵，初始时刻有若干坏橘子，和若干好橘子，其余为空位。已知坏橘子周围好橘子在下一刻会变成坏橘子。问全部橘子腐烂需要多久？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> DIRECTIONS[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 四方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) fresh ++; <span class="comment">// 统计新鲜橘子个数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">emplace_back</span>(i, j); <span class="comment">// 一开始就腐烂的橘子</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fresh &amp;&amp; !q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans++; <span class="comment">// 经过一分钟</span></span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nxt; <span class="comment">// 层序遍历已经开始用这种技术了？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : q) </span><br><span class="line">            &#123; <span class="comment">// 已经腐烂的橘子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> d : DIRECTIONS) </span><br><span class="line">                &#123; <span class="comment">// 四方向</span></span><br><span class="line">                    <span class="type">int</span> i = x + d[<span class="number">0</span>], j = y + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= i &amp;&amp; i &lt; m &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; n &amp;&amp; grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                    &#123; <span class="comment">// 新鲜橘子</span></span><br><span class="line">                        fresh--;</span><br><span class="line">                        grid[i][j] = <span class="number">2</span>; <span class="comment">// 变成腐烂橘子</span></span><br><span class="line">                        nxt.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q = <span class="built_in">move</span>(nxt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;<span class="comment">//准备一个vector记录每个节点（课）的入度</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; map;<span class="comment">//准备一个哈希表/二维邻接矩阵记录课与课（节点）之间的关系 int -&gt; vector&lt;int&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++ i) &#123;<span class="comment">//遍历所有requistes，获取入度和所有关系</span></span><br><span class="line">            inDegree[prerequisites[i][<span class="number">0</span>]] ++; <span class="comment">//记录入度</span></span><br><span class="line">            map[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);<span class="comment">//记录所有关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个队列，进行BFS广度优先遍历，遍历入度为0的课</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i); <span class="comment">//将入度为0的课放入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//用于记录有多少门课已经上过了</span></span><br><span class="line">        <span class="comment">//遍历inDegree，更新入度，更新inDegree，直到inDegree的size为0，再确认count是否等于numCourses</span></span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> selected = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//更新所有关联课程的入度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; map[selected].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[map[selected][i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    inDegree[map[selected][i]]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[map[selected][i]] == <span class="number">0</span>) </span><br><span class="line">                        que.<span class="built_in">push</span>(map[selected][i]);<span class="comment">//将入度降至0的课程放入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mem[n]) <span class="keyword">return</span> mem[n];</span><br><span class="line">        mem[n] = <span class="built_in">dfs</span>(n - <span class="number">1</span>) + <span class="built_in">dfs</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        mem.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">1</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = f1 + f0;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            c[i].<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="comment">// dfs(i) 表示从 nums[0] 到 nums[i] 最多能偷多少</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 递归边界（没有房子）</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i]; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>), <span class="built_in">dfs</span>(dfs, i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, n - <span class="number">1</span>); <span class="comment">// 从最后一个房子开始思考</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            f[i + <span class="number">2</span>] = <span class="built_in">max</span>(f[i + <span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = <span class="built_in">max</span>(f1, f0 + x);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">sky</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
