<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>next 主题基本设置</title>
    <url>/2023/09/03/next%E4%B8%BB%E9%A2%98%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>为博客更换 next 主题，并做基础设置，使其能用。</p>
<span id="more"></span>

<ol>
<li><h2 id="更换next主题"><a href="#更换next主题" class="headerlink" title="更换next主题"></a>更换next主题</h2><ol>
<li><p>从<a href="https://github.com/hexojs/hexo/wiki/Themes#n">hexo主题库</a>中找一款中意的下载到 blog-dir&#x2F;themes 文件夹中</p>
</li>
<li><p>设置 hexo 配置文件 <code>_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Extensions</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next  # 这里的主题名字要和themes文件夹中下载的主题文件夹名字一致</span><br></pre></td></tr></table></figure>

<p>将这里改为你下载的主题，顺便选 next 的原因是维护比较好，界面简约</p>
</li>
<li><p>然后 <code>hexo g</code> <code>hexo d</code> 就完成主题更换。</p>
</li>
</ol>
</li>
<li><h2 id="next-主题优化"><a href="#next-主题优化" class="headerlink" title="next 主题优化"></a>next 主题优化</h2><p>现在有两个关键配置文件，</p>
<ul>
<li>一个是 <code>site-dir\themes\next</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>另一个是<code>site-dir</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>两个文件同名，但是前者是关于 next 主题的配置，后者是关于 hexo 博客的配置。</li>
</ul>
<ol>
<li><h3 id="站点基本配置信息"><a href="#站点基本配置信息" class="headerlink" title="站点基本配置信息"></a>站点基本配置信息</h3><p>更改 hexo 配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Site</span></span><br><span class="line">title: Focus2flow</span><br><span class="line">subtitle: &#x27;less is more&#x27;</span><br><span class="line">description: &#x27;技术，人生，思考，自我&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: sky</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="更改-next-的-scheme"><a href="#更改-next-的-scheme" class="headerlink" title="更改 next 的 scheme"></a>更改 next 的 scheme</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Schemes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Muse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Mist</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>添加标签，分类关于三个页面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在 next 配置文件中打开这三个开关</span></span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 hexo 命令在 <span class="built_in">source</span> 目录下创建三个文件夹</span></span><br><span class="line">hexo n page about</span><br><span class="line">hexo n page tags</span><br><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure>

<p>此时在四个文件夹中自动生成了对应页面的 md 文档，hexo s 运行博客也可以在首页访问到对应页面，问题是这四个功能页面跟普通的post中的内容页面是有区别的，具体来讲：</p>
<ul>
<li>about 页暂不清楚</li>
<li>tags 页要根据 post 中博文在文件头部设置的标签对文章进行分类</li>
<li>categories 页要根据类别进行分类，类似于文件夹</li>
<li>archives 页对本博客所有文章按时间轴列出</li>
</ul>
<p>因此需要对这这些功能文件在文件头部用 type 字段进行说明，next 识别到类型说明才能启动对应的算法从 post 里的博文里统计并呈现对应信息。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903215225417.png" alt="image-20230903215225417"></p>
<p>那么写博文时候怎样设置 tags catagories 呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置标签</span></span><br><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置分类</span></span><br><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种设置方法</span></span><br><span class="line">tags: [&quot;tag1&quot;,&quot;tag2&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h3><p>在你认为合适的地方添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><ol>
<li><p>安装 <a href="https://links.jianshu.com/go?to=https://github.com/flashlab/hexo-generator-search">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开站点配置文件找到 <code>Extensions</code> 在下面添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3、打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
</li>
</ol>
</li>
</ol>
<p>至此就是一个打开可以用起来的博客了，那么梳理一下写新文章的合理步骤：</p>
<ol>
<li><code>hexo n name </code> 在 post 中生成一个带文件头的 md 文档</li>
<li>typora 接管文档，写博客</li>
<li>写完之后 hexo 生成，部署</li>
</ol>
<p><strong>参考文章：</strong></p>
<p><a href="https://hexo.io/">hexo 官方文档</a></p>
<p><a href="https://theme-next.js.org/">next 官方文档</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&mid=2247488750&idx=1&sn=bddb76b8e85d04b303b3d10024b8a56b&chksm=eb47150adc309c1cfe5f847acaf6a3eb7de3efb3c7f2a87e708a686a740aa364c33c80ea3000&token=1693393167&lang=zh_CN#rd">博客的意义</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">基础优化</a></p>
<p><strong>未来优化方向：</strong></p>
<p><a href="https://www.lovebykin.com/4288776826/">鉴于分类页太丑</a></p>
<p><a href="https://blog.juanertu.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一个系列博客有机会再优化</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC奖学金体系</title>
    <url>/2023/09/04/UESTC%E5%A5%96%E5%AD%A6%E9%87%91%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>学习一下成电的奖学金体系</p>
<span id="more"></span>

<ul>
<li><h1 id="奖学金体系"><a href="#奖学金体系" class="headerlink" title="奖学金体系"></a>奖学金体系</h1><ul>
<li>学业<ul>
<li>金额：10000&#x2F;8000&#x2F;4000</li>
<li>评定时间：9月中上旬</li>
<li>申请制：需要提交佐证材料</li>
</ul>
</li>
<li>国家<ul>
<li>金额：硕2万，博3万</li>
<li>评定时间：9月中下旬，学业奖学金之后</li>
<li>申请制：大约也是按照学业奖学金的那套细则</li>
</ul>
</li>
<li>专项<ul>
<li>小米<ul>
<li>金额：2万，10个名额</li>
<li>时间：1月上旬</li>
<li>可与国奖兼得</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ul>
<li>国奖与专项不可兼得，专项有特殊说明的除外</li>
</ul>
</li>
<li><h1 id="评定办法"><a href="#评定办法" class="headerlink" title="评定办法"></a>评定办法</h1><ul>
<li>研二：综合素质得分&#x3D;学业成绩得分+科研成果得分+素质发展得分+导师评价得分</li>
<li>研三：综合素质得分&#x3D;科研成果得分+素质发展得分+导师评价得分</li>
</ul>
</li>
<li><h1 id="综合素质得分细则"><a href="#综合素质得分细则" class="headerlink" title="综合素质得分细则"></a>综合素质得分细则</h1><ul>
<li><h2 id="科研成果"><a href="#科研成果" class="headerlink" title="科研成果"></a>科研成果</h2><ul>
<li><h3 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904093901825.png" alt="image-20230904093901825"></p>
</li>
<li><h3 id="专利软著"><a href="#专利软著" class="headerlink" title="专利软著"></a>专利软著</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094106297.png" alt="image-20230904094106297"></p>
</li>
<li><h3 id="教材或专著"><a href="#教材或专著" class="headerlink" title="教材或专著"></a>教材或专著</h3><p>学生参与编写教材或专著的（须在作者列表中），提交相关材料，由评审委员会认定加分，上限 8 分。</p>
</li>
<li><h3 id="科技获奖"><a href="#科技获奖" class="headerlink" title="科技获奖"></a>科技获奖</h3><ul>
<li>获得国家科技奖励，省部级科技一等奖，可直接定为学业奖学金一等奖</li>
<li>省部级科技二等奖、三等奖在原有奖学金基础上提升一等级</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="素质发展"><a href="#素质发展" class="headerlink" title="素质发展"></a>素质发展</h2><ul>
<li><h3 id="科技竞赛"><a href="#科技竞赛" class="headerlink" title="科技竞赛"></a>科技竞赛</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094921145.png" alt="image-20230904094921145"></p>
<ul>
<li>A类竞赛包括<ul>
<li>中国“互联网+”大学生创新创业大赛</li>
<li>“挑战杯”全国大学生课外学术科技作品竞赛</li>
<li>“挑战杯”中国大学生创业计划大赛</li>
<li><a href="https://cpipc.acge.org.cn/">中国研究生创新实践系列大赛</a><ul>
<li>中国研究生智慧城市技术与创意设计赛</li>
<li>中国研究生未来飞行器创新赛</li>
<li>中国研究生数学建模竞赛</li>
<li>中国研究生电子设计竞赛</li>
<li>中国研究生创“芯”大赛</li>
<li>中国研究生人工智能创新大赛</li>
<li>中国研究生机器人创新设计大赛</li>
<li>中国能源装备创新设计大赛</li>
<li>中国研究生公共管理案例大赛</li>
<li>中国研究生乡村振兴科技强农+创新大赛</li>
<li>中国研究生网络安全创新大赛</li>
<li>中国研究生“双碳”创新与创意大赛</li>
<li>中国研究生金融科技创新大赛</li>
</ul>
</li>
</ul>
</li>
<li>B类竞赛<ul>
<li>纳入研究生院研究生科技创新支持计划的其他竞赛<ul>
<li>全国大学生FPGA 创新设计竞赛</li>
<li>中兴捧月大赛</li>
<li>IEEEXtreme 极限编程大赛</li>
<li>全国大学生集成电路创新创业大赛</li>
<li>全国大学生嵌入式芯片与系统设计大赛</li>
<li>全国大学生集成电路EDA设计精英挑战赛</li>
<li>BOE 创新挑战赛</li>
<li>华为软件精英挑战赛</li>
<li>中国研究生电子设计竞赛商业计划书专项赛</li>
</ul>
</li>
<li>由我国政府教育行政主管部门、专业教学指导委员会，专业学术组织，主办的学术科技类比赛</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="学生骨干"><a href="#学生骨干" class="headerlink" title="学生骨干"></a>学生骨干</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904095600951.png" alt="image-20230904095600951"></p>
<ul>
<li>研究生会、研究生党建委员会若本年度获得学校表彰，成员可根据所在组织考评结果增加 1 分</li>
<li>党支部若获得本年度校级以上“先进党支部”称号，根据党支部评议结果，排名前 50%的党支部成员（以党支部正式党员、预备党员人数为基数）增加 1 分，院级减半</li>
</ul>
</li>
<li><h3 id="公益事业"><a href="#公益事业" class="headerlink" title="公益事业"></a>公益事业</h3><ul>
<li>参与志愿者等有突出表现，加 1 分，获得奖励的追加0.5分。可累加，上限为2 分</li>
</ul>
</li>
<li><h3 id="社会实践"><a href="#社会实践" class="headerlink" title="社会实践"></a>社会实践</h3><ul>
<li>参加扶贫、支教、国际组织实习、基层挂职锻炼项目等加 2 分，获得奖励的追加 1 分。可累加，上限 6 分。</li>
</ul>
</li>
<li><h3 id="综合素质比赛"><a href="#综合素质比赛" class="headerlink" title="综合素质比赛"></a>综合素质比赛</h3><ul>
<li>参加由我国政府教育行政主管部门、专业教学指导委员会、专业学术组织和学校学院主办的综合素质类比赛并获奖的，国家级加3分，省市级加 2 分，校级院级加 1 分，上限为 3 分。</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="导师评价"><a href="#导师评价" class="headerlink" title="导师评价"></a>导师评价</h2><ul>
<li><p>评分采取“<strong>科研团队（或导师）总分</strong>+<strong>内部分级</strong>”的方式</p>
</li>
<li><p>每个科研团队（或导师）拥有一个总评分，即该团队（或导师）门下具有参评奖学金资格的<strong>学生人数</strong>×<strong>学生人均分 15 分</strong>＝总评分</p>
</li>
<li><p>评分区间为5—20分，最后学生个人得分的加总不能超过团队（或导师）拥有的总评分。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904100133437.png" alt="image-20230904100133437"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>综合分析：</strong></p>
<p>其实比赛啊，支部啊，意义不大。做真科研，才是真正有长远发展的事情。</p>
]]></content>
      <tags>
        <tag>研究生</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows  环境下利用 Github page 搭建博客环境</title>
    <url>/2023/09/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Github + hexo 搭建个人博客</p>
<span id="more"></span>

<ol>
<li><h2 id="本地环境准备"><a href="#本地环境准备" class="headerlink" title="本地环境准备"></a>本地环境准备</h2><ol>
<li><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><blockquote>
<p>目的是为了利用 git 和 Github 仓库进行交互</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/download/win">下载官方 git</a>，选择合适版本，</li>
<li>将 git 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>git version</code>,检查是否安装并设置成功。</li>
</ul>
</li>
<li><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><blockquote>
<p>目的是使用其包管理软件 npm 安装 hexo ，也可能与 hexo s 命令有关</p>
</blockquote>
<ul>
<li><a href="https://nodejs.org/en/download">下载官方 nodejs</a>，选择合适版本</li>
<li>将 node 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>node -v</code>,检查是否安装并设置成功</li>
</ul>
</li>
<li><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><blockquote>
<p>hexo 是一款优秀的博客管理软件？这样定位不知道是否合适</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install hexo -g</code> 安装</li>
<li>在 git-bash 中使用命令 <code>hexo -v</code> 验证安装</li>
</ul>
</li>
<li><h3 id="安装-hexo-developer-git"><a href="#安装-hexo-developer-git" class="headerlink" title="安装 hexo-developer-git"></a>安装 hexo-developer-git</h3><blockquote>
<p>这个是 <code>hexo d</code> 命令中将本地编译好的博客部署到 github 仓库时，hexo 和 git 交互的软件</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install --save hexo-deployer-git</code> 安装</li>
</ul>
</li>
</ol>
</li>
<li><h2 id="Github-仓库设置"><a href="#Github-仓库设置" class="headerlink" title="Github 仓库设置"></a>Github 仓库设置</h2><ol>
<li><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><blockquote>
<p>默认情况下 github 允许每一个用户建立一个博客仓库</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903131724407.png" alt="image-20230903131724407"></p>
<p>这里似乎并不能看出这个仓库是专用于搭建博客用的，有待将来研究 Github Pages 的说明。</p>
</li>
</ol>
</li>
<li><h2 id="Git-与-Github-交互设置"><a href="#Git-与-Github-交互设置" class="headerlink" title="Git 与 Github 交互设置"></a>Git 与 Github 交互设置</h2><ol>
<li><h3 id="Git-客户端生成-ssh-公钥"><a href="#Git-客户端生成-ssh-公钥" class="headerlink" title="Git 客户端生成 ssh 公钥"></a>Git 客户端生成 ssh 公钥</h3><ol>
<li><p>在 git-bash 中使用 <code>ssh-keygen -t rsa -C &quot;example@email.com&quot;</code>生成密钥对</p>
</li>
<li><p><code>cd ~/.ssh</code> 进入到 ssh 本地秘钥文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README.md  config  id_rsa  id_rsa.pub  known_hosts  known_hosts.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其中的公钥 <code>id_rsa.pub</code> 的内容复制出来</p>
</li>
</ol>
</li>
<li><h3 id="Github-添加-Git-产生的公钥"><a href="#Github-添加-Git-产生的公钥" class="headerlink" title="Github 添加 Git 产生的公钥"></a>Github 添加 Git 产生的公钥</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903134218399.png" alt="image-20230903134218399"></p>
</li>
<li><h3 id="使用-ssh-T-git-github-com-命令测试是否成功"><a href="#使用-ssh-T-git-github-com-命令测试是否成功" class="headerlink" title="使用 ssh -T git@github.com 命令测试是否成功"></a>使用 <code>ssh -T git@github.com</code> 命令测试是否成功</h3></li>
<li><h3 id="设置-Git-用户名和邮箱"><a href="#设置-Git-用户名和邮箱" class="headerlink" title="设置 Git 用户名和邮箱"></a>设置 Git 用户名和邮箱</h3><ul>
<li>设置用户名：<code>git config --global user.name &quot;ColorMao&quot;</code></li>
<li>设置邮箱：<code>git config --global user.email &quot;zhangyumao@petalmail.com&quot;</code></li>
</ul>
</li>
</ol>
</li>
<li><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><ol>
<li><p>在本机合适的位置建立一个存放本地博客文件的文件夹，如我的：<code>E:\Blogs\Focus2flow</code>，git-bash 进入该空文件夹</p>
</li>
<li><p>使用 hexo 本地部署博客</p>
<ol>
<li><code>hexo init</code> 初始化博客文件</li>
<li><code>hexo generate</code> 编译生成可部署的 html 文件</li>
<li><code>hexo server</code> 本地部博客用于预览</li>
</ol>
</li>
<li><p>博客部署到仓库</p>
<ol>
<li><p>在博客文件夹根目录找到 hexo 配置文件 <code>_config.yml</code></p>
</li>
<li><p>更改其中的配置选项为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:captain0X01/captain0X01.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo deploy</code> 部署到 GIthub仓库</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142806727.png" alt="image-20230903142806727"></p>
<p>可以观察到文件确实推上去了，那么远程访问一下博客。</p>
</li>
<li><p>访问博客<a href="https://yimaginer.github.io/">https://yimaginer.github.io/</a></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142952837.png" alt="image-20230903142952837"></p>
<p>访问成功，至此我们在 Github 上搭建了一个幼儿园级的个人博客</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="新增博文"><a href="#新增博文" class="headerlink" title="新增博文"></a>新增博文</h2><ol>
<li><p>将写好的 markdown 文档放进 site-dir&#x2F;source&#x2F;_posts 文件夹中</p>
</li>
<li><p><code>hexo generate</code> 重新生成</p>
</li>
<li><p><code>hexo deploy</code> 部署，如图</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903144752739.png" alt="image-20230903144752739"></p>
</li>
<li><p>这样一个幼儿园博客，就实际使用来看还有下面的差距，如图编号</p>
<ol>
<li>博文是全篇展开放在主页，不科学</li>
<li>这个引用文字的格式转换成了这样，是这个默认主题的原因</li>
<li>新上传的文章没有标题，不行</li>
<li>博客的名称还是默认的，要改</li>
<li>顺便这配色不怎么好看</li>
</ol>
</li>
<li><p>接下里通过换一个主题，并进行设置，打造一个可以实际使用的博客。</p>
</li>
</ol>
</li>
</ol>
<p><strong>参考博客</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/550709268">利用Github DIY自己的个人博客</a></li>
<li><a href="https://www.cnblogs.com/Alight/p/4354294.html">这是一个有用的思考</a></li>
<li><a href="https://docs.github.com/zh/pages/quickstart">Github pages 官方文档</a></li>
</ul>
<p><strong>补充内容：hexo 命令的具象化解释</strong></p>
<p>执行完<code>hexo init</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902175759500.png" alt="image-20230902175759500"></p>
<p><code>hexo generate</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902180712442.png" alt="image-20230902180712442"></p>
<p><code>hexo clean</code>是把生成的东西清掉了</p>
<p><code>hexo d</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902181617668.png" alt="image-20230902181617668"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>房地产研究</title>
    <url>/2023/09/07/%E6%88%BF%E5%9C%B0%E4%BA%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>房地产行业研究</p>
<span id="more"></span>

<ol>
<li><h1 id="财政危机与飞税制改革"><a href="#财政危机与飞税制改革" class="headerlink" title="财政危机与飞税制改革"></a>财政危机与飞税制改革</h1><ul>
<li>财政包干使得中央财政吃紧，中央财政对国防，教育，医疗投入面临经费匮乏</li>
<li>分税制把税分成三类<ul>
<li>中央税</li>
<li>地方税</li>
<li>共享税</li>
</ul>
</li>
<li>广东谈判<ul>
<li>分税制可以，但要将土地出让收入归地方</li>
</ul>
</li>
<li>分税制使得中央财政中央财政年均增幅超过了10%，1993年958亿，1994年2906亿，2021年9.15万亿。对经济有了足够的调控能力，开始加速对中国经济体制的改革。</li>
</ul>
</li>
<li><h1 id="“98房改”与三驾马车"><a href="#“98房改”与三驾马车" class="headerlink" title="“98房改”与三驾马车"></a>“98房改”与三驾马车</h1><ul>
<li><p>1997东南亚经济危机蔓延，中央消费，投资，出口三驾马车。</p>
</li>
<li><p>怎么构建，谁来拉动没有办法，1997年，京九铁路剪彩，王石做《分税制对企业的影响》，讨论了房地产行业能不能作为经济支柱。</p>
</li>
<li><p>房地产模式</p>
<ul>
<li>士地财政</li>
<li>商品房预售</li>
<li>信贷体系</li>
<li>钱从购房者手中到开发商，再到地方政府。本质是将居民未来几十年的收入提前预支获得天量资金，转换成财政收入，进行基建，招商引资。将地方政府发展过程中的部分债务转移到居民层面。</li>
</ul>
</li>
<li><p>1994年8月30日到9月2日土地使用制度改革工作会议</p>
<ul>
<li>制约我国发展经济和进行现代化建设的最大制约因素是资金不足</li>
<li>土地是我国经济建设和发展的巨大财富成为共识</li>
</ul>
</li>
<li><p>分税制下地方政府对于财政收入的巨大渴望，政府把主地一级市场的所有权逐渐收回。</p>
<ul>
<li>一开始的方式是无偿划拨和土地出让，但一直无法让土地价值最大化</li>
<li>国土资源部规定经营性土地，即用来建设商业、旅游、娱乐金融、服务业、商品房的土地必须执行“招拍挂”</li>
</ul>
</li>
<li><p>土地市场从无偿划拨到土地出让，与之对应的住房制度是福利分房到商品房，1998年国务院《关于进一步深化城镇住房制度政革，加快住房建设的通知》，即著名的<strong>98房改</strong>。<strong>取消福利分房，实现居民住宅货币化、私有化</strong>，住宅商品化拉开序幕。</p>
</li>
<li><p>购房补贴</p>
<ul>
<li>房价收入比&#x3D;本地一套60平经济适用房的平均价格&#x2F;双职工家庭的年平均工资</li>
<li>中央建设部副部长俞正声拍板，房价收入比大于4倍的要建立购房补贴</li>
<li>要想步履蹒跚的中国房地产引领中国经济走出亚洲经济危机，<strong>还缺两个发动机</strong></li>
</ul>
</li>
<li><p>1999年6月16日，原国家计划发展委员会和教育部联合发出紧急通知决定1999年中国高等教育在年初扩招23万人的基础上再扩大招生33.7万，普通高等院校招生总人数达到153万</p>
<ul>
<li>大学扩招成为拉动经济的基操</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212341823.png" alt="image-20230906212341823" style="zoom:67%;" /></li>
<li>人回红利和士地红利开始集中释放，中国经济的三驾马车包经完成其二</li>
</ul>
</li>
<li><p>2001年，中国加入WTO,三家马车最后一架来了，人口红利进一步得到释放</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212720067.png" alt="image-20230906212720067" style="zoom:67%;" />

<p>评：房地产在那个特定时期发挥了它的经济拉动作用，推动我国的经济实力迅速上升，在房地产刚起步的年代，还是出现了许多在景观、产品细节、建筑风格、设计艺术上追求极致的好楼盘。没有高周转，没有夸张营销。</p>
<blockquote>
<p>美联储降息意味着什么？</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906213751190.png" alt="image-20230906213751190"></p>
</li>
</ul>
</li>
<li><h1 id="“国十条”与第一次狂奔"><a href="#“国十条”与第一次狂奔" class="headerlink" title="“国十条”与第一次狂奔"></a>“国十条”与第一次狂奔</h1><ul>
<li><p>2004-2008年，房价良性增长，政府稳房价出台一系列政策</p>
<ul>
<li><p>2003明确房地产为支柱产业</p>
</li>
<li><p>2004“831大限”，解决协议出让的历史遗留问题</p>
</li>
<li><p>2005年3月，取消房贷优惠，首套房首付比例从20%上调至30%</p>
</li>
<li><p>2005年3月，老“国八条”，稳房价提高到政治高度</p>
</li>
<li><p>2005.10，二手房需缴纳个人所得税</p>
</li>
<li><p>2006年5月，国六条，7月，《关于规范房地产市场外资准入和管理的意见》</p>
</li>
<li><p>2007年，加大炒房客“资金成本”，5次加息。二套房首付比例不低于50%</p>
</li>
<li><p>2007年，王石在万科会议“海螺行动二”中说，中国楼市的拐点即将到来，随后万科率先降价</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906215643008.png" alt="image-20230906215643008"></p>
<p>跟风的房企并不多，但紧接着金融危机到来，消费低靡。房价下调蔓延开来，但是人性都是“买涨不买跌”，越降价越没人买。中国经济有“硬着陆的风险”</p>
</li>
</ul>
</li>
<li><p>2008年11月5日，发布进一步扩大内需，促进经济平稳较快发展的<strong>“国十条</strong>”，具体的方法是：</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906220739549.png" alt="image-20230906220739549"></p>
<p>央行5次降息，连续降息2.16%，大水漫灌。</p>
</li>
<li><p>国十条需要的资金从哪里来？是地方政府通过城投公司用<strong>土地</strong>向银行借贷得来的。所以房价不能降，于是各地开始疯狂救市。</p>
</li>
<li><p>2008救市</p>
<ul>
<li><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223413007.png" alt="image-20230906223413007"></p>
</li>
<li><p>同时地方政府可以灵活指定特殊政策</p>
<ul>
<li>杭州“救市”24条，规定购买100万以士房产的客户可直接落户</li>
</ul>
</li>
<li><p>于是全国住宅均价平均上涨25.1%，全国一二线城市房价都在那两年翻了一番</p>
<ul>
<li><p>2008年郑州全年均价3960，到2010年12月已经张到了6493</p>
</li>
<li><p>陆家嘴</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223922564.png" alt="image-20230906223922564"></p>
</li>
</ul>
</li>
<li><p>大量人员开始<strong>恐慌性置业</strong>。</p>
</li>
</ul>
</li>
<li><p>土地金融</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906224301852.png" alt="image-20230906224301852"></p>
<ul>
<li>这里面关键是土地价格不能降</li>
</ul>
</li>
<li><p>刹车</p>
<ul>
<li><p>楼市火热，GDP重回两位数，2010年1月10日中快发布了国十一条”，限购</p>
</li>
<li><p>2010年4月12日：新国十条发布，调控加码</p>
<ul>
<li>首套房且90以上，贷款首付款比例不得低于30%</li>
<li>二套房，首付比例不得低于50%，贷款利率率不得低于基准利率的1.1倍，按当时，二套房利率达到了6.53%</li>
<li>非本地居民暂停贷款，就是只能全款</li>
</ul>
</li>
<li><p>2010年10月开始，四次加息，首套房利率来到7.05%</p>
<blockquote>
<p>何为资产负债率，广义货币M2是什么？</p>
<p>美元加息为什么会让资本回流美国？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>反思：国十条有效拉动了经济复苏，可惜政策没有成熟的监管体系。钱都流向了房市，推高了房价。</p>
</li>
<li><h1 id="第二次狂奔"><a href="#第二次狂奔" class="headerlink" title="第二次狂奔"></a>第二次狂奔</h1><ul>
<li><p>2014加息导致美元资金回流，同时房地产行业供远大于求，导致了房地产低迷</p>
<ul>
<li>呼和浩特等取消<strong>限购</strong>，释放需求，</li>
<li>2014年9月30，央行，银监会下发《关于进一步做好住房金融服务工作的通知》，提出<strong>房贷结清后再购房可算首套</strong>，<strong>限贷</strong>缓和</li>
<li>同时下调贷款利率</li>
<li>相当于从政策端和货币端给房地产松绑。</li>
<li>然而这次的政策松绑并没有起到预期效果<ul>
<li>房价的持续低迷打破了永远涨的预期，不敢投资房产</li>
<li>库存大多是三四线城市，一二线城市扥松绑并不能对整体库存的消化起到明显作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>既然松绑失败，那就只能直接促进需求端的上涨，<strong>棚改货币化</strong></p>
<ul>
<li><p>棚改分为实物安置和货币安置</p>
</li>
<li><p>2014年6月26日，国家开发银行成立住宅金融事业部，针对棚改工作向地方政府发放贷款。</p>
</li>
<li><p>棚改的运作逻辑</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906233801487.png" alt="image-20230906233801487" style="zoom:50%;" />
</li>
<li><p>棚改各阶段分析</p>
<ul>
<li>第一阶段：2007-2012， 大多数居民选择实物安置，因此并没对楼市产生很大影响</li>
<li>第二阶段：2013-2014，住建部选择优先就近实物安置</li>
<li>第三阶段：2015-2018，国务院37号文件，强调提高货币化安置比例，因为要“三去”，货币化安置比例从2014年的9%上升到2016年的48.5%</li>
</ul>
</li>
<li><p>二线拆迁户率先冲入楼市，2016年：合肥、厦门、南京、苏州翻倍涨幅，史称“房价四小龙”</p>
</li>
<li><p>二线楼市上涨促进了三四五线城市拿到接力棒，对楼市发起冲锋。</p>
<ul>
<li>让一直深耕三四线的恒大，碧桂园在2016年完成业绩超车</li>
<li>引起房企下沉</li>
</ul>
</li>
</ul>
</li>
<li><p>2017年<strong>930调控潮</strong>，全国一二线共19个城市发布调控，开始“<strong>五限</strong>”</p>
<ul>
<li>限购</li>
<li>限贷</li>
<li>限售：购房之日起，三年&#x2F;五年&#x2F;十年之内不许上市买卖。直接拉长炒房客资金回收周期</li>
<li>限价：在商品房房价，出地最高拍卖价格两方面设定上限，楼市，土市双限价</li>
<li>限签：房屋备案合同在网上登记备案，叫做“网签”，网签后，这套房的价格信息就会在全国联网的房地产系统中记录在案。国家就可以知道各城市的房价指数，于是各地方政府怕自己房价上涨的太快被中央知道，于是就让高价房源暂缓网签。因此2017年之后的房价指数都是不准确的</li>
<li>结婚离婚如何成为钻制度空子的方法<ul>
<li>以合肥为例<ul>
<li>限购政策为：本市户口住房者至多拥有两套住房，非本市户口购房要满一年社保才能买一套</li>
<li>问题在于本地户口的认定，婚姻持续状态的夫妻按一户只能有两套住房资格，但离了婚就算两户，有四套的购房资格。</li>
<li>合肥楼市新政：离婚不满两年仍按原家庭进行房查</li>
</ul>
</li>
<li>海南<ul>
<li>2017年4月出台：非本省户口只能购买一套，本省户口没限制</li>
<li>于是炒房客与三亚适龄单身女青年假结婚，并将户口迁海南，买够想要的房后离婚。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一二线调控使得一些区位好的三四线成了炒房客的聚集地。如“环沪四县”，昆山、嘉善、启东、太仓</p>
</li>
<li><p>问题所在：</p>
<ul>
<li>健康发展的房地产可以拉动上下游实体经济发展</li>
<li>房价暴涨造成人心理的异化：你有100万准备投资实体，但是你在的城市一年房价翻翻了，那你怎么还会投资实体经济。</li>
<li>原本带动实体经济发展的房地产反倒成了资金吸血鬼，抢走了原本应该投向实体的资金，扩大了房地产的金融化和泡沫化。</li>
<li><strong>最致命</strong>：房地产市场成了不会下跌的股市，不断推高房价，高的房价就是高的生活成本，让年轻人不得不追求高收入的金融互联网，多少人的梦想从小时候的想当科学家艺术价变成想买一套房。实体产业的发展、科技创新、文化创新都成为了楼市发展的代价。</li>
</ul>
</li>
<li><p>2018年全国各地开始收紧货币化安置，失去了货币化安置购买力的房企开始陷入困局</p>
<ul>
<li>2018年9月，万科郁亮开会强调“活下去”</li>
</ul>
</li>
</ul>
<p>总结：棚改是重要的民生工作，房地产去库存是为了防范金融风险。但这个过程中，房价的泡沫让社会思想开始异化：</p>
<ul>
<li>房企为追求利润和扩张开启高周转，高负债，房子质量也十分堪忧</li>
<li>群众被高房价倒逼为了钱累死累活，有房有车作为婚姻门槛越来越遥不可及</li>
</ul>
</li>
<li><h1 id="高周转的血与泪"><a href="#高周转的血与泪" class="headerlink" title="高周转的血与泪"></a>高周转的血与泪</h1><p>- </p>
<ul>
<li><p>现象</p>
<ul>
<li>2020年315晚会首次曝光万科水帘洞问题，房价越来越高，质量越来越差是人民的实感。</li>
<li>2021年起，高负债房企恒大，融创，碧桂园接连爆雷</li>
</ul>
</li>
<li><p>勾地</p>
<ul>
<li><p>早期无偿划拨和协议出让，2002建立土地“招拍挂”制度以后拿地成本很不确定</p>
</li>
<li><p>勾地就是类似于万达，龙湖模式，住宅+商业中心，通常会和政府暗通款曲，量身打造招标条件，同时地价也会比纯住宅低</p>
</li>
<li><p>保证金制度</p>
<ul>
<li>如果想拿地，必须先缴纳一定数额保证金才拥有了报名资格。</li>
<li>拍到了，保证金转成土地款；没拍到，原路退回。</li>
</ul>
</li>
</ul>
</li>
<li><p>工程经济学中的现金流模型</p>
<ul>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912142256305.png" alt="image-20230912142256305"></li>
<li>当土地成本、借款利率、税费建安费都无法下降的时候，将目光转向了时间——<strong>高周转</strong><ul>
<li>拿地后尽快开工，尽快开盘，尽快回款</li>
<li>两件事上放慢<ul>
<li>推迟土地款的支付时间</li>
<li>延期支付施工单位的工程款，延期到开盘之后甚至现金流回正之后，减少了前期融资的需求，降低了资金成本</li>
</ul>
</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912143558648.png" alt="0"></li>
</ul>
</li>
</ul>
</li>
<li><p>现实中高周转如何落地呢？</p>
<ul>
<li>首先是开盘时间的提速，开盘时间越早，曲线上扬越早，偿还贷款，节省资金成本。 </li>
<li>销售速度，销售速度越快，现金流上升的斜率就越陡，</li>
<li>建设速度，这是前两者的必要条件</li>
<li>释放预售监管资金进入公司自有账户</li>
<li>在项目外建立庞大的资金池，和自有资金一起进行投资</li>
</ul>
<blockquote>
<p>容积率：建筑总面积&#x2F;净用地面积</p>
<p>货地比：房产销售额&#x2F;总土地款</p>
<p>预售条件：从拿地到销售，需要满足预售条件，不同地区预售条件不一样</p>
<p>预售资金管理：</p>
</blockquote>
<ul>
<li>万科高周转<ul>
<li>2004年，36岁郁亮（北大经济系）接棒王石，提出“10年时间万科业务翻10倍，销售冲击千亿”</li>
<li>“5986”模式<ul>
<li>拿地后5个月开工，9个月开盘</li>
<li>普通住宅占开盘房源8成，开盘后当月销量达6成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高周转恶性循环</p>
<ul>
<li>规模越大的房企越容易获得额度更大，利息更低的贷款；小规模获得贷款利息更高，甚至申请不下来。</li>
<li>越大的规模意味着更便宜的融资，以为着更低的资金成本，也以为着更能发展更大规模和利润。</li>
<li>房地产沦为了资金游戏，顺便盖个房子</li>
</ul>
</li>
<li><p>美元债</p>
<ul>
<li><p>2016年19城调控前，房企通过上市、信托等渠道筹集资金</p>
</li>
<li><p>2016-2017调控潮之后，房企在国内的融资收紧，于是开始转向美元债</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912153414464.png" alt="image-20230912153414464"></p>
</li>
<li><p>美元债与信用评级挂钩，于是房企在美元债“躺平”就是房企爆雷的标志。</p>
</li>
</ul>
</li>
<li><p>净资产收益率ROE</p>
<ul>
<li><p>调控措施让房企的利润下降，使得ROE这个指标对于房企来说更重要，</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912163753937.png" alt="image-20230912163753937"></p>
</li>
<li><p>从重视净利率到重视ROE反映的是行业玩法的改变，就是将自己手上的每一分钱的赚钱能力发挥到极致。因为做个约分就发现：ROE &#x3D; 净利润&#x2F;总权益资本</p>
</li>
<li><p>导致的结果就是，<strong>加杠杆</strong>，于是奇怪现象：</p>
<ul>
<li><p>想做房企的施工单位，可以，请给一个亿的无息借款</p>
</li>
<li><p>并且我给你的工程支付会一直延后，让我的现金流尽快回正。</p>
<blockquote>
<p>我不成跪着要饭的了？要真这么说，给高周转房企当总包还真就是跪着要饭的，就这，多少人想跪还没这门子呢！</p>
</blockquote>
</li>
<li><p>向员工融资：跟投项目+理财产品</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高负债率</p>
<ul>
<li>在高周转模式下，只要现金流不断，这个模式就可以一直玩下去。</li>
<li>房企高负债逐渐成为中国经济的恶性肿瘤</li>
<li>2017年，十九大报告提出的“三大攻坚战”之首就是防范化解重大风险</li>
<li>2018年开始中央出台一系列政策加大房企融资限制，准备对房企釜底抽薪。</li>
<li>2019年底，2020年初新冠黑天鹅，使得不得不量化宽松扶持微小企业发展，这些钱却被用来炒房，引发<strong>第三次狂奔</strong></li>
</ul>
</li>
</ul>
</li>
<li><h1 id="第三次狂奔与三道红线"><a href="#第三次狂奔与三道红线" class="headerlink" title="第三次狂奔与三道红线"></a>第三次狂奔与三道红线</h1><ul>
<li><p>经营贷炒房</p>
</li>
<li><p>三道红线</p>
<ul>
<li><strong>剔除预收账款的资金负债率</strong>不得大于70%</li>
<li><strong>净负债率</strong>不得大于100%</li>
<li><strong>现金短债比</strong>不得小于1倍</li>
</ul>
</li>
<li><p>剔除预收账款的资产负债率</p>
<ul>
<li>预收款&#x3D;首付+房贷回款</li>
<li>交房前预收款被算作负债，交房后倍算作收入</li>
<li>剔除预收账款的资产负债率&#x3D;（总负债-预收款）&#x2F;（总资产-预收款）</li>
</ul>
</li>
<li><p>净负债</p>
<ul>
<li>净负债 &#x3D; （有息负债-货币资金）&#x2F; 合并权益</li>
</ul>
</li>
<li><p>现金短债</p>
<ul>
<li>现金短债比 &#x3D; 货币资金 &#x2F; 短期有息负债</li>
</ul>
</li>
<li><p><strong>三道红线</strong>和<strong>限跌令</strong>下的房企</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912203923915.png" alt="image-20230912203923915"></p>
</li>
</ul>
</li>
<li><h1 id="备用"><a href="#备用" class="headerlink" title="备用"></a>备用</h1><ul>
<li></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>房地产</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2024/09/01/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>acwing 贪心算法</p>
<span id="more"></span>

<ul>
<li><p>区间问题基础语法问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何存储区间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;<span class="type">int</span> l,r; <span class="type">bool</span> <span class="keyword">operator</span>&lt;()&#123;&#125;&#125;range[N]	<span class="comment">// 结构体数组</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;   vector&lt;PII&gt; <span class="comment">// vector 存 PII</span></span><br><span class="line"><span class="comment">// 如何排序</span></span><br><span class="line"><span class="keyword">operator</span>&lt;	<span class="comment">// 操作符重载</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">()</span>	<span class="comment">// 定义比较器</span></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(a.begin(), a.begin() + n, [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;)</span></span>; <span class="comment">// lambda 函数</span></span><br><span class="line"><span class="comment">// 如何输入一个区间</span></span><br><span class="line">range[i] = &#123;l,r&#125;; </span><br><span class="line">cin &gt;&gt; range[i].l &gt;&gt; range[i].r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">vc.<span class="built_in">push_back</span>(&#123;l,r&#125;);	<span class="comment">// pair 也算聚合体 可以用花括号作临时 pair 对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort 函数默认对 vector<PII> 进行双关键字排序</p>
</blockquote>
</li>
<li><p>区间选点: 选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> r &lt; W.r; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; range[i].l)</span><br><span class="line">        &#123; res ++ ;ed = range[i].r; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按右端点排序</li>
<li>依次遍历区间，<ol>
<li>和当前 end 有交集，则跳过</li>
<li>无交集，更新 end</li>
</ol>
</li>
</ol>
<p>为什么按右端点排序？</p>
<p>因为要尽可能少的点，点从左往右选，希望步子尽可能大，但是前提是点穿过所有区间，所以步子限制在无交集区间中最靠左的右端点</p>
<p>为何和最大无交集区间数是一个问题？</p>
<p>最大不相交区间和最多会议安排，都是找尽早结束时间点的区间纳入选择集中，这和区间选点策略是一样的。</p>
</blockquote>
</li>
<li><p>区间分组: 将区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> l &lt; W.l; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= range[i].l)</span><br><span class="line">            heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">        <span class="keyword">else</span> &#123; heap.<span class="built_in">pop</span>(); heap.<span class="built_in">push</span>(range[i].r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按左端点排序</li>
<li>遍历区间<ol>
<li>当前区间可以放在某组，放入并更新结束时间</li>
<li>无法放入，开新组</li>
</ol>
</li>
</ol>
<p>为什么这里又变成了左端点排序？</p>
<ol>
<li>其实是按开始时间依次放入，倘若变成按结束时间依次放入</li>
</ol>
<p>另一种新奇的思路：<a href="https://www.acwing.com/solution/content/8902/">https://www.acwing.com/solution/content/8902/</a></p>
</blockquote>
</li>
<li><p>区间覆盖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st,ed;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i]=&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range,range+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123; r = <span class="built_in">max</span>(r, range[j].r); j ++; &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; st)&#123; cout &lt;&lt; <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)&#123; cout &lt;&lt; res; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        st = r; i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>区间按左端点排序</li>
<li>遍历区间<ol>
<li>从可以覆盖 st 的区间中找一个右端点最靠右的，最大化覆盖 st ed 区间</li>
<li>更新 st 为这个区间最靠右的值。回到 2-1 循环</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>区间问题总结：</p>
<ul>
<li><p>区间尽管可以将其看做元素，根据需要按左端点或右端点进行排序</p>
</li>
<li><p>哈夫曼树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n ==  <span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123; <span class="type">int</span> t; cin &gt;&gt; t; q.<span class="built_in">push</span>(t); &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s1 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> s2 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        res += s1 + s2;</span><br><span class="line">        q.<span class="built_in">push</span>(s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排队打水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="built_in">sort</span>(m,m + n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> wait = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123; res += wait; wait += m[i]; &#125;</span><br><span class="line"><span class="comment">// 方法2 太优美了！</span></span><br><span class="line"><span class="built_in">sort</span>(t, t + n);</span><br><span class="line"><span class="built_in">reverse</span>(t, t + n);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += t[i] * i;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL调试准备</title>
    <url>/2023/09/06/AFL%E8%B0%83%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>调试 AFL </p>
<span id="more"></span>

<ul>
<li><p>在vscode+mingw64的条件下试图调试AFL,发现缺少头文件</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906163736865.png" alt="image-20230906163736865"></p>
<p>考虑安装VS再尝试</p>
</li>
<li><p>安装vs之后仍然报头文件缺失，然后全局搜索 shm.h 文件，发现本机并没有这个文件。此时恍然大悟，AFL 可能本来就不能再win上运行，<a href="https://www.51cto.com/article/753518.html">查证</a>后果然，为此还有人开发了 win 上的 AFL 工具<a href="https://github.com/ivanfratric/winafl">WinAFL</a>。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906171407166.png" alt="image-20230906171407166"></p>
</li>
<li><p>那么现在的方案有两个</p>
<ul>
<li>在 mac 上调试</li>
<li>在 linux 上直接 gdb 调试。或者 gdb + vscode 可视化调试</li>
</ul>
</li>
</ul>
<p>首先尝试第二种方案：</p>
<ul>
<li><p>读懂 Makefile 文件，给出 -g 编译选项，方便调试。</p>
</li>
<li><p>研究之后发现本来的 Makefile 中编译选项已经包含了 -g 所以都可以直接调试。</p>
</li>
<li><p>下一步思考怎么搭建一个双机调试环境？</p>
</li>
<li><p>退一步学习一下怎么样使用gdb调试。</p>
</li>
<li><p>先进行一个小的实验：<a href="https://xz.aliyun.com/t/4314">初探AFL-Fuzz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插桩编译</span></span><br><span class="line">afl-gcc -g -o test test.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模糊测试</span></span><br><span class="line">afl-fuzz -i input_dir -o output_dir program</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始使用GDB调试AFL</p>
<ul>
<li><a href="https://www.cnblogs.com/suphgcm/p/15498577.html">GDB cheetsheet</a></li>
<li><a href="https://wenku.baidu.com/view/30c4cfbfcf22bcd126fff705cc17552707225e0f.html?_wkts_=1694057567582&bdQuery=gdb+cheetsheet">cheet sheet</a></li>
<li><a href="https://blog.csdn.net/wxh0000mm/article/details/108582238">gdb速查表</a></li>
<li><a href="https://github.com/yimaginer/awesome-cheatsheets/blob/master/tools/gdb.txt">awesome-cheetsheet</a></li>
</ul>
</li>
</ul>
<p>记录调试过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动调试</span></span><br><span class="line">gdb --args afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GDB 前端</span></span><br><span class="line">ctrl-x ctrl-a 更换 CLI/TUI</span><br></pre></td></tr></table></figure>

<p>遇到的问题：<br><a href="http://www.taodudu.cc/news/show-5082273.html?action=onClick">GDB调试显示＜ optimized_out ＞</a></p>
]]></content>
      <tags>
        <tag>Fuzz</tag>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker环境</title>
    <url>/2023/09/07/docker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>docker环境</p>
<span id="more"></span>

<ol>
<li>在linux环境安装docker：<a href="https://docs.docker.com/desktop/install/linux-install/">https://docs.docker.com/desktop/install/linux-install/</a></li>
<li>docker权限问题：<a href="https://blog.csdn.net/AS_TS/article/details/131184815">https://blog.csdn.net/AS_TS/article/details/131184815</a></li>
</ol>
<h2 id="exercise1"><a href="#exercise1" class="headerlink" title="exercise1"></a>exercise1</h2><p>在docker环境中作一份代码的fuzzing</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本机下载问题代码</span></span><br><span class="line">git clone https://github.com/alex-maleno/Fuzzing-Module.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 AFL++ 的 docker 容器</span></span><br><span class="line">docker run --rm -it -v /home/tiger/fuzz/Fuzzing-Module://home/Fuzzing-Module 6612ffca640e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 编译示例代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成seeds</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始fuzzing</span></span><br><span class="line">/AFLplusplus/afl-fuzz -i /home/Fuzzing-Module/exercise1/seeds -o out -m none -d -- /home/Fuzzing-Module/exercise1/build/simple_crash</span><br><span class="line"></span><br><span class="line">docker run --rm -it -v &quot;/home/tiger&quot;:&quot;/home/tiger&quot; 6612ffca640e</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招笔试真题记录</title>
    <url>/2024/09/05/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录秋招过程中的笔试算法题目</p>
<span id="more"></span>

<ul>
<li>0905 小米</li>
</ul>
<ol>
<li><p>做面包</p>
<p>小明每天早上需要AB两种面包各一个，同时已知小明有 n 个面包机，n 个面包机做 A B 两种面包的时间分别是 a<del>i</del> ，b<del>i</del> 。可以选择用同一台面包机先后制作 A 和 B，这样时间是累加的，也可以选择用不同的面包机并行制作 A B, 这样时间取两块面包制作时间的大者。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表拥有面包机的数量。接下来有两行，每行 n 个数，第一行 n 个数代表 n 台面包机制作 A 面包的时间，第二行 n 个数代表 n 台面包机制作 B 面包的时间。</p>
<p><strong>输出格式：</strong></p>
<p>输出一个数，代表最短制作用时</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">2 6 8</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
<li><p>序列操作</p>
<p>给出一个数字序列，你可以有两种操作，一种是把某个元素加 1，第二种是直接删除某元素，最终期望达到的效果是所有元素之和是 x 的倍数</p>
<p><strong>输入格式：</strong></p>
<p>首行两个数字 n , x。n 代表数组长度， x 为上文描述的意义。</p>
<p><strong>输出格式：</strong></p>
<p>输出最少操作次数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 5 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目前 还没有太成熟的解法，想法是直接根据数据总和，以及数据元素，推算用两种方式各自需要多少次</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x; cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;<span class="type">int</span> t; cin &gt;&gt; t; a.<span class="built_in">push_back</span>(t), sum += t;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum % x  == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (sum + <span class="number">1</span>) % x == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), sum % x);</span><br><span class="line">        <span class="keyword">if</span>(pos != a.<span class="built_in">end</span>() &amp;&amp; *pos == sum % x) </span><br><span class="line">            &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pos &gt; sum % x &amp;&amp; pos != a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s1 = </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个题目有点像动态规划，但是似乎常规方法也可以，暂时没有很好的解法</li>
</ul>
</li>
<li><p>总结：</p>
<ol>
<li>其实题目算是很基础了，但一是心态，而是技术，两方面都需要加强<ol>
<li>心态应该更淡定一些</li>
<li>技术就是要多练</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​	</p>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>STL详细梳理</title>
    <url>/2024/09/05/STL%E8%AF%A6%E7%BB%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="STL-container"><a href="#STL-container" class="headerlink" title="STL-container"></a>STL-container</h1><span id="more"></span>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,5&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>,5&gt; <span class="title">c</span><span class="params">(c2)</span></span>;		<span class="comment">// 必须类型大小都一样</span></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = c2;</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = initlist</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="built_in">c</span>(rv);</span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = rv;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Int 可以扩充为：</p>
<ol>
<li>float bool ull struct class string 等基础类型</li>
<li>vector array deque list forward_list set map 等容器</li>
</ol>
</blockquote>
<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();</span><br><span class="line">c1 == c2		<span class="comment">// 只有类型大小相同才有比较的资格,数据全相同才为 true</span></span><br><span class="line">c1 != c2</span><br><span class="line">c1 &lt; c2			<span class="comment">// 字典序比较</span></span><br></pre></td></tr></table></figure>

<p>  赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">fill</span>(val)</span><br><span class="line">c1.<span class="built_in">swap</span>(c2)	<span class="comment">// 置换c1和c2</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2)	<span class="comment">// 类型大小相同才可以swap</span></span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);</span><br><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.back;</span><br></pre></td></tr></table></figure>

<p>八大迭代器：</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; c </span>= c2;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;			<span class="comment">// 开一个 size 为 n 的 vector，使用默认构造填充每个元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,val)</span></span>;	<span class="comment">// 以 n 个 val 填充 c</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2.beg,c2.end)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">capacity</span>();</span><br><span class="line">c.<span class="built_in">reserve</span>(num);		<span class="comment">// 针对 c 的 capacity 属性</span></span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>()	<span class="comment">// 针对 c 的 capacity 属性,执行后不一定 c.size() == c.capacity()</span></span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();	<span class="comment">// 数组起始位置</span></span><br><span class="line">== != &lt; &gt; &lt;= &gt;= 	<span class="comment">// 六种比较全支持，先比 size，再按字符串比较方法比元素</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有赋值都是将新元素赋值给 vector 并将旧元素删除</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);	<span class="comment">// 二者管理的内容（data,size,cap）交换，相当于二者交换名字，也相当于相互借壳上市</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);	<span class="comment">// 四个中只有 at 具有安全性检查，其余访问前要手动保证位置可访问</span></span><br><span class="line">c.<span class="built_in">front</span>();	</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">beg，end，cbeg，cend，rbeg，rend，crbeg，crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();	<span class="comment">// 程序员手动保证容器不空</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);	<span class="comment">// pos 之前插入 elem， 并返回新元素位置</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos, initlist);</span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...)	<span class="comment">// 在 pos 之前插入以 arg 为初值的元素,返回第一个新元素位置</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...)	<span class="comment">// 末尾插入以 arg 为初值的元素，无返回值</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);	<span class="comment">// 删除 [beg end) 区间内元素</span></span><br><span class="line">c.<span class="built_in">clear</span>();	<span class="comment">// 清空</span></span><br><span class="line">c.<span class="built_in">resize</span>(num);	<span class="comment">// 如果 size 变大，多出来的元素用默认构造填充</span></span><br><span class="line">c.<span class="built_in">resize</span>(num,elem);	<span class="comment">// 如果 size 变大，多出来的用 elem 拷贝填充</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove</span>(beg,end,val)	<span class="comment">// 	实质是把非 val 元素前移，size 并未改变</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有了 insert， vector 不局限于在尾部增加元素，可以在任意位置添加任意个数的元素，但是可以是一回事，并不擅长，因为复杂度原因。</li>
<li>insert emplace 的所有 pos，都需要是迭代器，而不能是 int 值（这很好理解，迭代器要么是pointer，要么是类，无论哪种都不是一个 int 可以替代的）</li>
<li>pos 的值可以由算法计算出，结合 insert 可以实现很多功能：<ol>
<li>vector 没有提供删除指定值功能，但是可以搭配算法实现这个功能：c.erase(remove(c.begin(),c.end(),val),c.end());</li>
<li>在 val1 前插入val2 c.insert(find(c.begin(),c.end(),val1),val2)</li>
</ol>
</li>
<li>删除第一个值为 val 的元素：auto pos &#x3D; find(c.begin(),c.end(),val); if(pos !&#x3D; c.end()) v.erase(pos);</li>
</ol>
</blockquote>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><blockquote>
<p>几乎和 vector 一模一样，除了</p>
<ol>
<li>不支持容量操作，reserve(), capcity()</li>
<li>安插和移除可以在头部进行</li>
</ol>
</blockquote>
<p>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dequeue&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(deg,end)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有接口都是整体赋值，所以大多数情况适用于算法开始前初始化</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem); </span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);	<span class="comment">// 交换内容</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.at(idx);</span><br><span class="line">c.front();</span><br><span class="line">c.back();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beg,end,cbeg,cend,rbeg,rend,crbeg,crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">c.<span class="built_in">resize</span>(n,num);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 原地构建一个 string 类</span></span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &lt; &gt; &lt;= &gt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b,e,cb,ce,rb,re,crb,cre</span><br><span class="line"><span class="comment">// 经过实验，list 的迭代器支持了 ++ -- 操作，但是不支持直接 + - 操作(包括加减 int， 以及迭代器之间加减)，意味着 list 的诸如 c.insert(pos,elem); 中 pos 的定位只能从 front 或者 end 航行过去，想来也是合理</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>();</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>();</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的 remove 总是好于算法中提供的 remove</span></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op); <span class="comment">// c.remove([](int i)&#123; return i % 2 == 0;&#125;); 删除偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulate(beg,end,0);</span></span><br><span class="line"><span class="comment">// transform(a.beg,a.end,b.beg,negate&lt;int&gt;());</span></span><br></pre></td></tr></table></figure>

<p>List 特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();		<span class="comment">// 相邻而数值相同留一个,所以要想实现真正的单一化，要先排序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2);	<span class="comment">// 整个 c2 放在 pos 之前</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2pos)	<span class="comment">// c2 的 c2pos 位置元素放在 c 的 pos 位置，c和c2可以相同</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2beg,c2end)	<span class="comment">// c2 的 [c2beg,c2end) 区间元素放在 pos 位置，c和c2可以相同</span></span><br><span class="line"> </span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前题是 c 和 c2 均有序</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>

<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br><span class="line">  <span class="comment">// 没有 size，可行的方案是 distance(c.begin(),c.end())</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">assign</span>(n.elem);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c = initlist;</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">四个正向迭代器：b,e,cb,ce</span><br><span class="line">额外两个： <span class="built_in">before_begin</span>(),<span class="built_in">before_end</span>(); <span class="comment">// 不要试图解引用这两个迭代器，仅限于后缀为 after 的借口使用</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace_after</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase_after</span>(pos);</span><br><span class="line">c.<span class="built_in">erase_after</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br></pre></td></tr></table></figure>

<p>list特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();	<span class="comment">// 前提是有序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2pos);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2beg,c2end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前提是有序，c2 归入 c</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op);</span><br><span class="line">c.<span class="built_in">reverse</span>();</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;	<span class="comment">// set&lt;int,greater&lt;int&gt;&gt; coll;</span></span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = rv;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;	<span class="comment">// 可接受不同类型容器元素</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = initlist;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">不支持随机，通常使用 range-base <span class="keyword">for</span> 或 迭代器</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器(关联式容器都是)</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>();</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>set 特殊查找函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val);</span><br><span class="line">c.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">lower_bound</span>(val);</span><br><span class="line">c.<span class="built_in">upper_bound</span>(val);</span><br><span class="line">c.<span class="built_in">equal_bound</span>(val);</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = initlist;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = <span class="built_in">c</span>(c2);</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key];</span><br><span class="line">c.<span class="built_in">at</span>(key);</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(key);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 	由于元素是 key/val pair 因此元素插入略显复杂</span></span><br><span class="line">	c.<span class="built_in">insert</span>(&#123;<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	c.<span class="built_in">insert</span>(map&lt;string,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>))</span><br><span class="line">  c.<span class="built_in">insert</span>(<span class="keyword">decltype</span>(c)::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each(beg,end,op)</span></span><br><span class="line"><span class="comment">// find_if(beg,end,op)</span></span><br></pre></td></tr></table></figure>

<p>map特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(key)</span><br><span class="line">c.<span class="built_in">find</span>(key)</span><br><span class="line">c.<span class="built_in">lower_bound</span>(key)</span><br><span class="line">c.<span class="built_in">upper_bound</span>(key)</span><br><span class="line">c.<span class="built_in">equal_bound</span>(key)</span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Unord c;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">Unord c = initlist;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">Unord c = rv;</span><br></pre></td></tr></table></figure>

<p>布局操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">hash_function</span>();</span><br><span class="line">c.<span class="built_in">key_eq</span>();</span><br><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>(val);</span><br><span class="line">c.<span class="built_in">rehash</span>(bnum);</span><br><span class="line">c.<span class="built_in">reserve</span>(bnum);</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">c1 == c2;</span><br><span class="line">c1 != c2;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c1.<span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key]</span><br><span class="line">c.<span class="built_in">at</span>(key)</span><br></pre></td></tr></table></figure>

<p>迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器，但是只支持 forward interator，不支持 bidirection interator 或 random-access interator</span><br></pre></td></tr></table></figure>

<p>安插和移除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);		<span class="comment">// 移除所有 与val相等 的元素，返回移除个数</span></span><br><span class="line">c.<span class="built_in">erase</span>(pos);		<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">erase</span>(beg,end)<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>无序容器特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val)</span><br><span class="line">c.<span class="built_in">find</span>(val)	<span class="comment">// 若想指定 pred 只能用 find_if()</span></span><br><span class="line">c.<span class="built_in">equal_bound</span>(val)</span><br></pre></td></tr></table></figure>

<p>bucket 接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">bucket</span>();</span><br><span class="line">c.<span class="built_in">bucket_size</span>();</span><br><span class="line">c.<span class="built_in">begin</span>(buckidx);</span><br><span class="line">c.<span class="built_in">end</span>(buckidx);</span><br><span class="line">c.<span class="built_in">cbegin</span>(bucketidx);</span><br><span class="line">c.<span class="built_in">cend</span>(bucketidx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform()</span></span><br></pre></td></tr></table></figure>

<p>STL延伸</p>
<ul>
<li>以上介绍皆为标准容器，可以利用容器思想扩充类，一般有以下扩充方向<ul>
<li>Intrusive, 侵入式。直接提供STL所需接口，如begin，end。典型的如 string 类</li>
<li>nonintrusive，非侵入式。提供特殊迭代器，作为算法和容器接口。如 array 中，begin(val) 获得其迭代器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL源码阅读</title>
    <url>/2024/07/06/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>AFL 源码阅读记录</p>
<span id="more"></span>

<ul>
<li><p>main 函数</p>
<ul>
<li><p>函数功能：解析命令参数，</p>
</li>
<li><p>具体过程：</p>
<ul>
<li>命令解析</li>
<li>分别调用 setup_signal_handlers(); check_asan_opts(); 设置信号处理函数，设置 asan；如果是并行 fuzzing ，调用 fix_up_sync() 设置同步</li>
<li>根据环境变量设置运行全局变量，检测可能存在的模式冲突</li>
<li>调用 save_cmdline 保存命令行；调用 fix_up_banner 设置运行时窗口；调用 check_if_tty 测试终端；调用 get_core_count 获取 CPU 核心数，如果开启了 CPU 亲和性，调用 bind_to_free_cpu() 找到空闲核心；调用 check_crash_handling() 查看core pattern 是否设置为 core；调用 setup_post() 设置收尾处理函数；调用 setup_shm() 设置最关键的路径记录向量；调用 init_count_class16() 构建 count_class_lookup16[65536] 阶梯数组；调用 setup_dirs_fds() 设置好输出文件夹；调用 read_testcases() 把输入文件夹的测试用例加入测试 queue；调用 load_auto() 读取输出文件夹中自动生成的字典；<strong>啥时候生成的</strong>？调用 pivot_inputs() 在输出目录中为输入测试用例建立硬链接；<strong>目的是什么？</strong>如果使用 -x 参数设置了 extras_dir，就调用 load_extras 加载字典；如果没有设置 timeout_given，调用 find_timeout() 尝试从先前的运行中读取 exec_tmout（如果设置了 resuming_fuzz）； 调用 detect_file_args(argv + optind + 1) 对参数中的 @@ 进行替换；如果没有设置 out_file，调用 setup_stdio_file() 删除可能的遗留并新建 out_dir&#x2F;.cur_input；<strong>将来谁往里面写</strong>？调 check_binary(argv[optind]) 进行二进制文件检测。</li>
<li>记录当前时间戳，写入 start_time</li>
<li>如果是 qemu 模式，调用 get_qemu_argv(argv[0], argv + optind, argc - optind) 重新设置参数</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li><p>setup_shm 设置的几个关键变量</p>
<ul>
<li>virgin_bits	没有触碰到的路径，在 in_bitmap 为空，也即没有外来引入 bitmap 情况下，初始化为 0xFF</li>
<li>virgin_tmout  没有超时的路径，初始化为 0xFF，<strong>逻辑不通</strong></li>
<li>virgin_crash   没有 crash 的路径，初始化为0xFF</li>
<li>trace_bits       申请匿名共享内存，并加载到 fuzzer 进程空间，用 trace_bits 指向这个地址，将共享内存 id 放到环境变量 __AFL_SHM_ID 中。<strong>为什么要以字符串形式放进去？</strong></li>
</ul>
</li>
<li><p>timeout_given </p>
<ul>
<li>-t 选项参数中 exec_tmout 有 + 后缀，timeout_given &#x3D; 2，否则为 1</li>
<li>没设置 -t，则 timeout_given 为 0</li>
<li>in_place_resume 模式下，超时时间来自于上次运行 out_dir&#x2F;fuzzer_stats 文件中的 exec_timeout 字段，则设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>resuming_fuzz</p>
<ul>
<li>一旦从 queue 读到名称为 id:%06u,orig:%s 测试用例的测试用例，将 resuming_fuzz 设为 1，其余情况皆为 0</li>
</ul>
</li>
<li><p>in_place_resume</p>
<ul>
<li>如果 -i 的参数是 -，则将 in_place_resume 设置为 1。<strong>除了 in_place_resume 还有什么恢复形式</strong>？</li>
</ul>
</li>
<li><p>static u32 find_start_position(void)</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，找到继续 fuzz 的起始点</li>
<li>具体过程：<ul>
<li>找到 out_dir&#x2F;fuzzer_stats，读出其中的 cur_path</li>
<li>如果 cur_path 大于 queued_paths，则返回 0，否则返回 cur_path。</li>
</ul>
</li>
</ul>
</li>
<li><p>static void find_timeout(void) 函数</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，设置 exec_tmout 和   timeout_given</li>
<li>具体过程：</li>
<li>如果是 in_place_resume，读取 out_dir&#x2F;fuzzer_stats 文件，否则读取 in_dir&#x2F;..&#x2F;fuzzer_stats 文件</li>
<li>读取其中的 exec_timeout，都不到，或读到了值小于 4，直接返回没有任何改动</li>
<li>如果读到了并且不小于 4 ，则把 exec_timeout 设置到 exec_tmout，并设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>EXP_ST void detect_file_args(char** argv) 函数</p>
<ul>
<li>函数作用：把参数中 @@ 替换</li>
<li>具体过程：<ul>
<li>逐个遍历 afl-fuzz 的参数，遇到含有 @@ 则停下来处理</li>
<li>如果通过 -f 指定了 out_file，并且 out_file 是自根目录 &#x2F; 开始，则将 @@ 替换为 out_file，如果不是自根目录开始，则将 @@ 替换为 cwd&#x2F;out_file</li>
<li>如果压根没指定 out_file，把 @@ 替换为 out_dir&#x2F;.cur_input</li>
<li>形如 xxx@@xxx, 也对@@进行相同的替换。</li>
</ul>
</li>
</ul>
</li>
<li><p>EXP_ST void setup_stdio_file(void) 函数</p>
<ul>
<li>函数作用：删除可能的遗留并新建 out_dir&#x2F;.cur_input</li>
</ul>
</li>
<li><p>EXP_ST void check_binary(u8* fname) 函数</p>
<ul>
<li>函数作用：确保测试目标存在且是正常的二进制可执行文件，测试是否插桩匹配当前运行模式，</li>
<li>函数过程：<ul>
<li>如果 fname 含有 &#x2F; ，或者 fname 不含 &#x2F;  但 PATH 环境变量是空的，直接拿着 fname 做检测，假如不是常规文件，或者不具备执行权限，或者 size 小于 4，视为不合格 target_path，<strong>报错退出</strong>。</li>
<li>fname 不含 &#x2F;，且 PATH 环境变量不空，就遍历 path 中的路径，并在每个路径下搜索 fname 文件，满足：是常规文件，具备执行权限， size 大于 4，视为合格 target_path，结束遍历。如果遍历所有路径，没找到满足这三个条件的 fname，视为没有合格 target_path，将 target_path 置 0，<strong>报错退出</strong>。</li>
<li>找到合格 target_path 时候，检查 AFL_SKIP_BIN_CHECK 是否被设置，设置则返回，否则观察如果二进制文件在 &#x2F;tmp&#x2F; 或 &#x2F;var&#x2F;tmp&#x2F; 文件夹中，<strong>报错退出</strong>。</li>
<li>将二进制文件直接用 mmap 映射到进程地址空间<ul>
<li>检测到是 shell 脚本，则<strong>报错退出</strong>。</li>
<li>检测到不是 ELF 文件，则<strong>报错退出</strong>。</li>
<li>在非 qemu_mode 且非 dumb_mode 下检测是否插桩，memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1)) 检测方式是在二进制文件中搜索共享内存 id，检测到代表已经完成插桩。</li>
<li>qemu_mode 下，如果也进行了插桩，则<strong>报错退出</strong>。</li>
<li>在二进制文件中搜索到 libasan.so 或 __msan_init，则设置 uses_asan &#x3D; 1</li>
<li>如果在二进制中搜索到 ##SIG_AFL_PERSISTENT## ，则把环境变量 __AFL_PERSISTENT 设为 1，把 persistent_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_PERSISTENT 却被设置了，矛盾，输出报警信息。</li>
<li>如果在二进制中搜索到 ##SIG_AFL_DEFER_FORKSRV## ，则把环境变量 __AFL_DEFER_FORKSRV 设为 1，把 deferred_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_DEFER_FORKSRV 却被设置了，矛盾，输出报警信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static char** get_qemu_argv(u8* own_loc, char** argv, int argc)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>申请大小为 argc + 4 的 char 指针数组 new_argv</li>
<li>把 argv[1] 开始的 argc 项拷贝到 new_argv[3] 开始的位置</li>
<li>填充 argv[1-2], new_argv[2] &#x3D; target_path, new_argv[1] &#x3D; “–”</li>
<li>填充 argv[0]，<ul>
<li>先考虑 AFL_PATH&#x2F;afl-qemu-trace 文件，存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>再看 own_loc&#x2F;afl-qemu-trace （own_loc 如果含有 &#x2F; 的话），存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>前两个路径都没找到，看 BIN_PATH “&#x2F;afl-qemu-trace”，其中 BIN_PATH 在根 makefile 中定义，存在则操作同上</li>
<li>前面都寻找失败，则报错退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static void perform_dry_run(char** argv)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>cal_failures 初始化为 0，用于，获取环境变量 AFL_SKIP_CRASHES 写进 skip_crashes</li>
<li>遍历测试用例队列 queue，做如下事情<ul>
<li>将测试用例内容读入新开辟内存 use_mem 上，<strong>为什么多此一举</strong>？执行 res &#x3D; calibrate_case(argv, q, use_mem, 0, 1)</li>
<li>此时若 stop_soon 不为 0，<strong>函数返回</strong></li>
<li>如果 res &#x3D;&#x3D; crash_mode 或者 res &#x3D;&#x3D; FAULT_NOBITS，打印一下当前元素的 q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us 三个信息</li>
<li>然后根据 res 的值分类处理<ul>
<li>FAULT_NONE：如果当前处理的是队列首元素，也即 q &#x3D;&#x3D; queue，调 check_map_coverage()；如果 crash_mode 被设置，<strong>报错退出</strong>。</li>
<li>FAULT_TMOUT：依据 timeout_given 是否为 0 分别处理<ul>
<li>timeout_given 为 0，报错退出。</li>
<li>timeout_given 不为 0，且为 2 或 3（2代表 -t 参数有 + 号，3代表 in_place_resume 且上次执行设置了 exec_tmout），报警并 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++;</li>
</ul>
</li>
<li>FAULT_CRASH：</li>
<li>如果 crash_mode 被设置，跳过不处理，结束 switch</li>
<li>如果 skip_crashes 被设置，执行 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++，结束 switch</li>
<li>如果前面两个都没设置，而 mem_limit 被设置，打印出可能出错的原因</li>
<li>FAULT_ERROR：代表文件不能执行，结束 switch</li>
<li>FAULT_NOINST：文件没有被插桩，结束 switch</li>
<li>FAULT_NOBITS：useless_at_start++，如果 in_bitmap 和 shuffle_queue 都为 0，报警，结束 switch</li>
</ul>
</li>
<li>如果 q-&gt;var_behavior 被设置，报警 Instrumentation output varies across runs，<strong>什么意思</strong></li>
</ul>
</li>
<li>遍历完成之后，如果 cal_failures 不为 0，根据 cal_failures 和 queued_paths 的相对数据处理<ul>
<li>cal_failures &#x3D;&#x3D; queued_paths，所有测试用例都失败，报错退出</li>
<li>al_failures * 5 &gt; queued_paths，超过 20% 测试用例失败，报警。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) 函数</p>
<ul>
<li>函数作用：</li>
<li><h2 id="具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration"><a href="#具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration" class="headerlink" title="具体过程：- 局部变量  - static u8 first_trace[MAP_SIZE]  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)  - use_tmout &#x3D; exec_tmout  - old_sn &#x3D; stage_name- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace- 开始计时，写入 start_us- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 abort_calibration    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 abort_calibration    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等      - 相等，没有操作，往下流      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb      - 看 q-&gt;exec_cksum 是否有值        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子- abort_calibration"></a>具体过程：<br>- 局部变量<br>  - static u8 first_trace[MAP_SIZE]<br>  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)<br>  - use_tmout &#x3D; exec_tmout<br>  - old_sn &#x3D; stage_name<br>- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大<br>- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;<br>- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever<br>- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace<br>- 开始计时，写入 start_us<br>- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：<br>  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘<br>  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。<br>  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，<br>    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等<br>      - 相等，没有操作，往下流<br>      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb<br>      - 看 q-&gt;exec_cksum 是否有值<br>        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮<br>        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮<br>- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max<br>- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;<br>- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子<br>- <strong>abort_calibration</strong></h2></li>
</ul>
</li>
<li><p>static void write_to_testcase(void* mem, u32 len) 函数</p>
<ul>
<li>函数作用：把 mem 开始的 len 字节作为测试用例写默认的或特指的文件中去。</li>
<li>具体过程：<ul>
<li>如果 out_file 指定了，删除原文件，把 mem 开始的 len 字节作为测试用例写进去。如果 out_file 没指定，则写到 out_fd 里</li>
<li>如果是通过 out_fd 写，则需要截断文件，并移动文件光标。</li>
</ul>
</li>
</ul>
</li>
<li><p>has_new_bits 函数</p>
<ul>
<li>返回 2，发现新 tuples</li>
<li>返回 1，没发现新 tuples，但是命中数量增加</li>
<li>返回 0，没有任何发现</li>
</ul>
</li>
<li><p>persistent_mode</p>
<ul>
<li>“Persistent Mode”（持久模式）允许模糊测试工具在目标程序中更高效地探索执行路径。</li>
<li>可以通过以下方式启用持久模式：<ul>
<li>使用 <code>__AFL_LOOP()</code> 宏来指示循环的开始和结束。</li>
<li>使用 <code>__AFL_INIT()</code> 宏来执行一次性的初始化。</li>
<li>使用 <code>__AFL_FUZZ_TESTCASE_BUF</code> 和 <code>__AFL_FUZZ_TESTCASE_LEN</code> 宏来访问当前的测试用例数据和长度。</li>
</ul>
</li>
</ul>
</li>
<li><p>deferred_mode</p>
</li>
<li><p>afl-qemu-trace</p>
<ul>
<li><a href="https://blog.csdn.net/song_lee/article/details/105082092">https://blog.csdn.net/song_lee/article/details/105082092</a></li>
<li><a href="https://blog.csdn.net/qysh123/article/details/114792891">https://blog.csdn.net/qysh123/article/details/114792891</a></li>
<li><a href="https://airbus-seclab.github.io/AFLplusplus-blogpost/">https://airbus-seclab.github.io/AFLplusplus-blogpost/</a></li>
<li><a href="https://aflplus.plus/docs/env_variables/">https://aflplus.plus/docs/env_variables/</a></li>
<li><a href="https://afl-1.readthedocs.io/en/latest/user_guide.html">https://afl-1.readthedocs.io/en/latest/user_guide.html</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://github.com/nccgroup/TriforceAFL">https://github.com/nccgroup/TriforceAFL</a></li>
<li><a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md</a></li>
</ul>
</li>
<li><p>crash_mode</p>
<ul>
<li>-C 选项代表 crash_mode &#x3D; FAULT_CRASH，仅此设置</li>
</ul>
</li>
<li><p>dumb_mode</p>
<ul>
<li>默认为 0，在有 -n 选项的情况下，如果设置了 AFL_DUMB_FORKSRV 环境变量，dumb_mode &#x3D; 2，否则 dumb_mode &#x3D; 1</li>
</ul>
</li>
<li><p>out_file</p>
<ul>
<li>-f 指定，是等待 fuzz 的测试用例</li>
</ul>
</li>
<li><p>out_fd</p>
<ul>
<li>setup_stdio_file 中被设置为指向 out_dir&#x2F;.cur_input</li>
<li>out_fd 是指向 out_file 的文件描述符？可能的机制是，out_fd 默认指向 out_dir&#x2F;.cur_input，但是当用户指定了 out_file，则 out_file 顶替了默认的 out_dir&#x2F;.cur_input 的作用。</li>
</ul>
</li>
<li><p>var_bytes[i]</p>
</li>
</ul>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统数据结构</title>
    <url>/2024/09/05/linux%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>linux 系统中常见的数据结构</p>
<span id="more"></span>

<h1 id="struct-itimerval"><a href="#struct-itimerval" class="headerlink" title="struct itimerval"></a>struct itimerval</h1><p><code>struct itimerval</code>是一个用于设置定时器的结构体。它包含了两个成员变量，分别是<code>it_interval</code>和<code>it_value</code>。</p>
<p><code>it_interval</code>用于设置定时器的间隔时间，即每隔多少时间触发一次定时器。<code>it_value</code>用于设置定时器的初始值，即第一次触发定时器的时间。</p>
<p>这个结构体可以在C语言中使用，用于设置定时器以及处理定时器信号。例如，可以使用<code>setitimer()</code>函数来设置定时器并启动定时器信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="type">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">and gives the number of seconds and microseconds since the <span class="title function_">Epoch</span> <span class="params">(see time(<span class="number">2</span>))</span>.</span><br><span class="line"></span><br><span class="line">The tz argument is a <span class="keyword">struct</span> timezone:</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timezone &#123;</span><br><span class="line">	<span class="type">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">	<span class="type">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br><span class="line">Describes times in seconds and nanoseconds.</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>  tv_sec;  <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>    tv_nsec; <span class="comment">/* Nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="文件系统-stat"><a href="#文件系统-stat" class="headerlink" title="文件系统 stat"></a>文件系统 stat</h1><ul>
<li>在<code>E:\Ubuntushare\linux-6.0\arch\x86\include\uapi\asm\stat.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ino;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_nlink;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_rdev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blksize;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused4;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> S_ISREG(m)  is it a regular file?</p>
<pre><code>       S_ISDIR(m)  directory?

       S_ISCHR(m)  character device?

       S_ISBLK(m)  block device?

       S_ISFIFO(m) FIFO (named pipe)?

       S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)

       S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
</code></pre>
<p>成员变量的含义：</p>
<ul>
<li>st_dev：文件所在设备的设备号</li>
<li>st_ino：文件的i-node号</li>
<li>st_mode：文件的类型和访问权限</li>
<li>st_nlink：文件的硬链接数</li>
<li>st_uid：文件的所有者的用户ID</li>
<li>st_gid：文件的所有者的组ID</li>
<li>st_rdev：如果文件是设备文件，则该成员保存了设备的设备号</li>
<li>st_size：文件的大小（以字节为单位）</li>
<li>st_blksize：文件系统I&#x2F;O操作的最佳块大小</li>
<li>st_blocks：文件所占用的磁盘块数</li>
<li>st_atime：文件的最后访问时间</li>
<li>st_atime_nsec：文件的最后访问时间的纳秒部分</li>
<li>st_mtime：文件的最后修改时间</li>
<li>st_mtime_nsec：文件的最后修改时间的纳秒部分</li>
<li>st_ctime：文件的最后状态改变时间</li>
<li>st_ctime_nsec：文件的最后状态改变时间的纳秒部分</li>
<li>__unused4和__unused5：未使用的保留字段</li>
</ul>
<p>这个结构体是用于在C语言中对文件的状态进行描述和操作的一个重要数据结构。在C语言中，可以使用stat()函数来获取一个文件的状态，然后通过访问结构体的成员变量来获取文件的各种属性。</p>
<ul>
<li><p>本地化数据格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lconv</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Numeric (nonmonetary) information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *decimal_point;     <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *thousands_sep;     <span class="comment">/* Separator for digit groups to left</span></span><br><span class="line"><span class="comment">								of radix character */</span></span><br><span class="line">	<span class="type">char</span> *grouping;     <span class="comment">/* Each element is the number of digits in</span></span><br><span class="line"><span class="comment">							a group; elements with higher indices</span></span><br><span class="line"><span class="comment">							are further left.  An element with value</span></span><br><span class="line"><span class="comment">							CHAR_MAX means that no further grouping</span></span><br><span class="line"><span class="comment">							is done.  An element with value 0 means</span></span><br><span class="line"><span class="comment">							that the previous element is used for</span></span><br><span class="line"><span class="comment">							all groups further left. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remaining fields are for monetary information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *int_curr_symbol;   <span class="comment">/* First three chars are a currency</span></span><br><span class="line"><span class="comment">								symbol from ISO 4217.  Fourth char</span></span><br><span class="line"><span class="comment">								is the separator.  Fifth char</span></span><br><span class="line"><span class="comment">								is &#x27;\0&#x27;. */</span></span><br><span class="line">	<span class="type">char</span> *currency_symbol;   <span class="comment">/* Local currency symbol */</span></span><br><span class="line">	<span class="type">char</span> *mon_decimal_point; <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *mon_thousands_sep; <span class="comment">/* Like thousands_sep above */</span></span><br><span class="line">	<span class="type">char</span> *mon_grouping;      <span class="comment">/* Like grouping above */</span></span><br><span class="line">	<span class="type">char</span> *positive_sign;     <span class="comment">/* Sign for positive values */</span></span><br><span class="line">	<span class="type">char</span> *negative_sign;     <span class="comment">/* Sign for negative values */</span></span><br><span class="line">	<span class="type">char</span>  int_frac_digits;   <span class="comment">/* International fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  frac_digits;       <span class="comment">/* Local fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  p_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								positive value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  p_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a positive</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="type">char</span>  n_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								negative value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  n_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a negative</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="comment">/* Positive and negative sign positions:</span></span><br><span class="line"><span class="comment">		0 Parentheses surround the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		1 The sign string precedes the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		2 The sign string succeeds the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		3 The sign string immediately precedes the currency_symbol.</span></span><br><span class="line"><span class="comment">		4 The sign string immediately succeeds the currency_symbol. */</span></span><br><span class="line">	<span class="type">char</span>  p_sign_posn;</span><br><span class="line">	<span class="type">char</span>  n_sign_posn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>密码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">	<span class="type">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">	<span class="type">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">	<span class="type">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">	<span class="type">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">	<span class="type">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">	<span class="type">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">	<span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Creation time/time of last</span></span><br><span class="line"><span class="comment">									modification via shmctl() */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span> <span class="comment">//不关注最后一次detach的进程ID</span></span><br><span class="line">	<span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中的 ipc_perm 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">	<span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">	<span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">	<span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">	<span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">	<span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">								SHM_LOCKED flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源限制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>apue 学习记录</title>
    <url>/2024/06/19/apue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>apue 学习记录</p>
<span id="more"></span>

<ul>
<li><p>环境搭建：<a href="https://zhuanlan.zhihu.com/p/580675705">https://zhuanlan.zhihu.com/p/580675705</a></p>
</li>
<li><p>文件描述符和inode关系：<a href="https://blog.csdn.net/ambitiousssssss/article/details/124001467%EF%BC%8Chttps://blog.csdn.net/weixin_43864567/article/details/124063198">https://blog.csdn.net/ambitiousssssss/article/details/124001467，https://blog.csdn.net/weixin_43864567/article/details/124063198</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/kcloveworld/p/17989014">文件描述符、文件描述符表、文件表项、inode名词释义</a><br><a href="https://blog.csdn.net/kyang_823/article/details/79496362">https://blog.csdn.net/kyang_823/article/details/79496362</a></p>
</li>
<li><p>&#x2F;proc文件系统：<a href="https://blog.51cto.com/u_15127514/4196632">https://blog.51cto.com/u_15127514/4196632</a></p>
</li>
<li><p>虚拟文件系统VFS原理：<a href="https://blog.51cto.com/mingongge/2945174">https://blog.51cto.com/mingongge/2945174</a></p>
</li>
<li><p>重要头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">这个头文件包含了POSIX标准中定义的一些常用函数和类型，比如fork()、exec()系列函数，以及pid_t类型等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">这个头文件包含了系统调用的编号，比如SYS_gettid和SYS_tgkill等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">这个头文件定义了一些基本的数据类型，比如pid_t、size_t等。</span><br><span class="line"></span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">这个头文件包含了信号相关的函数和类型，比如SIGHUP信号常量。</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/perf/include/bpf/unistd.h</span><br><span class="line">./tools/arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./tools/include/nolibc/unistd.h</span><br><span class="line">./tools/include/uapi/asm-generic/unistd.h</span><br><span class="line">./arch/alpha/include/asm/unistd.h</span><br><span class="line">./arch/alpha/include/uapi/asm/unistd.h</span><br><span class="line">./arch/ia64/include/asm/unistd.h</span><br><span class="line">./arch/ia64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm64/include/asm/unistd.h</span><br><span class="line">./arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sparc/include/asm/unistd.h</span><br><span class="line">./arch/sparc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/uapi/asm/unistd.h</span><br><span class="line">./arch/parisc/include/asm/unistd.h</span><br><span class="line">./arch/parisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/riscv/include/asm/unistd.h</span><br><span class="line">./arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./arch/s390/include/asm/unistd.h</span><br><span class="line">./arch/s390/include/uapi/asm/unistd.h</span><br><span class="line">./arch/nios2/include/uapi/asm/unistd.h</span><br><span class="line">./arch/x86/include/asm/unistd.h</span><br><span class="line">./arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sh/include/asm/unistd.h</span><br><span class="line">./arch/sh/include/uapi/asm/unistd.h</span><br><span class="line">./arch/m68k/include/asm/unistd.h</span><br><span class="line">./arch/m68k/include/uapi/asm/unistd.h</span><br><span class="line">./arch/csky/include/asm/unistd.h</span><br><span class="line">./arch/csky/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm/include/asm/unistd.h</span><br><span class="line">./arch/arm/include/uapi/asm/unistd.h</span><br><span class="line">./arch/openrisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/mips/include/asm/unistd.h</span><br><span class="line">./arch/mips/include/uapi/asm/unistd.h</span><br><span class="line">./include/uapi/asm-generic/unistd.h</span><br><span class="line">./include/uapi/linux/unistd.h</span><br><span class="line">arch/mips/include/asm/unistd.h 通常包含了特定于MIPS架构的系统调用号码定义，这些定义是基于MIPS架构的特点定制的。</span><br><span class="line">arch/mips/include/uapi/asm/unistd.h 则包含了用户空间API的系统调用号码定义，这些定义是为了让用户空间程序能够安全地调用内核提供的服务。</span><br><span class="line">简单来说，uapi目录下的头文件通常用于定义用户空间可以使用的接口，而非特定于某个架构的内部细节。这样做的好处是，用户空间程序不必关心底层的硬件架构，只需通过统一的接口与内核通信。而asm目录下的头文件则包含了特定于某一架构的实现细节，这些细节对于用户空间程序是透明的，但对于内核开发者来说非常重要，因为它们涉及到如何在特定的硬件上实现系统调用.</span><br></pre></td></tr></table></figure>

<p>学习 apue 的目的是什么？<br>1.明白 linux 系统级知识，为读 AFL 源码做准备。<br>2.进而熟悉 linux 内核源码，可以对内核进行调试，修改。<br>目前好的 apue 学习素材：<br>1.b站李慧琴的课，相关笔记<a href="https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8">https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8</a><br>2.apue 书本<br>目前对 apue 的理解以及所能预料到的掌握后的能力：<br>1.熟悉了 linux 平台 进程 文件 信号机制 的原理，接口<br>2.能够在此基础之上进行应用程序开发</p>
<p>对于使用 afl 本身来说，了解平台机制就可以了，想要研究 afl 更重要的就是要对 afl 的原理进行更深入的研究。<br>以上都为计算机的术的话，计算机学习的道应该是什么？</p>
<p>6月20号：<br>1.昨天开始读 AFL 源码，主要是看 makefile ,问题是 makefile 语法还是不太熟悉，又转去看手册。makefile 里有 shell 命令，于是看 bash 手册<br>2.makefile bash 两个手册可以粗略看一下，花费一个半小时，然后开始看 AFL 源码</p>
<p>type command  查看命令类型</p>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>LibAFL入门</title>
    <url>/2024/06/15/LibAFL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>原文地址：<a href="https://www.atredis.com/blog/2023/12/4/a-libafl-introductory-workshop">LibAFL Introductory workshop — Atredis Partners</a></p>
<p>来自一家很酷的公司：<a href="https://www.atredis.com/careers">Careers — Atredis Partners</a></p>
<hr>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么选择-LibAFL"><a href="#为什么选择-LibAFL" class="headerlink" title="为什么选择 LibAFL"></a>为什么选择 LibAFL</h2><p>Fuzzing（模糊测试）非常棒！在正确的设置下，快速地向目标投掷随机输入可以产生不合理的效果。当开始一个新的目标时，模糊测试的框架可以与你的逆向工程&#x2F;审计工作一起迭代，你可以安心地睡觉，知道你的核心在夜间值班。在寻找漏洞时，我们的时间通常是有限的；任何花在工具上的努力都需要是值得的。LibAFL 是一个很棒的库，可以让我们快速地将模糊测试器适应我们的特定目标。并不是每个目标都适合“解析文件的命令行程序”类别，因此 LibAFL 让我们为特定情况制作模糊测试器。这种适应性为更广泛的目标打开了模糊测试的力量。</p>
<h2 id="为什么举办研讨会"><a href="#为什么举办研讨会" class="headerlink" title="为什么举办研讨会"></a>为什么举办研讨会</h2><p>以下材料来自一个内部研讨会，用作对 LibAFL 的介绍。这篇文章是对研讨会的总结，并包括一个练习和示例的仓库，供你在家跟随。它期望你已经有一些 Rust 和模糊测试概念的理解。（如果你需要复习 Rust：Google 的全面 Rust 是很棒的。）</p>
<p>已经有一些很好的资源可以学习 LibAFL。</p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>这个研讨会旨在增加用 LibAFL 构建的示例模糊测试器的现有语料库，重点是将模糊测试器定制到我们的目标。你还会找到一些入门问题，以便你亲手体验 LibAFL。在整个研讨会中，我们尝试突出库的多功能性和力量，让你看看你可以在哪里将模糊测试器融入你的流程。</p>
<h2 id="课程预告"><a href="#课程预告" class="headerlink" title="课程预告"></a>课程预告</h2><p>顺便说一句，如果你对这类事情（安全工具、漏洞、模糊测试）感兴趣，你可能会对我们的符号执行课程感兴趣。我们计划在 2024 年 2 月与 ringzer0 举行一次虚拟会议。本文末尾有更多信息。</p>
<h2 id="模糊测试器"><a href="#模糊测试器" class="headerlink" title="模糊测试器"></a>模糊测试器</h2><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在整个研讨会中，我们一直在测试一个在 Linux 上运行的简单目标。这个目标本身并不是很有趣，但作为我们模糊测试器的一个很好的示例目标。它逐行接收一些文本，并替换某些标识符（如 <code>&#123;&#123;XXd3sMRBIGGGz5b2&#125;&#125;</code>）为名称。为此，它包含一个具有非常大查找树的函数。在这个函数中，许多查找情况可能导致段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">uid_to_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* uid)</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span> <span class="comment">// 大量的嵌套 switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (nbuf[<span class="number">14</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="comment">// 常规情况，没有段错误</span></span><br><span class="line">        addr = &amp;names[<span class="number">0x4b9</span>];</span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">        <span class="comment">// 一个坏情况</span></span><br><span class="line">        addr = ((<span class="type">const</span> <span class="type">char</span>**)<span class="number">0x68c2</span>);</span><br><span class="line">        <span class="comment">// 这里 SEGFAULT</span></span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>

<p>这为我们提供了一个目标，它有许多不同的代码路径，并且有许多可达到的“漏洞”可以发现。随着我们的进展，我们将适应我们的模糊测试器到这个目标，展示一些常见的方法，我们可以使用 LibAFL 将模糊测试器塑造成一个目标。</p>
<p>你可以在这里找到我们的目标，并且仓库包括一些稍后示例中有用的变体。<a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target.c">.&#x2F;fuzz_target&#x2F;target.c</a></p>
<h2 id="模糊测试器的组成部分"><a href="#模糊测试器的组成部分" class="headerlink" title="模糊测试器的组成部分"></a>模糊测试器的组成部分</h2><p>在我们深入示例之前，让我们快速了解一下现代模糊测试器的内部结构。LibAFL 将模糊测试器分解为可以互换或更改的部分。LibAFL 充分利用了 <a href="https://google.github.io/comprehensive-rust/methods-and-traits/traits.html">Rust 的特性系统</a>来做到这一点。下面我们有一个非常简单的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器的脚本可能像下面这样简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ! [ -f ./core.* ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">head</span> -c 900 /dev/urandom &gt; ./testfile</span><br><span class="line">    <span class="built_in">cat</span> ./testfile | ./target</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上面的简单模糊测试器遵循三个核心步骤。</p>
<ol>
<li>生成一个随机输入</li>
<li>使用新输入运行目标</li>
<li>如果创建的输入导致“胜利”（在这种情况下，胜利是产生核心文件的崩溃），则保留该输入</li>
</ol>
<p>如果你错过了上述任何部分，你将不会有一个非常好的模糊测试器。我们都听说过研究人员将随机输入管道到他们的目标，得到了一个令人兴奋的崩溃，但因为他们没有保存测试用例，所以再也无法重现该漏洞的悲惨故事。</p>
<p>即使有了上述部分，那个简单的模糊测试器也会在发现漏洞方面挣扎。它甚至没有进展的概念！下面我们有一个更现代的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器基于一组现有的输入，这些输入被随机变异以创建新的测试用例。“变异”只是一组可以快速应用于输入的简单修改，以生成新的有趣的输入。重要的是，这个模糊测试器还使用执行目标的观察结果来知道输入是否“有趣”。与仅关心崩溃的模糊测试器不同，具有反馈的模糊测试器可以将变异的测试用例重新路由到要变异的输入集中。这允许模糊测试器通过迭代输入，跟踪目标中有趣的功能来取得进展。</p>
<p>LibAFL 为这些“部分”中的每一个提供了工具。</p>
<ul>
<li>实现 <code>Executor</code> 特性的将使用给定的测试用例运行目标。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html">https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html</a></li>
</ul>
</li>
<li><code>Corpus</code> 特性是用于保存一组测试用例的项目，通常用于输入或解决方案。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html">https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html</a></li>
</ul>
</li>
<li>实现 <code>Scheduler</code> 特性的东西负责从语料库中选择输入以制作下一个测试用例。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html">https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html</a></li>
</ul>
</li>
<li>实现 <code>Mutator</code> 特性的提供在运行前更改输入的修改。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html">https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html</a></li>
</ul>
</li>
<li><code>Feedback</code> 和 <code>Observer</code> 特性提供了有用的工具，用于决定输入是否有用。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html">https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html</a></li>
<li><a href="https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html">https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html</a></li>
</ul>
</li>
</ul>
<p>我们还将看到其他重要的特性。一定要查看特性文档中的“实现者”部分，看看库提供的有用实现。</p>
<h2 id="Exec-模糊测试器"><a href="#Exec-模糊测试器" class="headerlink" title="Exec 模糊测试器"></a>Exec 模糊测试器</h2><p>这就带我们来到了我们的第一个示例！让我们通过使用 LibAFL 的一个基本模糊测试器来逐步了解。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer/src/main.rs">.&#x2F;exec_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>源代码有详细的注释，你应该仔细阅读。这里我们只突出一些关键部分。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = CommandExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = StdState::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            StdRand::<span class="title function_ invoke__">with_seed</span>(<span class="title function_ invoke__">current_nanos</span>()),</span><br><span class="line">            InMemoryCorpus::&lt;BytesInput&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            OnDiskCorpus::<span class="title function_ invoke__">new</span>(PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;./solutions&quot;</span>)).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            &amp;<span class="keyword">mut</span> feedback,</span><br><span class="line">            &amp;<span class="keyword">mut</span> objective,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>我们的模糊测试器使用一个“状态”对象，该对象跟踪输入测试用例的集合、任何解决方案测试用例以及其他元数据。注意我们选择将输入保存在内存中，但将解决方案测试用例保存到磁盘上。</p>
<p>我们使用 <code>CommandExecutor</code> 来执行我们的目标程序，它将运行目标进程并传入测试用例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            <span class="title function_ invoke__">havoc_mutations</span>(),</span><br><span class="line">            <span class="number">9</span>,                 <span class="comment">// 最大变异迭代次数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stages</span> = tuple_list!(StdMutationalStage::<span class="title function_ invoke__">new</span>(mutator));</span><br></pre></td></tr></table></figure>

<p>我们为输入构建了一个非常简单的管道。这个管道只有一个阶段，它将为每个测试用例随机选择一组变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">scheduler</span> = RandScheduler::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fuzzer</span> = StdFuzzer::<span class="title function_ invoke__">new</span>(scheduler, feedback, objective);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载我们状态中的初始语料库</span></span><br><span class="line">        <span class="comment">// 由于我们在这个模糊测试器中缺乏反馈，我们必须强制执行</span></span><br><span class="line">        state.<span class="title function_ invoke__">load_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> mgr, &amp;[PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;../fuzz_target/corpus/&quot;</span>)]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊测试</span></span><br><span class="line">        fuzzer.<span class="title function_ invoke__">fuzz_loop</span>(&amp;<span class="keyword">mut</span> stages, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> state, &amp;<span class="keyword">mut</span> mgr).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error in fuzz loop&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过一个调度器和一些反馈（这里我们使用 <code>ConstFeedback::False</code> 来没有任何反馈，除了目标反馈，这是一个 <code>CrashFeedback</code>），我们可以加载我们的初始条目并开始模糊测试。我们使用创建的阶段、选择的执行器、状态和一个事件管理器来开始模糊测试。我们的事件管理器将让我们知道当我们开始获得“胜利”时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan exec_fuzzer]$ ./target/release/exec_fuzzer/</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 3, objectives: 0, executions: 3, exec/sec: 0.000</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 3, objectives: 1, executions: 3, exec/sec: 2.932</span><br><span class="line">[Stats #0] run time: 0h-0m-15s, clients: 1, corpus: 3, objectives: 1, executions: 38863, exec/sec: 2.590k</span><br><span class="line">[Objective #0] run time: 0h-0m-20s, clients: 1, corpus: 3, objectives: 2, executions: 38863, exec/sec: 1.885k</span><br></pre></td></tr></table></figure>

<p>我们脆弱的目标很快就开始给我们崩溃，即使没有反馈。从一组有用的输入开始有助于我们的变异能够找到崩溃的输入。</p>
<p>这个简单的执行模糊测试器为我们提供了一个良好的基础，我们可以在此基础上添加更多功能。</p>
<h2 id="带自定义反馈的-Exec-模糊测试器"><a href="#带自定义反馈的-Exec-模糊测试器" class="headerlink" title="带自定义反馈的 Exec 模糊测试器"></a>带自定义反馈的 Exec 模糊测试器</h2><p>没有反馈，我们就不能有效地迭代有趣的输入。目前我们的随机变异必须一次性生成一个崩溃的案例。如果我们能向模糊测试器添加反馈，那么我们就可以识别出做了一些有趣事情的测试用例。我们将这些有趣的测试用例循环回我们的测试用例集中，进行进一步的变异。</p>
<p>我们可以从许多不同的来源获取这些信息。对于这个示例，让我们使用 <code>fuzz_target/target_dbg</code> 二进制文件，这是我们目标的调试输出版本。通过查看这个调试输出，我们可以开始识别有趣的案例。如果一个测试用例让我们得到了我们之前没有见过的调试输出，那么我们可以认为它是有趣的，值得进一步迭代。</p>
<p>LibAFL 库中没有这种反馈的现有实现，所以我们必须自己制作！如果你想自己尝试，我们在仓库中提供了一个模板文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/exec_fuzzer_stderr_template">.&#x2F;exec_fuzzer_stderr_template&#x2F;</a></p>
<p>LibAFL 仓库提供了一个 <code>StdErrObserver</code> 结构，我们可以将其与我们的 <code>CommandExecutor</code> 一起使用。这个观察者将允许我们的自定义反馈结构接收我们运行的 <code>stderr</code> 输出。我们所要做的就是创建一个实现 <code>Feedback</code> 特性的 <code>is_interesting</code> 方法的结构，我们就应该可以开始了。在该方法中，我们提供了状态、变异输入、观察者。我们只需要从 StdErrObserver 获取调试输出，并确定我们是否到达了新的位置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Feedback&lt;S&gt; <span class="keyword">for</span> <span class="title class_">NewOutputFeedback</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: UsesInput + HasClientPerfMonitor,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">        _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">        _input: &amp;S::Input,</span><br><span class="line">        observers: &amp;OT,</span><br><span class="line">        _exit_kind: &amp;ExitKind</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">        OT: ObserversTuple&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 Ok(false) 对于不有趣的输入</span></span><br><span class="line">        <span class="comment">// 返回 Ok(true) 对于有趣的输入</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我鼓励你自己尝试实现这个反馈。你可能想要找到一些启发式方法来忽略无帮助的调试消息。我们希望避免报告太多的输入作为有用的，这样我们就不会过度填充我们的输入语料库。输入语料库是我们用于生成新测试用例的输入集。如果语料库中有太多实际上并没有帮助我们挖掘胜利的输入，我们将浪费大量时间。理想情况下，我们希望这些输入尽可能小且运行速度快，同时在我们的目标中执行独特的路径。</p>
<p>在我们的解决方案中，我们简单地保持一组已看到的哈希。如果我们看到它导致了一个独特的哈希，我们就会报告输入是有趣的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer_stderr/src/main.rs">.&#x2F;exec_fuzzer_stderr&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">            _input: &amp;S::Input,</span><br><span class="line">            observers: &amp;OT,</span><br><span class="line">            _exit_kind: &amp;ExitKind</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">           <span class="keyword">where</span> EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">                 OT: ObserversTuple&lt;S&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">observer</span> = observers.match_name::&lt;StdErrObserver&gt;(&amp;<span class="keyword">self</span>.observer_name)</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;A NewOutputFeedback needs a StdErrObserver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            hasher.<span class="title function_ invoke__">write</span>(&amp;observer.stderr.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">contains</span>(&amp;hash) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">insert</span>(hash);</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这最终非常快地找到了“有趣”的输入，并迅速增加了我们的输入语料库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 308, objectives: 0, executions: 4388, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 0, executions: 4423, exec/sec: 2.520k</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 1, executions: 4423, exec/sec: 2.497k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 310, objectives: 1, executions: 4532, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 311, objectives: 1, executions: 4629, exec/sec: 2.521k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率反馈"><a href="#代码覆盖率反馈" class="headerlink" title="代码覆盖率反馈"></a>代码覆盖率反馈</h2><p>依赖程序的正常副作用（如调试输出、系统交互等）并不是深入探索目标的可靠方法。使用这种反馈，我们可能会错过许多有趣的特性。许多现代模糊测试器的首选反馈是“代码覆盖率”。通过观察哪些代码块正在被执行，我们可以了解哪些输入暴露了有趣的逻辑。</p>
<p>然而，收集这些信息并不总是直接的。如果你可以访问源代码，你可能可以使用编译器来为代码添加这些信息。如果没有，你可能必须通过二进制修改、仿真或其他来源动态地为你的目标添加工具。</p>
<p>AFL++ 提供了一个版本的 clang，用于编译器级别的工具，提供代码覆盖率反馈。LibAFL 可以观察这种工具生成的信息，我们可以使用它作为反馈。我们有一个使用 <code>afl-clang-fast</code> 构建的目标。有了这个构建（ <code>target_instrumented</code>），我们可以使用 LibAFL 的 <code>ForkserverExecutor</code> 与我们的工具目标进行通信。<code>HitcountsMapObserver</code> 可以使用共享内存来接收每次运行的覆盖率信息。</p>
<p>你可以在这里看到我们模糊测试器的代码。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_fuzzer/src/main.rs">.&#x2F;aflcc_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem_provider</span> = UnixShMemProvider::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem</span> = shmem_provider.<span class="title function_ invoke__">new_shmem</span>(MAP_SIZE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// 将 id 写入环境变量以供 forkserver 使用</span></span><br><span class="line">        shmem.<span class="title function_ invoke__">write_to_env</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shmembuf</span> = shmem.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line">        <span class="comment">// 基于该缓冲区构建观察者，与目标共享</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">edges_observer</span> = <span class="keyword">unsafe</span> &#123;HitcountsMapObserver::<span class="title function_ invoke__">new</span>(StdMapObserver::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shared_mem&quot;</span>, shmembuf))&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用观察到的覆盖率来反馈基于获得最大覆盖率</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">feedback</span> = MaxMapFeedback::<span class="title function_ invoke__">tracking</span>(&amp;edges_observer, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 这次我们可以使用 fork 服务器执行器，它使用 instrumented in fork server</span></span><br><span class="line">    <span class="comment">// 它通过分叉部分实例化的过程而不是每次从头开始，从而获得更多的每秒执行次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_instrumented&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">        .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>编译的 fork 服务器还应该减少我们需要实例化运行的时间，通过分叉部分实例化的过程而不是从头开始。这应该抵消我们工具的一些成本。</p>
<p>执行时，我们的模糊测试器迅速找到了新的过程路径，建立了我们有趣的案例语料库，并指导我们的模糊测试器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan aflcc_fuzzer]$ ./target/release/aflcc_fuzzer</span><br><span class="line"></span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 0, executions: 19152, exec/sec: 1.823k</span><br><span class="line">[Objective #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.762k</span><br><span class="line">[Stats #0] run time: 0h-0m-11s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.723k</span><br><span class="line">[Testcase #0] run time: 0h-0m-11s, clients: 1, corpus: 101, objectives: 1, executions: 20250, exec/sec: 1.821k</span><br></pre></td></tr></table></figure>

<h2 id="自定义变异"><a href="#自定义变异" class="headerlink" title="自定义变异"></a>自定义变异</h2><p>到目前为止，我们一直在使用 <code>havoc_mutations</code>，你可以看到这里是一组对许多目标都非常好的变异。</p>
<p><a href="https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296">https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296</a></p>
<p>这些变异中的许多对我们的目标来说是浪费的。为了到达易受攻击的 <code>uid_to_name</code> 函数，输入首先必须通过 <code>valid_uid</code> 检查。在这个检查中，范围之外的字符 <code>A-Za-z0-9\-_</code> 被拒绝。许多 <code>havoc_mutations</code>，例如 <code>BytesRandInsertMutator</code>，将引入不在该范围内的字符。这导致许多测试用例被浪费。</p>
<p>有了关于我们目标的这些知识，我们可以使用一个自定义变异器，它只会在所需的范围内插入新的字节。实现 <code>Mutator</code> 特性很简单，我们只需要提供一个 <code>mutate</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;I, S&gt; Mutator&lt;I, S&gt; <span class="keyword">for</span> <span class="title class_">AlphaByteSwapMutator</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        I: HasBytesVec,</span><br><span class="line">        S: HasRand,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                return Ok(MutationResult::Mutated) when you mutate the input</span></span><br><span class="line"><span class="comment">                or Ok(MutationResult::Skipped) when you don&#x27;t</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想自己尝试这个，欢迎使用 <code>aflcc_custom_mut_template</code> 作为起点。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_mut_template/">.&#x2F;aflcc_custom_mut_template&#x2F;</a></p>
<p>在我们的解决方案中，我们使用一组变异器，包括我们的新 <code>AlphaByteSwapMutator</code> 和一些现有的变异器。这个集合应该会产生更多的有效测试用例，使其到达 <code>uid_to_name</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们将指定我们的自定义变异器，以及另外两个有助于增长或缩小的变异器</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            tuple_list!(</span><br><span class="line">                AlphaByteSwapMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesDeleteMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesInsertMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            ),</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>然后在我们的变异器中，我们使用状态的随机源来选择位置，并从一组有效字符中选择一个新的字节。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里我们应用我们的随机变异</span></span><br><span class="line">            <span class="comment">// 对于我们的目标，简单地交换一个字节应该是有效的</span></span><br><span class="line">            <span class="comment">// 只要我们的新字节是 0-9A-Za-z 或 &#x27;-&#x27; 或 &#x27;_&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空输入</span></span><br><span class="line">            <span class="keyword">if</span> input.<span class="title function_ invoke__">bytes</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择一个随机字节</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte</span>: &amp;<span class="keyword">mut</span> <span class="type">u8</span> = state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(input.<span class="title function_ invoke__">bytes_mut</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不要替换标签字符 &#x27;&#123;&#123;&#125;&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> *byte == <span class="string">b&#x27;&#123;&#x27;</span> || *byte == <span class="string">b&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在我们可以将该字节替换为一个已知好的字节</span></span><br><span class="line">            *byte = *state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(&amp;<span class="keyword">self</span>.good_bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 技术上我们应该说“跳过”如果我们用它自己替换一个字节，但这现在没问题</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Mutated)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>就是这样！自定义变异器与系统的其余部分无缝协作。能够像这样快速调整模糊测试器是适应目标的好方法。结合性能测量，这样的实验可以帮助我们快速迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 76, objectives: 1, executions: 2339, exec/sec: 1.895k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.933k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.928k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 78, objectives: 1, executions: 2392, exec/sec: 1.933k</span><br></pre></td></tr></table></figure>

<h2 id="示例问题"><a href="#示例问题" class="headerlink" title="示例问题"></a>示例问题</h2><p>到这一点，我们有一个单独的目标，你可能想要尝试！它是一个包含一个小迷宫的程序，并给你一个机会创建一个模糊测试器，使用一些自定义反馈或变异来更好地遍历迷宫并发现崩溃。尝试我们在这里介绍的一些概念，并看看你的模糊测试器有多快可以解决迷宫。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/maze_target/">.&#x2F;maze_target&#x2F;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[jordan maze_target]$ ./maze -p</span><br><span class="line"></span><br><span class="line">██████████████</span><br><span class="line">█.██......█ ██</span><br><span class="line">█....██ █.☺  █</span><br><span class="line">██████  █ ██ █</span><br><span class="line">██   ██████  █</span><br><span class="line">█  █  █     ██</span><br><span class="line">█ ███   ██████</span><br><span class="line">█  ███ ██   ██</span><br><span class="line">██   ███  █  █</span><br><span class="line">████ ██  ███ █</span><br><span class="line">█    █  ██ █ █</span><br><span class="line">█ ████ ███ █ █</span><br><span class="line">█          █  </span><br><span class="line">████████████</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### #### #</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #...@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..<span class="comment">######...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.<span class="comment">##.#  ######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....<span class="comment"># ##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-2s, clients: 1, corpus: 49, objectives: 0, executions: 5745, exec/sec: 2.585k</span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### ####@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #....#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..<span class="comment">######...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.<span class="comment">##.#  ######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....<span class="comment"># ##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-3s, clients: 1, corpus: 50, objectives: 0, executions: 8892, exec/sec: 2.587k</span><br></pre></td></tr></table></figure>

<h2 id="更快地进行模糊测试"><a href="#更快地进行模糊测试" class="headerlink" title="更快地进行模糊测试"></a>更快地进行模糊测试</h2><h2 id="持久模糊测试器"><a href="#持久模糊测试器" class="headerlink" title="持久模糊测试器"></a>持久模糊测试器</h2><p>在前面的示例中，我们使用了 <code>ForkserverExecutor</code>，它与 <code>afl-clang-fast</code> 插入到我们目标中的 fork 服务器一起工作。虽然 fork 服务器通过减少每个目标进程的启动时间给了我们很大的速度提升，但我们仍然需要为每个测试用例创建一个新进程。如果我们可以在一个进程中运行多个测试用例，我们可以大大加快我们的模糊测试。在一个目标进程中运行多个测试用例通常被称为“持久模式”模糊测试。</p>
<p>正如 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/61e27c6b54f7641a168b6acc6ecffb1754c10918/docs/fuzzing_in_depth.md?plain=1#L371">AFL++ 文档</a>中所说：</p>
<blockquote>
<p>基本上，如果你不以持久模式对目标进行模糊测试，那么你就是在业余地进行模糊测试，而不是专业地进行模糊测试。</p>
</blockquote>
<p>一些目标与持久模式不兼容。每次运行都会改变大量全局状态的任何内容都可能遇到麻烦，因为我们希望每个测试用例尽可能独立运行。即使对于适合持久模式的目标，我们通常也需要为目标代码创建一个框架。这个框架只是我们编写的一些代码，用于调用目标进行模糊测试。<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md">AFL++ 文档中关于 LLVM 的持久模式</a>是编写这些类型框架的一个很好的参考。</p>
<p>当我们创建了这样的框架时，插入的 fork 服务器将检测到持久的能力，甚至可以使用共享内存来提供测试用例。LibAFL 的 <code>ForkserverExecutor</code> 可以让我们利用这些持久框架。</p>
<p>使用持久框架的模糊测试器与我们之前的模糊测试器没有太大变化。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/persistent_fuzzer/src/main.rs">.&#x2F;persistent_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>主要变化在于告诉我们的 <code>ForkServerExecutor</code> 它 <code>is_persistent(true)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_persistent&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">is_persistent</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">            .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><code>ForkserverExecutor</code> 负责使这一切发生。我们的大部分工作都投入到实际创建一个有效的框架中！如果你想尝试自己制作，我们已经为你准备了一些模板，让你开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent_template.c">.&#x2F;fuzz_target&#x2F;target_persistent_template.c</a></p>
<p>在我们的框架中，我们要注意每次运行后重置状态，以便我们尽可能接近原始状态。任何修改的全局变量、堆分配或运行的副作用，可能会改变未来运行的行为，需要被撤销。未能清除程序状态可能导致误报或不稳定。如果我们希望这个模糊测试器的成功测试用例也能使原始目标崩溃，那么我们需要尽可能地模拟原始目标的行为。</p>
<p>有时，模拟原始目标并不值得，而是使用我们的框架来针对更深层次的表面。例如，在我们的目标中，我们可以直接针对 <code>uid_to_name</code> 函数，然后在以后将解决方案转换为原始目标的解决方案。我们还会希望在我们的框架中调用 <code>valid_uid</code>，以确保我们不会报告永远不会对我们的原始目标起作用的误报。</p>
<p>你可以在这里检查我们的持久框架；我们选择为每行反复调用 <code>process_line</code> 并注意清理我们自己。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent.c">.&#x2F;fuzz_target&#x2F;target_persistent.c</a></p>
<p>在那里之前，我们看到了大约每秒 2k 次执行的模糊测试器，使用代码覆盖率反馈，现在我们看到大约每秒 5k 或 6k，仍然只有一个客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 171, objectives: 4, executions: 95677, exec/sec: 5.826k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.860k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.821k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.863k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.798k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.866k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.855k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.867k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.853k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 176, objectives: 4, executions: 98488, exec/sec: 5.866k</span><br></pre></td></tr></table></figure>

<h2 id="进程内模糊测试器"><a href="#进程内模糊测试器" class="headerlink" title="进程内模糊测试器"></a>进程内模糊测试器</h2><p>使用 AFL++ 的编译器和 fork 服务器并不是实现一个进程中多个测试用例的唯一方法。LibAFL 是一个极其灵活的库，支持各种场景。<code>InProcessExecutor</code> 允许我们在与我们的模糊测试逻辑相同的进程中直接运行测试用例。这意味着如果我们能以某种方式与我们的目标链接，我们就可以在同一进程中进行模糊测试。</p>
<p>LibAFL 的多功能性意味着我们可以将我们的整个模糊测试器构建为库，我们可以将其链接到我们的目标中，甚至可以动态地预加载到我们的目标中。LibAFL 甚至支持 <code>nostd</code>（不依赖于操作系统或标准库的编译），因此我们可以将我们的整个模糊测试器视为一个 blob 注入到我们目标的环境。</p>
<p>在我们的示例中，我们将我们的模糊测试器与我们的目标构建为静态库，并使用 Rust 的 FFI 直接调用 C 代码。</p>
<p>通过提供一个 <code>build.rs</code> 文件来构建我们的模糊测试器并使其与我们的目标链接，Rust 编译将使用该文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/inproc_fuzzer/build.rs">.&#x2F;inproc_fuzzer&#x2F;build.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_dir</span> = <span class="string">&quot;../fuzz_target&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_lib</span> = <span class="string">&quot;target_libfuzzer&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制我们链接文件 &#x27;libtarget_libfuzzer.a&#x27;</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;</span>, &amp;target_dir);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=static:+whole-archive=&#123;&#125;&quot;</span>, &amp;target_lib);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=build.rs&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了工具来包装 clang 编译器，如果你希望创建一个编译器，它将自动将你的模糊测试器注入到目标中。你可以在 LibAFL 示例中看到这一点。</p>
<p>我们还需要一个框架来处理这个目标，这样我们就可以将测试用例作为缓冲区传递，而不是让目标从 <code>stdin</code> 读取行。我们将使用 <code>libfuzzer</code> 使用的公共接口，这让我们创建一个名为 <code>LLVMFuzzerTestOneInput</code> 的函数。LibAFL 甚至有一些助手函数可以为我们执行 FFI 调用。</p>
<p>我们的框架可以与我们为持久模式模糊测试创建的框架非常相似。我们还要注意与持久模式模糊测试中相同的全局状态或内存泄漏，这些可能会使我们的模糊测试不稳定。同样，如果你想要自己制作框架，我们有一个模板供你参考。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_libfuzzer_template.c">.&#x2F;fuzz_target&#x2F;target_libfuzzer_template.c</a></p>
<p>在目标中定义了 <code>LLVMFuzzerTestOneInput</code> 并制作了静态库后，我们的模糊测试器可以直接调用框架进行每个测试用例。我们定义了一个 <code>harness</code> 函数，我们的执行器将使用测试用例数据调用该函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架</span></span><br><span class="line">        <span class="comment">// 调用 libfuzzer 风格的框架</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="comment">// 这只是一些不错的调用 libfuzzer C 函数的调用</span></span><br><span class="line">            <span class="comment">// 但我们不需要使用 libfuzzer 框架来进行进程内模糊测试</span></span><br><span class="line">            <span class="comment">// 我们可以调用任何链接的函数，只要它是一个框架</span></span><br><span class="line">            <span class="title function_ invoke__">libfuzzer_test_one_input</span>(buf);</span><br><span class="line">            <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = InProcessExecutor::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> harness,</span><br><span class="line">            tuple_list!(edges_observer),</span><br><span class="line">            &amp;<span class="keyword">mut</span> fuzzer,</span><br><span class="line">            &amp;<span class="keyword">mut</span> state,</span><br><span class="line">            &amp;<span class="keyword">mut</span> restarting_mgr,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这种与 libfuzzer 框架的轻松互操作性很好，我们再次看到比我们之前的模糊测试器有巨大的速度提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan inproc_fuzzer]$ ./target/release/inproc_fuzzer</span><br><span class="line"></span><br><span class="line">启动中</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-16s, clients: 2, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">                  (CLIENT) corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000, edges: 0/37494 (0%)</span><br><span class="line">...</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k, edges: 136/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k, edges: 137/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k</span><br><span class="line">                  (CLIENT) corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k, edges: 137/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-20s, clients: 2, corpus: 103, objectives: 6, executions: 106626, exec/sec: 28.32k</span><br></pre></td></tr></table></figure>

<p>在这个模糊测试器中，我们还在利用 LibAFL 提供的一个非常重要的工具：低级消息传递（LLMP）。这提供了多个客户端之间的快速通信，并让我们有效地将模糊测试扩展到多个核心甚至多台机器。<code>setup_restarting_mgr_std</code> 辅助函数创建了一个事件管理器，该管理器将管理客户端，并在它们遇到崩溃时重新启动它们。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">monitor</span> = MultiMonitor::<span class="title function_ invoke__">new</span>(|s| <span class="built_in">println!</span>(<span class="string">&quot; &#123;s&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们使用一个重新启动管理器，每次崩溃时都会重新启动</span></span><br><span class="line">        <span class="comment">// 我们的进程</span></span><br><span class="line">        <span class="comment">// 这将设置一个主机管理器，我们将不得不启动其他进程</span></span><br><span class="line">        <span class="keyword">let</span> (state, <span class="keyword">mut</span> restarting_mgr) = <span class="title function_ invoke__">setup_restarting_mgr_std</span>(monitor, <span class="number">1337</span>, EventConfig::<span class="title function_ invoke__">from_name</span>(<span class="string">&quot;default&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法设置重启器！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有客户端将从上面的调用中返回</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;我们是客户端！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种速度提升很重要，可以使你找到重要的漏洞或找不到。另外，在冬天让你的房间变暖一些感觉很好。</p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>当然，并不是所有的目标都很容易与链接或使用编译器进行工具化。在这些情况下，LibAFL 提供了一些有趣的工具，如 <code>libafl_frida</code> 或 <code>libafl_nyx</code>。在下一个示例中，我们将使用 LibAFL 的修改版 QEMU 为我们没有内置工具化的二进制文件提供代码覆盖率反馈。修改版的 QEMU 将向我们的模糊测试器公开代码覆盖率信息以进行反馈。</p>
<p>设置将类似于我们的进程内模糊测试器，但现在我们的框架将负责在目标中运行仿真器。默认情况下，仿真器状态不会为你重置，你将希望重置每次运行之间更改的任何全局状态。</p>
<p>如果你想自己尝试，请参阅<a href="https://docs.rs/libafl_qemu/0.10.1/libafl_qemu/emu/struct.Emulator.html">仿真器文档</a>，并随时从我们的模板开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/qemu_fuzzer_template">.&#x2F;qemu_fuzzer_template&#x2F;</a></p>
<p>在我们的解决方案中，我们首先执行一些初始化，直到一个断点，然后保存堆栈和返回地址。我们将不得不每次运行重置堆栈，并在返回地址上放置一个断点，以便我们可以在调用后停止。我们还在目标中映射一个区域，可以放置我们的输入。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(mainptr);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pc</span>: GuestReg = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Pc).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">remove_breakpoint</span>(mainptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 ret 地址，以便我们可以使用它并停止</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">retaddr</span>: GuestAddr = emu.<span class="title function_ invoke__">read_return_address</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(retaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">savedsp</span>: GuestAddr = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Sp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在让我们在目标中映射一个区域，我们将用于输入。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inputaddr</span> = emu.<span class="title function_ invoke__">map_private</span>(<span class="number">0</span>, <span class="number">0x1000</span>, MmapPerms::ReadWrite).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Input page @ &#123;inputaddr:#x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在在框架本身中，我们将输入并将其写入目标，然后开始在目标函数中执行。这次我们直接执行 <code>uid_to_name</code> 函数，并使用一个变异器，该变异器不会添加任何 <code>valid_uid</code> 会停止的无效字符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">len</span> = buf.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制我们的输入大小</span></span><br><span class="line">            <span class="keyword">if</span> len &gt; <span class="number">1024</span> &#123;</span><br><span class="line">                buf = &amp;buf[<span class="number">0</span>..<span class="number">1024</span>];</span><br><span class="line">                len = <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将我们的测试用例写入内存，以 null 终止</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr, buf);</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr + (len <span class="keyword">as</span> <span class="type">u64</span>), <span class="string">b&quot;\0\0\0\0&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 根据需要重置寄存器</span></span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Pc, parseptr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Sp, savedsp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_return_address</span>(retaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Rdi, inputaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行直到我们的返回地址断点</span></span><br><span class="line">            <span class="comment">// 或崩溃</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果我们没有崩溃，我们很好</span></span><br><span class="line">            ExitKind::<span class="literal">Ok</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这种仿真可以非常快，特别是如果我们可以在每次运行之间不必重置大量状态。通过在这里针对更深层的函数，我们可能会很快达到崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 54, objectives: 0, executions: 33349, exec/sec: 31.56k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 32.85k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 31.59k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 0, executions: 36124, exec/sec: 32.87k</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 1, executions: 36124, exec/sec: 28.73k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了一些有用的助手，如 <code>QemuAsanHelper</code> 和 <code>QemuSnapshotHelper</code>。甚至还有支持全系统仿真，而不是用户模式仿真。能够有效地使用仿真器进行模糊测试可以打开一个全新的目标世界。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>我们从一些初始输入开始，然后简单地变异它们的方法对于某些目标来说可能非常有效，但对于更复杂的输入则不那么有效。如果我们从一个像这样的 javascript 输入开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现有的变异可能会产生以下结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>\x00 (a &lt;\u003c b) &#123;</span><br><span class="line">    <span class="title function_">somefu</span>(a;;;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能会在解析器中发现一些漏洞，但不太可能在任何 javascript 引擎中发现更深层次的漏洞。如果我们想要锻炼引擎本身，我们将希望主要产生有效的 javascript。这是生成的一个很好的用例！通过定义一个语法，描述有效的 javascript 看起来像什么，我们可以生成大量的测试用例来对抗引擎。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"></p>
<p>正如你在上面的图表中看到的，仅靠生成我们就不再使用变异+反馈循环。有许多成功的模糊测试器仅靠生成就获得了胜利（<a href="https://github.com/googleprojectzero/domato">domato</a>、<a href="https://boofuzz.readthedocs.io/en/stable/">boofuzz</a>、<a href="https://www.atredis.com/blog/2022/03/29/veni-midi-vici-conquering-cve-2022-22657-and-cve-2022-22664">一堆奇怪的 midi 文件</a>），但我们希望在我们的模糊测试中有一些形式的反馈和进展。</p>
<p>为了在我们的生成中利用反馈，我们可以创建一个生成数据的中间表示（IR）。然后我们可以将有趣的案例反馈到我们的输入中，以便进一步变异。</p>
<p>所以我们之前的 javascript 可以像这样表达为令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (var a), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func,</span><br><span class="line">            (arg_list (var a))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们对这种标记版本的变异可以做的事情包括用其他有效的令牌替换令牌或向树添加更多节点，创建一个稍微不同的输入。然后我们可以像以前一样使用这些 IR 输入和变异，结合代码覆盖率反馈。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
<p>现在对 IR 的变异可能会产生像这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (const 0), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func</span><br><span class="line">            (arg_list</span><br><span class="line">                (func_call some_func,</span><br><span class="line">                    (arg_list ((var a), (var a)))</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这将呈现为有效的 javascript，并且如果它产生有趣的反馈，可以进一步变异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(<span class="title function_">somefunc</span>(a,a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 提供了一些很棒的工具，帮助你拥有一个带有反馈的生成模糊测试器。LibAFL 中包含了一个 <a href="https://github.com/nautilus-fuzz/nautilus">Nautilus 模糊测试器</a>的版本。为了使用它与我们的例子，我们首先定义一个语法，描述我们目标的有效输入是什么样的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/grammar.json">.&#x2F;aflcc_custom_gen&#x2F;grammar.json</a></p>
<p>有了 LibAFL，我们可以将这个语法加载到一个 <code>NautilusContext</code> 中，我们可以使用它进行生成。我们使用 <code>InProcessExecutor</code>，在我们的框架中，我们接受一个 <code>NautilusInput</code>，我们将其呈现为字节并传递给我们的 <code>LLVMFuzzerTestOneInput</code>。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/src/main.rs">.&#x2F;aflcc_custom_gen&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不能使用普通的字节变异，所以我们使用在我们生成器树上工作的变异</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">        tuple_list!(</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRecursionMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>我们还需要生成一些初始 IR 输入并指定要使用的变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">must_load_initial_inputs</span>() &#123;</span><br><span class="line">        <span class="comment">// 与从初始语料库加载不同，我们将生成 9 个 NautilusInputs 的初始语料库</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">generator</span> = NautilusGenerator::<span class="title function_ invoke__">new</span>(&amp;genctx);</span><br><span class="line">        state.<span class="title function_ invoke__">generate_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> generator, &amp;<span class="keyword">mut</span> restarting_mgr, <span class="number">9</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Created initial inputs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>有了这一切，我们可以运行并获得生成、代码覆盖率和进程内执行的结合优势。为了进一步改进这一点，我们可以随着对我们目标的更好理解而改进我们的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                  (CLIENT) corpus: 145, objectives: 2, executions: 40968, exec/sec: 1.800k, edges: 167/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k, edges: 167/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k, edges: 167/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-27s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.755k</span><br></pre></td></tr></table></figure>

<p>注意，我们保存的解决方案只是序列化的 <code>NautilusInputs</code>，并且在原始目标上使用时将不起作用。我们创建了一个单独的项目，将这些解决方案呈现为字节。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/gen_solution_render/src/main.rs">.&#x2F;gen_solution_render&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: NautilusInput = NautilusInput::<span class="title function_ invoke__">from_file</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tree_depth</span> = <span class="number">0x45</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">genctx</span> = NautilusContext::<span class="title function_ invoke__">from_file</span>(tree_depth, grammarpath);</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;PLvkLizOcGccywcS&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">&#123;&#123;EGgkWs-PxeqpwBZK&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;hlNeoKiwMTNfqO_h&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0 | ../fuzz_target/target</span><br><span class="line"></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="示例问题-2"><a href="#示例问题-2" class="headerlink" title="示例问题 2"></a>示例问题 2</h2><p>这给我们带来了第二个带回家的问题！我们有一个聊天客户端，它容易受到许多问题的影响。通过好好利用生成和&#x2F;或仿真，可以使对二进制文件的模糊测试变得更容易。在你发现一些嘈杂的漏洞时，你可能希望在你的模糊测试器中避免这些路径，或者在你的目标中修补这些漏洞。漏洞经常会掩盖其他漏洞。你可以在这里找到目标。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/chat_target">.&#x2F;chat_target&#x2F;</a></p>
<p>以及一个可以模糊测试聊天客户端的示例解决方案。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/chat_solution/src/main.rs">.&#x2F;chat_solution&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Ping from    16937944: DDAAAATt&#x27;AAAAPt&#x27;%222%%%%%%%9999&#x27;pRR9&amp;&amp;%%%%%%2Tt&#123;&#x27;&#x27;pRt&#x27;%99999999&#x27;pRR9&amp;&amp;&amp;%%%%%%999AATt&#x27;%&amp;&#x27;pRt&#x27;%TTTTTTTTTTTTTT9999999&#x27;a%&#x27;AAATTt&#x27;% --</span><br><span class="line">-- Error sending message: Bad file descriptor --</span><br><span class="line">[Stats #0] run time: 0h-0m-5s, clients: 1, corpus: 531, objectives: 13, executions: 26752, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-5s, clients: 1, corpus: 532, objectives: 13, executions: 26760, exec/sec: 0.000</span><br><span class="line">-- Ping from    16937944: DDAAAATT&#x27;%&#x27;aRt&#x27;%9999&#x27;pRRT&#x27;%&#x27;LLLLLLLLLLLa%&#x27;nnnnnmnnnT&#x27;AA&#x27;&#x27;&#x27;</span><br><span class="line">A&#x27;&#x27;p%&#x27;&#x27;A9999&#x27;pRRT&#x27;pRR -- </span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个研讨会的目标是展示 LibAFL 的多功能性，并鼓励它的使用。希望这些示例能激发你一些关于如何将自定义模糊测试器整合到你的一些目标中的想法。如果你有任何问题或发现我们示例中的任何问题，请让我们知道。或者，如果你有一个有趣的目标，并希望我们为你找到漏洞，请与我们联系。</p>
<h2 id="课程推广"><a href="#课程推广" class="headerlink" title="课程推广"></a>课程推广</h2><p>再次感谢你的阅读！如果你喜欢这类内容，你可能会对我们的课程“Practical Symbolic Execution for VR and RE”感兴趣，你将学习如何为以下内容创建你自己的符号执行框架：逆向工程、去混淆、漏洞检测、漏洞开发等。下一次公开课程将在 2024 年 2 月作为 ringzer0 的 BOOTSTRAP24 的一部分。我们也可以根据要求提供私人课程。</p>
<p>更多信息在这里。<br><a href="https://ringzer0.training/trainings/practical-symbolic-execution.html">https://ringzer0.training/trainings/practical-symbolic-execution.html</a></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1566943528908-J56DPCZRQ9SVG4TFPP27/WhiskeyBirdTextOverlayWhite.png?format=1500w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1701794251926-ZA8KEPB15YFCJ0QRW122/johannes-weber-wcspluM_Iqw-unsplash.jpg?format=1000w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
        <category>翻译文章</category>
      </categories>
      <tags>
        <tag>LibAFL</tag>
      </tags>
  </entry>
</search>
