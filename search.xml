<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL 函数对象及Lambda.md</title>
    <url>/2023/10/08/C++/STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%8A%20Lambda/</url>
    <content><![CDATA[<p>函数对象，适配器，binder，lambda</p>
<span id="more"></span>
<h2 id="STL-函数对象及-Lambda"><a href="#STL-函数对象及-Lambda" class="headerlink" title="STL 函数对象及 Lambda"></a>STL 函数对象及 Lambda</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数对象 (function object) 等同于仿函数(functors) , 就是指定义了 operator() 的对象</p>
<h4 id="对比一下一般函数和函数对象："><a href="#对比一下一般函数和函数对象：" class="headerlink" title="对比一下一般函数和函数对象："></a>对比一下一般函数和函数对象：</h4><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(typename1 a, typename2 b, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// statements</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yourclassname</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(typename1 a, typename2 b, ...)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">// statements</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>可以拥有状态</li>
<li>可以作为模版参数传递给容器，从而指定某种行为</li>
<li>Function object 比 function pointer 快</li>
</ol>
<h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>我们说函数对象拥有状态，但是如果我们将一个函数对象传递给算法，算法处理过程中其实是拿着函数对象副本在操作，所以这个状态的改变发生在副本上，我们既没有办法获取也没有办法操作。如果想要从“运用了 function object“ 的算法中获取“结果”或者“反馈”，有三种方法：</p>
<ol>
<li>在外部持有状态，并让function object 指向他</li>
<li>用 by reference 的方式传递 function object</li>
<li>利用 for_each() 算法的返回值，利用 for_each 可以返回其操作的特性</li>
</ol>
<p><strong>predicate</strong> ： 判断式，就是返回 Boolean 值的函数或者 function object</p>
<h4 id="预定义的-function-object-和-Binder"><a href="#预定义的-function-object-和-Binder" class="headerlink" title="预定义的 function object 和 Binder"></a>预定义的 function object 和 Binder</h4><p><a href="https://blog.51cto.com/u_15346415/3674270">https://blog.51cto.com/u_15346415/3674270</a></p>
<p><a href="https://www.cnblogs.com/larry-xia/p/9496343.html">https://www.cnblogs.com/larry-xia/p/9496343.html</a></p>
<p><a href="https://blog.csdn.net/jingza/article/details/77772951">https://blog.csdn.net/jingza/article/details/77772951</a></p>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试常见八股</title>
    <url>/2023/12/10/C++/C++%20%E5%A4%9A%E6%80%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>c++ 多态机制的内存布局</p>
<span id="more"></span>

<h2 id="C-多态机制的内存管理"><a href="#C-多态机制的内存管理" class="headerlink" title="C++ 多态机制的内存管理"></a>C++ 多态机制的内存管理</h2><h4 id="一个-C-类的四种成员："><a href="#一个-C-类的四种成员：" class="headerlink" title="一个 C++ 类的四种成员："></a>一个 C++ 类的四种成员：</h4><ul>
<li>非静态成员变量：属于类，参与继承。</li>
<li>静态成员变量：位于全局变量区域，不参与继承，属于类而不属于任何实例。必须类内声明，类外定义。</li>
<li>静态成员函数：</li>
<li>非静态成员函数：</li>
</ul>
<h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><ul>
<li>虚函数表指针放在最前</li>
<li>成员变量依据继承和声明顺序放在后面</li>
<li>被重写的虚函数在虚函数表中进行更新</li>
</ul>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><ul>
<li>父类按照继承顺序依次排列，每个父类有自己的虚表。</li>
<li>子类的新定义虚函数被放到了第一个父类的表中。</li>
<li>子类重写的虚函数会在对应的父类虚函数表中更新。</li>
</ul>
<p>出现钻石继承的虚继承的时候，虚基类在子类中只有一份。<br>出现钻石继承的非虚继承的时候，虚基类在每个子类中都有一份。</p>
<p>只讲虚函数的处理，简单明了：<a href="https://zhuanlan.zhihu.com/p/611317234">https://zhuanlan.zhihu.com/p/611317234</a></p>
<p>画图讲解虚表，最佳：<a href="https://www.cnblogs.com/QG-whz/p/4909359.html">https://www.cnblogs.com/QG-whz/p/4909359.html</a></p>
<p>稍微简化点的讲解：<a href="https://www.jianshu.com/p/31373b52902d">https://www.jianshu.com/p/31373b52902d</a></p>
<p>反汇编网站：<a href="https://gcc.godbolt.org/">https://gcc.godbolt.org/</a></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm</title>
    <url>/2023/10/09/C++/algorithm/</url>
    <content><![CDATA[<p>STL 中的算法</p>
<span id="more"></span>

<ul>
<li><p>非更易算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  for_each(b,e,uop)	<span class="comment">// 单元素访问，处理，修改，be指示范围，op可以是 函数/lambda/function object</span></span><br><span class="line">  <span class="built_in">count</span>(b,e,val)	<span class="comment">// 统计满足某种条件元素个数</span></span><br><span class="line">  <span class="built_in">count_if</span>(b,e,uop)</span><br><span class="line">  <span class="built_in">min_element</span>(b,e,(cmp))	<span class="comment">// 返回首个最小值位置迭代器 *访问元素 different 计算距离</span></span><br><span class="line">  <span class="built_in">max_element</span>()</span><br><span class="line">  <span class="built_in">minmax_element</span>()	<span class="comment">// 返回最后一个最大最小值的迭代器位置</span></span><br><span class="line">  <span class="built_in">find</span>(b,e,val)	<span class="comment">// 返回第一个符合的位置的迭代器，如果要第二个，需要以此为起点进行第二次find</span></span><br><span class="line">  <span class="built_in">find_if</span>(b,e,uop)</span><br><span class="line">  <span class="built_in">find_if_not</span>()</span><br><span class="line">  <span class="built_in">search_n</span>(b,e,c,val/bop)	<span class="comment">// 返回连续c个满足条件的元素区间的起点，注意这里虽然实际只使用uop，但模版参数是bop，所以要设置一个闲置变量以便于签名检查可以通过</span></span><br><span class="line">  <span class="built_in">search</span>(b,e,sb,se,(bop))		<span class="comment">// 返回第一个子区间起点</span></span><br><span class="line">  <span class="built_in">find_end</span>(b,e,sb,se,(bop))		<span class="comment">// 返回最后一个子区间起点</span></span><br><span class="line">  <span class="built_in">find_first_of</span>(b,e,sb,se,(bop))	<span class="comment">// 某元素第一次出现的位置，用反向迭代器则是最后一次出现的位置</span></span><br><span class="line">  <span class="built_in">adjacent_find</span>(b,e,(bop))	<span class="comment">// 返回连续两个满足关系对的元素起点</span></span><br><span class="line">  <span class="built_in">equal</span>(b,e,cmpb,(bop))	<span class="comment">// 区间比较，不等可以用 mismatch() 找失配位置</span></span><br><span class="line">  <span class="built_in">is_permutation</span>(b,e,b2,(cmp))	<span class="comment">// 是否是排列</span></span><br><span class="line">  <span class="built_in">mismatch</span>(b,e,b2,(bp))	<span class="comment">// 失配位置，返回pair</span></span><br><span class="line">  <span class="built_in">is_sorted</span>(b,e,(bp))	<span class="comment">// 检验是否有序</span></span><br><span class="line">  <span class="built_in">is_sorted_until</span>()</span><br><span class="line">  <span class="built_in">is_partitioned</span>(b,e,up)	<span class="comment">// 是否二段</span></span><br><span class="line">  <span class="built_in">partition_point</span>(),</span><br><span class="line">  <span class="built_in">is_heap</span>(b,e,bp)</span><br><span class="line">  <span class="built_in">is_heap_until</span>()</span><br><span class="line">  <span class="built_in">all_of</span>(b,e,up)	<span class="comment">// 所有都 任何 都不, up 一定要有</span></span><br><span class="line">  <span class="built_in">any_of</span>()</span><br><span class="line">  <span class="built_in">none_of</span>(b,e,up)</span><br><span class="line"></span><br><span class="line">- 更易算法</span><br><span class="line"></span><br><span class="line">  更易算法统一返回被更易容器下一个可操作位置</span><br><span class="line"></span><br><span class="line">  更易算法不可作用于关联式容器(map,set), 无序容器(unordered) 的 key 键值</span><br><span class="line"></span><br><span class="line">  ```<span class="function">cpp</span></span><br><span class="line"><span class="function">  <span class="title">for_each</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">copy</span><span class="params">(sb,se,db)</span>	<span class="comment">// 以下四个都返回目标区间最后一个将要被覆盖的位置</span></span></span><br><span class="line"><span class="function">  <span class="title">copy_if</span><span class="params">(sb,se,db,up)</span></span></span><br><span class="line"><span class="function">  <span class="title">copy_n</span><span class="params">(sb,n,db)</span></span></span><br><span class="line"><span class="function">  <span class="title">copy_backward</span><span class="params">(sb,se,de)</span></span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(sb,se,db)</span>	<span class="comment">// 搬移元素，注意原数据失效</span></span></span><br><span class="line"><span class="function">  <span class="title">move_backward</span><span class="params">(sb,se,se)</span></span></span><br><span class="line"><span class="function">  <span class="title">transform</span><span class="params">(sb,se,db,uop)</span>	<span class="comment">// 转换元素（一源，二源）</span></span></span><br><span class="line"><span class="function">  <span class="title">transform</span><span class="params">(b1,e1,b2,db,bop)</span></span></span><br><span class="line"><span class="function">  <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="title">swap_range</span><span class="params">(b1,e1,b2)</span>	<span class="comment">// 互换元素，使用反向迭代器并作用在同一个容器，回</span></span></span><br><span class="line"><span class="function">  <span class="title">fill</span><span class="params">(b,e,val)</span>	<span class="comment">// 下面5个为填充元素，当容器为空，调用这些算法要用 插入迭代器</span></span></span><br><span class="line"><span class="function">  <span class="title">fill_n</span><span class="params">(b,n,val)</span></span></span><br><span class="line"><span class="function">  <span class="title">generate</span><span class="params">(b,e,op)</span></span></span><br><span class="line"><span class="function">  <span class="title">generate_n</span><span class="params">(b,n,op)</span></span></span><br><span class="line"><span class="function">  <span class="title">itoa</span><span class="params">(b,e,startVal)</span></span></span><br><span class="line"><span class="function">  <span class="title">replace</span><span class="params">(b,e,oldVal,newVal)</span>	<span class="comment">// 	区间值替换</span></span></span><br><span class="line"><span class="function">  <span class="title">replace_if</span><span class="params">(b,e,up,newVal)</span></span></span><br><span class="line"><span class="function">  <span class="title">replace_copy</span><span class="params">(sb,se,db,oldVal,newVal)</span></span></span><br><span class="line"><span class="function">  <span class="title">replace_copy_if</span><span class="params">(sb,se,db,up,newVal)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>移除型算法</p>
<p>覆盖式移除，返回逻辑新终点，移除完成后要使用返回值作为新的容器终点，最好用 erase 操作一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">remove</span>(b,e,val)	<span class="comment">// 移除元素</span></span><br><span class="line"><span class="built_in">remove_if</span>(b,e,up)</span><br><span class="line"><span class="built_in">remove_copy</span>(sb,se,db,val)</span><br><span class="line"><span class="built_in">remove_copy_if</span>(sb,se,db,up)</span><br><span class="line"><span class="built_in">unique</span>(b,e,(bp))	<span class="comment">// 移除相邻重复，如果想要唯一化要先排序</span></span><br><span class="line"><span class="built_in">unique_copy</span>(sb,se,db,bp)</span><br></pre></td></tr></table></figure>
</li>
<li><p>变序型算法</p>
<p>不适合关联式容器和无序容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(b,e)</span><br><span class="line"><span class="built_in">reverse_copy</span>(sb,se,db)</span><br><span class="line"><span class="built_in">rotate</span>(b,newb,e)</span><br><span class="line"><span class="built_in">rotate_copy</span>(b,newb,e,db)</span><br><span class="line"><span class="built_in">next_permutation</span>(b,e,(bp))	<span class="comment">// bp 给出判断两个元素大小的方法，函数按字典序排列返回 false，其余返回 true</span></span><br><span class="line"><span class="built_in">prev_permutation</span>(b,e,(bp))</span><br><span class="line"><span class="built_in">shuffle</span>(b,e,UniformRandomGenerator&amp;&amp; eng) <span class="comment">// 返回 void</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(b,e,(op))</span><br><span class="line"><span class="built_in">partition</span>(b,e,up)	<span class="comment">// 前 true 后 false 格局，返回第一个 false 位置</span></span><br><span class="line"><span class="built_in">stable_partition</span>(b,e,up)</span><br><span class="line"><span class="built_in">partition_copy</span>(sb,se,db1,db2,up)	<span class="comment">// 一分为二 back_inserter 返回两个分裂容器的最后位置 pair</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序算法</p>
<p>需要能提供 random-access interator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(b,e,(bp))</span><br><span class="line"><span class="built_in">stable_sort</span>(b,e,(bp))</span><br><span class="line"><span class="built_in">partial_sort</span>(b,sortEnd,e,(bp))</span><br><span class="line"><span class="built_in">partial_sort_copy</span>(sb,se,db,de,(bp))</span><br><span class="line"><span class="built_in">nth_element</span>(b,n,e,(bp))		<span class="comment">// 保证了 begin 到 begin + n 这(n+1)个元素是全局最小或最大</span></span><br><span class="line"><span class="built_in">partition</span>()</span><br><span class="line"><span class="built_in">stable_partition</span>()</span><br><span class="line"><span class="built_in">partition_copy</span>()</span><br><span class="line"><span class="built_in">make_heap</span>(b,e,(bp))	<span class="comment">// 算法复杂度 3n</span></span><br><span class="line"><span class="built_in">push_heap</span>(b,e,(bp))	<span class="comment">// 加在末尾，然后上滤，logn</span></span><br><span class="line"><span class="built_in">pop_heap</span>(b,e,(bp))	<span class="comment">//	首位互换，然后下滤，2logn</span></span><br><span class="line"><span class="built_in">sort_heap</span>(b,e,(bp))	<span class="comment">//	特异性算法，确保区间已经是heap，nlogn</span></span><br><span class="line">  <span class="comment">// 检测就序状态</span></span><br><span class="line"><span class="built_in">is_sorted</span>()</span><br><span class="line"><span class="built_in">is_sorted_until</span>()</span><br><span class="line"><span class="built_in">is_partitioned</span>()</span><br><span class="line"><span class="built_in">partition_point</span>()</span><br><span class="line"><span class="built_in">is_heap</span>()</span><br><span class="line"><span class="built_in">is_heap_until</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>已排序区间算法</p>
<p>通常是对数复杂度，对于没有 random-access iterator 的容器，复杂度线性，但比较次数为对数级，对于关联式容器和无序容器，如果其有特异性同名接口，应该考虑使用其特异性接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(b,e,val,(bp))	<span class="comment">// 返回 bool，代表是否存在</span></span><br><span class="line"><span class="built_in">includes</span>(b,e,searchb,searche,(bp))	<span class="comment">// 两个已排序区间的元素包含关系，不是连续子序列</span></span><br><span class="line"><span class="built_in">lower_bound</span>(b,e,val,(bp))	<span class="comment">// 至多 logn + 1</span></span><br><span class="line"><span class="built_in">upper_bound</span>(b,e,val,(bp))</span><br><span class="line"><span class="built_in">eauql_range</span>(b,e,val,(bp))	<span class="comment">// 至多 2logn + 1</span></span><br><span class="line"><span class="built_in">merge</span>(s1b,s1e,s2b,s2e,ds,(bp))	<span class="comment">// 至多 n1 + n2 - 1</span></span><br><span class="line"><span class="built_in">set_union</span>(s1b,s1e,s2b,s2e,db,(bp))	<span class="comment">//	要求合并前两集和有序 并集</span></span><br><span class="line"><span class="built_in">set_intersection</span>(s1b,s1e,s2b,s2e,db,(bp))	<span class="comment">// 交集</span></span><br><span class="line"><span class="built_in">set_difference</span>(s1b,s1e,s2b,s2e,db,(bp))	<span class="comment">// 在 1 中不在 2 中， 差集</span></span><br><span class="line"><span class="built_in">set_symmetric_difference</span>(s1b,s1e,s2b,s2e,db,(bp))	<span class="comment">// 在 1 或在 2，但不同时在 12，并集减去交集 </span></span><br><span class="line"><span class="built_in">inplace_merge</span>(<span class="number">1</span>b,<span class="number">1e2</span>b,<span class="number">2</span>e,(bp))	<span class="comment">// 把原本二分有序的区间合并成全局有序</span></span><br><span class="line"><span class="built_in">partition_point</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>数值算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(b,e,initVal,(bop))	<span class="comment">// 规约</span></span><br><span class="line"><span class="built_in">inner_product</span>(<span class="number">1</span>b,<span class="number">1</span>e,<span class="number">2</span>b,initVal,(outbop),(innerbop))	<span class="comment">// 内积</span></span><br><span class="line"><span class="built_in">adjacent_difference</span>(sb,se,db,(bop))	<span class="comment">// 差分，这两个都是可以原地进行</span></span><br><span class="line"><span class="built_in">partial_sum</span>(sb,se,db,(bop))	<span class="comment">// 前缀和</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>迭代器：</p>
<p>随机访问迭代器可以进行算数 + - ，也可以用 &lt; 做比较</p>
<p>但是普通迭代器则只能 ++ 步进</p>
<p>函数简称说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uop bop <span class="comment">// 单参，双参函数</span></span><br><span class="line">up bp <span class="comment">// 单参，双参判断</span></span><br><span class="line">cmp	<span class="comment">// 比较</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>apue 学习记录</title>
    <url>/2024/06/19/linux/apue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>apue 学习记录</p>
<span id="more"></span>

<ul>
<li><p>环境搭建：<a href="https://zhuanlan.zhihu.com/p/580675705">https://zhuanlan.zhihu.com/p/580675705</a></p>
</li>
<li><p>文件描述符和inode关系：<a href="https://blog.csdn.net/ambitiousssssss/article/details/124001467%EF%BC%8Chttps://blog.csdn.net/weixin_43864567/article/details/124063198">https://blog.csdn.net/ambitiousssssss/article/details/124001467，https://blog.csdn.net/weixin_43864567/article/details/124063198</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/kcloveworld/p/17989014">文件描述符、文件描述符表、文件表项、inode名词释义</a><br><a href="https://blog.csdn.net/kyang_823/article/details/79496362">https://blog.csdn.net/kyang_823/article/details/79496362</a></p>
</li>
<li><p>&#x2F;proc文件系统：<a href="https://blog.51cto.com/u_15127514/4196632">https://blog.51cto.com/u_15127514/4196632</a></p>
</li>
<li><p>虚拟文件系统VFS原理：<a href="https://blog.51cto.com/mingongge/2945174">https://blog.51cto.com/mingongge/2945174</a></p>
</li>
<li><p>重要头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">这个头文件包含了POSIX标准中定义的一些常用函数和类型，比如fork()、exec()系列函数，以及pid_t类型等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">这个头文件包含了系统调用的编号，比如SYS_gettid和SYS_tgkill等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">这个头文件定义了一些基本的数据类型，比如pid_t、size_t等。</span><br><span class="line"></span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">这个头文件包含了信号相关的函数和类型，比如SIGHUP信号常量。</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/perf/include/bpf/unistd.h</span><br><span class="line">./tools/arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./tools/include/nolibc/unistd.h</span><br><span class="line">./tools/include/uapi/asm-generic/unistd.h</span><br><span class="line">./arch/alpha/include/asm/unistd.h</span><br><span class="line">./arch/alpha/include/uapi/asm/unistd.h</span><br><span class="line">./arch/ia64/include/asm/unistd.h</span><br><span class="line">./arch/ia64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm64/include/asm/unistd.h</span><br><span class="line">./arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sparc/include/asm/unistd.h</span><br><span class="line">./arch/sparc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/uapi/asm/unistd.h</span><br><span class="line">./arch/parisc/include/asm/unistd.h</span><br><span class="line">./arch/parisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/riscv/include/asm/unistd.h</span><br><span class="line">./arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./arch/s390/include/asm/unistd.h</span><br><span class="line">./arch/s390/include/uapi/asm/unistd.h</span><br><span class="line">./arch/nios2/include/uapi/asm/unistd.h</span><br><span class="line">./arch/x86/include/asm/unistd.h</span><br><span class="line">./arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sh/include/asm/unistd.h</span><br><span class="line">./arch/sh/include/uapi/asm/unistd.h</span><br><span class="line">./arch/m68k/include/asm/unistd.h</span><br><span class="line">./arch/m68k/include/uapi/asm/unistd.h</span><br><span class="line">./arch/csky/include/asm/unistd.h</span><br><span class="line">./arch/csky/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm/include/asm/unistd.h</span><br><span class="line">./arch/arm/include/uapi/asm/unistd.h</span><br><span class="line">./arch/openrisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/mips/include/asm/unistd.h</span><br><span class="line">./arch/mips/include/uapi/asm/unistd.h</span><br><span class="line">./include/uapi/asm-generic/unistd.h</span><br><span class="line">./include/uapi/linux/unistd.h</span><br><span class="line">arch/mips/include/asm/unistd.h 通常包含了特定于MIPS架构的系统调用号码定义，这些定义是基于MIPS架构的特点定制的。</span><br><span class="line">arch/mips/include/uapi/asm/unistd.h 则包含了用户空间API的系统调用号码定义，这些定义是为了让用户空间程序能够安全地调用内核提供的服务。</span><br><span class="line">简单来说，uapi目录下的头文件通常用于定义用户空间可以使用的接口，而非特定于某个架构的内部细节。这样做的好处是，用户空间程序不必关心底层的硬件架构，只需通过统一的接口与内核通信。而asm目录下的头文件则包含了特定于某一架构的实现细节，这些细节对于用户空间程序是透明的，但对于内核开发者来说非常重要，因为它们涉及到如何在特定的硬件上实现系统调用.</span><br></pre></td></tr></table></figure>

<p>学习 apue 的目的是什么？<br>1.明白 linux 系统级知识，为读 AFL 源码做准备。<br>2.进而熟悉 linux 内核源码，可以对内核进行调试，修改。<br>目前好的 apue 学习素材：<br>1.b站李慧琴的课，相关笔记<a href="https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8">https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8</a><br>2.apue 书本<br>目前对 apue 的理解以及所能预料到的掌握后的能力：<br>1.熟悉了 linux 平台 进程 文件 信号机制 的原理，接口<br>2.能够在此基础之上进行应用程序开发</p>
<p>对于使用 afl 本身来说，了解平台机制就可以了，想要研究 afl 更重要的就是要对 afl 的原理进行更深入的研究。<br>以上都为计算机的术的话，计算机学习的道应该是什么？</p>
<p>6月20号：<br>1.昨天开始读 AFL 源码，主要是看 makefile ,问题是 makefile 语法还是不太熟悉，又转去看手册。makefile 里有 shell 命令，于是看 bash 手册<br>2.makefile bash 两个手册可以粗略看一下，花费一个半小时，然后开始看 AFL 源码</p>
<p>type command  查看命令类型</p>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>STL详细梳理</title>
    <url>/2024/09/05/C++/STL%E8%AF%A6%E7%BB%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="STL-container"><a href="#STL-container" class="headerlink" title="STL-container"></a>STL-container</h1><span id="more"></span>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,5&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>,5&gt; <span class="title">c</span><span class="params">(c2)</span></span>;		<span class="comment">// 必须类型大小都一样</span></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = c2;</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = initlist</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="built_in">c</span>(rv);</span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = rv;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Int 可以扩充为：</p>
<ol>
<li>float bool ull struct class string 等基础类型</li>
<li>vector array deque list forward_list set map 等容器</li>
</ol>
</blockquote>
<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();</span><br><span class="line">c1 == c2		<span class="comment">// 只有类型大小相同才有比较的资格,数据全相同才为 true</span></span><br><span class="line">c1 != c2</span><br><span class="line">c1 &lt; c2			<span class="comment">// 字典序比较</span></span><br></pre></td></tr></table></figure>

<p>  赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">fill</span>(val)</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2)	<span class="comment">// 置换c1和c2</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2)	<span class="comment">// 类型大小相同才可以swap</span></span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);</span><br><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.back;</span><br></pre></td></tr></table></figure>

<p>八大迭代器：</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; c </span>= c2;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;			<span class="comment">// 开一个 size 为 n 的 vector，使用默认构造填充每个元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,val)</span></span>;	<span class="comment">// 以 n 个 val 填充 c</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c<span class="number">2.</span>beg,c<span class="number">2.</span>end)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">capacity</span>();</span><br><span class="line">c.<span class="built_in">reserve</span>(num);		<span class="comment">// 针对 c 的 capacity 属性</span></span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>()	<span class="comment">// 针对 c 的 capacity 属性,执行后不一定 c.size() == c.capacity()</span></span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();	<span class="comment">// 数组起始位置</span></span><br><span class="line">== != &lt; &gt; &lt;= &gt;= 	<span class="comment">// 六种比较全支持，先比 size，再按字符串比较方法比元素</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有赋值都是将新元素赋值给 vector 并将旧元素删除</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);	<span class="comment">// 二者管理的内容（data,size,cap）交换，相当于二者交换名字，也相当于相互借壳上市</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);	<span class="comment">// 四个中只有 at 具有安全性检查，其余访问前要手动保证位置可访问</span></span><br><span class="line">c.<span class="built_in">front</span>();	</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">beg，end，cbeg，cend，rbeg，rend，crbeg，crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();	<span class="comment">// 程序员手动保证容器不空</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);	<span class="comment">// pos 之前插入 elem， 并返回新元素位置</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos, initlist);</span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...)	<span class="comment">// 在 pos 之前插入以 arg 为初值的元素,返回第一个新元素位置</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...)	<span class="comment">// 末尾插入以 arg 为初值的元素，无返回值</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);	<span class="comment">// 删除 [beg end) 区间内元素</span></span><br><span class="line">c.<span class="built_in">clear</span>();	<span class="comment">// 清空</span></span><br><span class="line">c.<span class="built_in">resize</span>(num);	<span class="comment">// 如果 size 变大，多出来的元素用默认构造填充</span></span><br><span class="line">c.<span class="built_in">resize</span>(num,elem);	<span class="comment">// 如果 size 变大，多出来的用 elem 拷贝填充</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove</span>(beg,end,val)	<span class="comment">// 	实质是把非 val 元素前移，size 并未改变</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有了 insert， vector 不局限于在尾部增加元素，可以在任意位置添加任意个数的元素，但是可以是一回事，并不擅长，因为复杂度原因。</li>
<li>insert emplace 的所有 pos，都需要是迭代器，而不能是 int 值（这很好理解，迭代器要么是pointer，要么是类，无论哪种都不是一个 int 可以替代的）</li>
<li>pos 的值可以由算法计算出，结合 insert 可以实现很多功能：<ol>
<li>vector 没有提供删除指定值功能，但是可以搭配算法实现这个功能：c.erase(remove(c.begin(),c.end(),val),c.end());</li>
<li>在 val1 前插入val2 c.insert(find(c.begin(),c.end(),val1),val2)</li>
</ol>
</li>
<li>删除第一个值为 val 的元素：auto pos &#x3D; find(c.begin(),c.end(),val); if(pos !&#x3D; c.end()) v.erase(pos);</li>
</ol>
</blockquote>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><blockquote>
<p>几乎和 vector 一模一样，除了</p>
<ol>
<li>不支持容量操作，reserve(), capcity()</li>
<li>安插和移除可以在头部进行</li>
</ol>
</blockquote>
<p>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dequeue&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(deg,end)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有接口都是整体赋值，所以大多数情况适用于算法开始前初始化</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem); </span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);	<span class="comment">// 交换内容</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.at(idx);</span><br><span class="line">c.front();</span><br><span class="line">c.back();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beg,end,cbeg,cend,rbeg,rend,crbeg,crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">c.<span class="built_in">resize</span>(n,num);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 原地构建一个 string 类</span></span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &lt; &gt; &lt;= &gt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b,e,cb,ce,rb,re,crb,cre</span><br><span class="line"><span class="comment">// 经过实验，list 的迭代器支持了 ++ -- 操作，但是不支持直接 + - 操作(包括加减 int， 以及迭代器之间加减)，意味着 list 的诸如 c.insert(pos,elem); 中 pos 的定位只能从 front 或者 end 航行过去，想来也是合理</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>();</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>();</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的 remove 总是好于算法中提供的 remove</span></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op); <span class="comment">// c.remove([](int i)&#123; return i % 2 == 0;&#125;); 删除偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulate(beg,end,0);</span></span><br><span class="line"><span class="comment">// transform(a.beg,a.end,b.beg,negate&lt;int&gt;());</span></span><br></pre></td></tr></table></figure>

<p>List 特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();		<span class="comment">// 相邻而数值相同留一个,所以要想实现真正的单一化，要先排序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2);	<span class="comment">// 整个 c2 放在 pos 之前</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2pos)	<span class="comment">// c2 的 c2pos 位置元素放在 c 的 pos 位置，c和c2可以相同</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2beg,c2end)	<span class="comment">// c2 的 [c2beg,c2end) 区间元素放在 pos 位置，c和c2可以相同</span></span><br><span class="line"> </span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前题是 c 和 c2 均有序</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>

<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br><span class="line">  <span class="comment">// 没有 size，可行的方案是 distance(c.begin(),c.end())</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">assign</span>(n.elem);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">四个正向迭代器：b,e,cb,ce</span><br><span class="line">额外两个： <span class="built_in">before_begin</span>(),<span class="built_in">before_end</span>(); <span class="comment">// 不要试图解引用这两个迭代器，仅限于后缀为 after 的借口使用</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace_after</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase_after</span>(pos);</span><br><span class="line">c.<span class="built_in">erase_after</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br></pre></td></tr></table></figure>

<p>list特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();	<span class="comment">// 前提是有序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2pos);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2beg,c2end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前提是有序，c2 归入 c</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op);</span><br><span class="line">c.<span class="built_in">reverse</span>();</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;	<span class="comment">// set&lt;int,greater&lt;int&gt;&gt; coll;</span></span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = rv;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;	<span class="comment">// 可接受不同类型容器元素</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = initlist;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">不支持随机，通常使用 range-base <span class="keyword">for</span> 或 迭代器</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器(关联式容器都是)</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>();</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>set 特殊查找函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val);</span><br><span class="line">c.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">lower_bound</span>(val);</span><br><span class="line">c.<span class="built_in">upper_bound</span>(val);</span><br><span class="line">c.<span class="built_in">equal_bound</span>(val);</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = initlist;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = <span class="built_in">c</span>(c2);</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key];</span><br><span class="line">c.<span class="built_in">at</span>(key);</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(key);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 	由于元素是 key/val pair 因此元素插入略显复杂</span></span><br><span class="line">	c.<span class="built_in">insert</span>(&#123;<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	c.<span class="built_in">insert</span>(map&lt;string,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>))</span><br><span class="line">  c.<span class="built_in">insert</span>(<span class="keyword">decltype</span>(c)::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each(beg,end,op)</span></span><br><span class="line"><span class="comment">// find_if(beg,end,op)</span></span><br></pre></td></tr></table></figure>

<p>map特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(key)</span><br><span class="line">c.<span class="built_in">find</span>(key)</span><br><span class="line">c.<span class="built_in">lower_bound</span>(key)</span><br><span class="line">c.<span class="built_in">upper_bound</span>(key)</span><br><span class="line">c.<span class="built_in">equal_bound</span>(key)</span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Unord c;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">Unord c = initlist;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">Unord c = rv;</span><br></pre></td></tr></table></figure>

<p>布局操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">hash_function</span>();</span><br><span class="line">c.<span class="built_in">key_eq</span>();</span><br><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>(val);</span><br><span class="line">c.<span class="built_in">rehash</span>(bnum);</span><br><span class="line">c.<span class="built_in">reserve</span>(bnum);</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">c1 == c2;</span><br><span class="line">c1 != c2;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key]</span><br><span class="line">c.<span class="built_in">at</span>(key)</span><br></pre></td></tr></table></figure>

<p>迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器，但是只支持 forward interator，不支持 bidirection interator 或 random-access interator</span><br></pre></td></tr></table></figure>

<p>安插和移除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);		<span class="comment">// 移除所有 与val相等 的元素，返回移除个数</span></span><br><span class="line">c.<span class="built_in">erase</span>(pos);		<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">erase</span>(beg,end)<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>无序容器特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val)</span><br><span class="line">c.<span class="built_in">find</span>(val)	<span class="comment">// 若想指定 pred 只能用 find_if()</span></span><br><span class="line">c.<span class="built_in">equal_bound</span>(val)</span><br></pre></td></tr></table></figure>

<p>bucket 接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">bucket</span>();</span><br><span class="line">c.<span class="built_in">bucket_size</span>();</span><br><span class="line">c.<span class="built_in">begin</span>(buckidx);</span><br><span class="line">c.<span class="built_in">end</span>(buckidx);</span><br><span class="line">c.<span class="built_in">cbegin</span>(bucketidx);</span><br><span class="line">c.<span class="built_in">cend</span>(bucketidx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform()</span></span><br></pre></td></tr></table></figure>

<p>STL延伸</p>
<ul>
<li>以上介绍皆为标准容器，可以利用容器思想扩充类，一般有以下扩充方向<ul>
<li>Intrusive, 侵入式。直接提供STL所需接口，如begin，end。典型的如 string 类</li>
<li>nonintrusive，非侵入式。提供特殊迭代器，作为算法和容器接口。如 array 中，begin(val) 获得其迭代器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统数据结构</title>
    <url>/2024/09/05/linux/linux%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>linux 系统中常见的数据结构</p>
<span id="more"></span>

<h1 id="struct-itimerval"><a href="#struct-itimerval" class="headerlink" title="struct itimerval"></a>struct itimerval</h1><p><code>struct itimerval</code>是一个用于设置定时器的结构体。它包含了两个成员变量，分别是<code>it_interval</code>和<code>it_value</code>。</p>
<p><code>it_interval</code>用于设置定时器的间隔时间，即每隔多少时间触发一次定时器。<code>it_value</code>用于设置定时器的初始值，即第一次触发定时器的时间。</p>
<p>这个结构体可以在C语言中使用，用于设置定时器以及处理定时器信号。例如，可以使用<code>setitimer()</code>函数来设置定时器并启动定时器信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="type">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">and gives the number of seconds and microseconds since the <span class="title function_">Epoch</span> <span class="params">(see time(<span class="number">2</span>))</span>.</span><br><span class="line"></span><br><span class="line">The tz argument is a <span class="keyword">struct</span> timezone:</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timezone &#123;</span><br><span class="line">	<span class="type">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">	<span class="type">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br><span class="line">Describes times in seconds and nanoseconds.</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>  tv_sec;  <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>    tv_nsec; <span class="comment">/* Nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="文件系统-stat"><a href="#文件系统-stat" class="headerlink" title="文件系统 stat"></a>文件系统 stat</h1><ul>
<li>在<code>E:\Ubuntushare\linux-6.0\arch\x86\include\uapi\asm\stat.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ino;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_nlink;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_rdev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blksize;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused4;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> S_ISREG(m)  is it a regular file?</p>
<pre><code>       S_ISDIR(m)  directory?

       S_ISCHR(m)  character device?

       S_ISBLK(m)  block device?

       S_ISFIFO(m) FIFO (named pipe)?

       S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)

       S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
</code></pre>
<p>成员变量的含义：</p>
<ul>
<li>st_dev：文件所在设备的设备号</li>
<li>st_ino：文件的i-node号</li>
<li>st_mode：文件的类型和访问权限</li>
<li>st_nlink：文件的硬链接数</li>
<li>st_uid：文件的所有者的用户ID</li>
<li>st_gid：文件的所有者的组ID</li>
<li>st_rdev：如果文件是设备文件，则该成员保存了设备的设备号</li>
<li>st_size：文件的大小（以字节为单位）</li>
<li>st_blksize：文件系统I&#x2F;O操作的最佳块大小</li>
<li>st_blocks：文件所占用的磁盘块数</li>
<li>st_atime：文件的最后访问时间</li>
<li>st_atime_nsec：文件的最后访问时间的纳秒部分</li>
<li>st_mtime：文件的最后修改时间</li>
<li>st_mtime_nsec：文件的最后修改时间的纳秒部分</li>
<li>st_ctime：文件的最后状态改变时间</li>
<li>st_ctime_nsec：文件的最后状态改变时间的纳秒部分</li>
<li>__unused4和__unused5：未使用的保留字段</li>
</ul>
<p>这个结构体是用于在C语言中对文件的状态进行描述和操作的一个重要数据结构。在C语言中，可以使用stat()函数来获取一个文件的状态，然后通过访问结构体的成员变量来获取文件的各种属性。</p>
<ul>
<li><p>本地化数据格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lconv</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Numeric (nonmonetary) information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *decimal_point;     <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *thousands_sep;     <span class="comment">/* Separator for digit groups to left</span></span><br><span class="line"><span class="comment">								of radix character */</span></span><br><span class="line">	<span class="type">char</span> *grouping;     <span class="comment">/* Each element is the number of digits in</span></span><br><span class="line"><span class="comment">							a group; elements with higher indices</span></span><br><span class="line"><span class="comment">							are further left.  An element with value</span></span><br><span class="line"><span class="comment">							CHAR_MAX means that no further grouping</span></span><br><span class="line"><span class="comment">							is done.  An element with value 0 means</span></span><br><span class="line"><span class="comment">							that the previous element is used for</span></span><br><span class="line"><span class="comment">							all groups further left. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remaining fields are for monetary information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *int_curr_symbol;   <span class="comment">/* First three chars are a currency</span></span><br><span class="line"><span class="comment">								symbol from ISO 4217.  Fourth char</span></span><br><span class="line"><span class="comment">								is the separator.  Fifth char</span></span><br><span class="line"><span class="comment">								is &#x27;\0&#x27;. */</span></span><br><span class="line">	<span class="type">char</span> *currency_symbol;   <span class="comment">/* Local currency symbol */</span></span><br><span class="line">	<span class="type">char</span> *mon_decimal_point; <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *mon_thousands_sep; <span class="comment">/* Like thousands_sep above */</span></span><br><span class="line">	<span class="type">char</span> *mon_grouping;      <span class="comment">/* Like grouping above */</span></span><br><span class="line">	<span class="type">char</span> *positive_sign;     <span class="comment">/* Sign for positive values */</span></span><br><span class="line">	<span class="type">char</span> *negative_sign;     <span class="comment">/* Sign for negative values */</span></span><br><span class="line">	<span class="type">char</span>  int_frac_digits;   <span class="comment">/* International fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  frac_digits;       <span class="comment">/* Local fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  p_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								positive value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  p_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a positive</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="type">char</span>  n_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								negative value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  n_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a negative</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="comment">/* Positive and negative sign positions:</span></span><br><span class="line"><span class="comment">		0 Parentheses surround the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		1 The sign string precedes the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		2 The sign string succeeds the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		3 The sign string immediately precedes the currency_symbol.</span></span><br><span class="line"><span class="comment">		4 The sign string immediately succeeds the currency_symbol. */</span></span><br><span class="line">	<span class="type">char</span>  p_sign_posn;</span><br><span class="line">	<span class="type">char</span>  n_sign_posn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>密码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">	<span class="type">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">	<span class="type">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">	<span class="type">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">	<span class="type">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">	<span class="type">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">	<span class="type">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">	<span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Creation time/time of last</span></span><br><span class="line"><span class="comment">									modification via shmctl() */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span> <span class="comment">//不关注最后一次detach的进程ID</span></span><br><span class="line">	<span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中的 ipc_perm 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">	<span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">	<span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">	<span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">	<span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">	<span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">								SHM_LOCKED flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源限制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>big_three那些事</title>
    <url>/2023/12/10/C++/big_three%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>默认构造，默认拷贝，默认赋值</p>
<span id="more"></span>

<h4 id="此篇文章提出两种常见的错误观念："><a href="#此篇文章提出两种常见的错误观念：" class="headerlink" title="此篇文章提出两种常见的错误观念："></a><a href="https://www.cnblogs.com/QG-whz/p/4676481.html">此篇文章</a>提出两种常见的错误观念：</h4><ul>
<li>任何类如果没有定义构造函数，则编译器会帮我们合成一个默认构造函数。</li>
<li>合成默认构造函数会对类中的每一个数据成员进行初始化</li>
</ul>
<p>指出正确的观念：</p>
<p>只有在编译器需要默认构造函数来完成编译任务的时候，编译器才会为没有任何构造函数的类合成一个默认构造函数，或者是把这些操作插入到已有的构造函数中去。具体是：</p>
<ul>
<li>作为子类其父类含有虚函数，此时编译器一定会介入安放虚表</li>
<li>虚继承同理，要安放虚基类指针</li>
<li>内部含有另一个类，且这个类有默认构造，至少要有一个默认构造调内含类的构造函数</li>
<li>继承自一个类，这个类有默认构造函数。</li>
</ul>
<p>经过验证：<strong>如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数</strong> 是错的，如下可以编译通过并被赋值默认 0！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> isTrue;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">if</span> (a.isTrue) cout &lt;&lt; a.num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这篇文章"><a href="#这篇文章" class="headerlink" title="这篇文章"></a><a href="https://www.cnblogs.com/QG-whz/p/4485574.html">这篇文章</a></h4><p>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/17/C++/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h4 id><a href="#" class="headerlink" title></a></h4><p>腾讯pcg客户端开发<br>拷打实习<br>面试官介绍业务<br>八股：</p>
<ol>
<li>c++多态的理解</li>
<li>线程安全的理解</li>
<li>协程</li>
</ol>
<p>数据库：</p>
<ol>
<li>什么时候用索引</li>
</ol>
<p>网络：</p>
<ol>
<li><p>输入网址到页面显示的过程</p>
</li>
<li><p>get和post区别</p>
</li>
<li><p>C++ 多态</p>
<ul>
<li>静态多态：函数重载，运算符重载，泛型多态(类模板和函数模版)。特点：编译时</li>
<li>动态多态：也称运行时多态，主要是通过虚函数实现，允许在子类中重写父类的方法，对函数调用的解析在运行时进行</li>
</ul>
</li>
<li><p>动态多态的实现机制</p>
<p><img src="/2024/09/17/C++/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/image-20240917092921829.png" alt="image-20240917092921829"></p>
<ul>
<li><p>构建时：父类将需要具体实现的方法定义为虚函数，实现共同逻辑或不实现任何逻辑（纯虚函数）。子类根据具体行为对同名虚函数进行覆盖。</p>
</li>
<li><p>编译时：为处理虚函数，编译器在编译时候在子类内存空间的首地址放入虚函数表指针。虚函数表指针指向子类的虚函数表，这个虚函数表继承自父类，然后在这个虚函数表中作两个事，覆盖父类的同名虚函数地址，在末尾增加自己新定义的虚函数。</p>
</li>
<li><p>运行时：用父类指针指向子类对象，想当于把子类对象当做父类对象去用，此时按照访问父类虚函数的数据流去访问，由于虚函数已经被覆盖，自然访问到的就是子函数的虚函数了。可以验证的是如果用这种方式访问子类新定义的虚函数将会出错。</p>
<blockquote>
<p>所以本质上子函数覆盖了的虚函数其实相当于生成了不同名函数，只不过编译器通过虚表把执行流引到了对应的虚函数位置。这样程序员在编码的时候就可以减少工作量了。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>虚函数</p>
<ol>
<li>虚函数是类中的成员函数，被声明为<code>virtual</code>。它允许派生类（子类）重写（override）基类中的虚函数，实现不同的功能。虚函数机制使得<strong>基类指针或引用可以指向派生类对象，并调用派生类中重写的函数。</strong></li>
<li>类别<ol>
<li>non-virtual: </li>
<li>virtual：可以选择性覆盖</li>
<li>pure virture：一定要覆盖</li>
</ol>
</li>
<li>理解：<ol>
<li>虚函数机制其实是配合多态机制实现的</li>
<li>我们假设父类的函数有实函数，虚函数，实函数不会产生覆盖现象，虚函数会覆盖，且每一个实例拥有自己的虚函数表。</li>
<li>父类指针指向子类对象：<ol>
<li>实函数会走父类的对应函数，调用是通过静态绑定, 直接 call 具体地址</li>
<li>虚函数会走子函数的对应函数，体现多态，调用是通过动态绑定</li>
</ol>
</li>
<li>怎么实现多态的：<ol>
<li>在每一个对象起始处放一个虚表指针，通过虚表指针找到虚表，进而找到对应的表项。</li>
<li>多态，虚函数，虚表都是为了实现一个目的，用一个父类指针调用成员函数，子类根据各自不同类型调用不同的虚函数实现</li>
</ol>
</li>
<li>好的文章<ol>
<li><a href="https://blog.csdn.net/qq_42048450/article/details/117282640">https://blog.csdn.net/qq_42048450/article/details/117282640</a></li>
<li><a href="https://blog.csdn.net/wkd_007/article/details/140316339">https://blog.csdn.net/wkd_007/article/details/140316339</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/611317234">https://zhuanlan.zhihu.com/p/611317234</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>抽象类</p>
<ul>
<li>含有至少一个纯虚函数的类，不能被直接实例化，通常用于定义一个接口或基类。</li>
<li>纯虚函数是一种没有实现的虚函数，它的存在是为了强制派生类提供这些函数的具体实现。</li>
</ul>
</li>
<li><p>泛型编程</p>
<ul>
<li>主要通过模版机制实现，允许编写和类型无关的代码，模版可以是函数模版或类模版</li>
</ul>
</li>
<li><p>函数重载</p>
<ul>
<li>参数的个数，类型，或顺序不同</li>
<li>返回值：参数完全相同，只有返回值类型不同不能构成重载。</li>
<li>类型：构造函数重载，运算符重载，函数重载，成员函数重载</li>
<li>运算符重载：+ - * &#x2F; &#x3D;&#x3D; !&#x3D; &lt;&lt; &gt;&gt; () ++ – ，C++操作符重载是允许开发者为<strong>自定义类型</strong>提供内置操作符（如+、-、*、&#x2F; ++ &#x3D;&#x3D; +&#x3D;等）的新行为的机制，通过这种方式可以使得自定义类型与内置类型一样直观和易于使用。</li>
</ul>
</li>
<li><p>C++ 类中的四种成员</p>
<ul>
<li><strong>非静态数据成员</strong>被放在每一个对象体内作为对象专有的数据成员。</li>
<li><strong>静态数据成员</strong>被提取出来放在程序的静态数据区内(和全局变量一样的位置)，为该类所有对象共享，只存在一份。</li>
<li><strong>静态和非静态成员函数</strong>最终都被提取出来放在程序代码段中并为该类所有对象共享，因此每个成员函数也只能存在一份代码实体。C++中类的成员函数都是保存在静态存储区中，静态成员函数也是保存在静态存储区中，他们都是在类中保存同一个备份。</li>
<li><strong>说明</strong>：构成对象本身的只有数据，任何成员函数都不隶属于任何一个对象，非静态成员函数与对象的关系就是this指针（this详细解释）。成员函数为该类所有对象共享，不仅是处于简化语言实现、节省存储的目的，而且是为了使同类对象有一致的行为。同类对象的行为虽然一致，但是操作不同的数据成员。</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/m0_46535940/article/details/125133512">静态成员函数与非静态成员函数的区别</a></p>
<ul>
<li>无论静态函数还是非静态函数，都属于类的（这一点与数据成员的静态非静态不同），对象并不拥有函数的拷贝。</li>
<li>调用方式：静态成员函数可以通过类或实体调用，但非静态成员函数必须用实例或实例的指针访问。</li>
<li>this: 非静态成员默认传入 this 指针，而非静态成员函数由于不属于对象而没 this 指针。</li>
<li>作用对象：静态成员函数用于管理类相关的静态数据成员，而非静态成员函数管理具体对象相关的数据成员。</li>
<li>多态：静态成员函数不能写成虚函数，而非静态成员函数可以。</li>
</ul>
</li>
<li><p>单继承</p>
<ul>
<li><p>虚函数表派生类覆盖的虚函数的地址被放在了基类虚函数表对应的函数原来的位置。（覆盖）</p>
</li>
<li><p>派生类没有覆盖的虚函数就延用基类的。同时，虚函数按照其声明顺序放于表中，<strong>父类的虚函数在子类的虚函数前面</strong>。</p>
</li>
</ul>
</li>
<li><p>多继承</p>
</li>
</ol>
<ul>
<li><p>每个基类都有自己的虚函数表</p>
</li>
<li><p>派生类的虚函数地址存依照声明顺序<strong>放在第一个基类的虚表最后</strong>.</p>
</li>
</ul>
<ol start="11">
<li><p>override</p>
<ul>
<li>在子类书写的虚函数中添加，目的明确告诉编译器这个函数就是父类虚函数的一个覆盖。</li>
<li>作用：防止手误写错了覆盖函数的签名从而引入新的虚函数。</li>
</ul>
</li>
<li><p>final</p>
<ul>
<li>不希望某个类被继承，或不希望某个虚函数被重写，则可以在类名和虚函数后加上 final 关键字，加上 final 关键字后，再被继承或重写，编译器就会报错。</li>
</ul>
</li>
<li><p>菱形继承</p>
<ul>
<li>在继承树上，某一个子类由于多重继承，导致在内存空间中同时存在多份基类，也就是间接继承了 &gt;&#x3D; 两次的基类，菱形一般指两次。造成问题就是子类空间含有两份基类数据，当使用不同父类指针访问基类元素时候歧义。</li>
<li>解决方法：<strong>虚继承</strong></li>
</ul>
</li>
<li><p>虚继承：</p>
<p><img src="/2024/09/17/C++/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1/image-20240917200349701.png" alt="image-20240917200349701"></p>
<ul>
<li>gcc 和 vc 实现不太一样，gcc 内存布局就是再添加一个基类指针，指向基类内存空间</li>
<li>仍按照继承顺序排列，基类放在最后，每个类拥有自己的虚函数表。最终结果是在子类中没有重复类。因此消除了歧义，缺点是添加了基类指针，造成效率降低。</li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/QG-whz/p/4473384.html">static 关键字</a></p>
<ul>
<li>会影响变量或者函数的，作用域，生命周期，存储位置，至于怎么影响要分情况</li>
<li>全局变量：影响了作用域，使其局限于文件本身。不影响生命周期，存储位置</li>
<li>局部变量：改变了存储位置，生命周期，作用域不变</li>
<li>普通函数：static使得函数在内存中只有一份，并将函数作用域限制在当前源文件。</li>
<li>类 static 成员：static使得成员从“属于类对象”变成了“属于类，而不属于类对象”。</li>
</ul>
</li>
<li><p>static 关键字：<code>static</code>关键字用于控制<strong>变量或函数</strong>的存储期和作用域</p>
<ol>
<li><strong>局部静态变量</strong>：在函数内部声明为<code>static</code>的变量，其生命周期贯穿整个程序，只在首次调用函数时初始化一次。</li>
<li><strong>全局静态变量</strong>：在函数外部声明为<code>static</code>的变量，其作用域限定在定义它的文件内，不会被其他文件访问。</li>
<li><strong>静态成员变量</strong>：类的<code>static</code>成员变量属于类本身，而不是类的某个特定对象，所有对象共享同一份数据。</li>
<li><strong>静态成员函数</strong>：类的<code>static</code>成员函数不依赖于类的任何特定对象，只能访问类的<code>static</code>成员和其他<code>static</code>成员函数。所有对象共享同一份源码。调静态成员函数可以用对象实例也可以用类名</li>
<li><strong>静态类</strong>：声明为<code>static</code>的类只能在定义它的文件内使用，不能被其他文件访问。</li>
</ol>
</li>
<li><p>1. </p>
</li>
<li><p>const 关键字</p>
<ol>
<li>常量值 <code>const int maxUsers = 100;</code></li>
<li>常量指针<ol>
<li>顶层 const : <code>int* const ptr = &amp;someInt;</code></li>
<li>底层 const : <code>const int* ptr;</code></li>
</ol>
</li>
<li>常量引用 <code>void function(const int&amp; ref) &#123; &#125;</code><ol>
<li>常量引用可以指向普通变量和常量变量</li>
<li>普通引用不能指向常量引用</li>
</ol>
</li>
<li>常量成员函数 <code>void myFunction() const &#123; &#125;</code><ol>
<li>不会修改类的任何成员变量（除了那些用<code>mutable</code>修饰的成员）</li>
</ol>
</li>
<li>常量成员变量 <code>class MyClass &#123; public: const int myValue; &#125;;</code><ol>
<li>必须在构造函数初始化列表中初始化，因为它们不能在对象构造后修改。</li>
</ol>
</li>
<li>const 对象：<code>const MyClass myObject;</code><ol>
<li>const MyClass myObject;</li>
</ol>
</li>
</ol>
</li>
<li><p>C++ 智能指针</p>
<ul>
<li>auto_ptr,unique_ptr,shared_ptr,weak_ptr。</li>
<li>智能指针就是这样的一种类。它们的行为类似于指针，同样支持解引用* 或取成员-&gt;运算。智能指针将基本内置类型指针封装为类对象指针，管理着该指针所指向的动态分配资源，并通过类的析构函数对资源进行释放。在C++中，智能指针都是模板类，因为它们要管理的可能是用户自定义类型所分配的内存空间。</li>
</ul>
</li>
<li><p>malloc 和 free</p>
<ul>
<li>并不是直接向操作系统申请或者释放内存，而是应用级内存管理。</li>
<li>最终的申请由 brk 和 mmap 进行</li>
</ul>
</li>
<li><p>new&#x2F;delete</p>
<ol>
<li>new 先分配在构造</li>
<li>delete 先析构，再释放</li>
<li>array new 要记得用 array delete,  array new 分配内存的时候开始部分会有四个字节记录数组长度</li>
</ol>
</li>
<li><p><code>new</code>和<code>malloc</code>的区别：</p>
<ol>
<li><strong>构造函数和析构函数</strong>：<code>new</code>在分配内存的同时调用对象的构造函数，而<code>malloc</code>仅分配内存，不调用构造函数。相应地，<code>delete</code>会调用析构函数，而<code>free</code>不会。</li>
<li><strong>类型安全</strong>：<code>new</code>是类型安全的，返回一个具体类型的指针，而<code>malloc</code>返回<code>void*</code>类型，需要显式类型转换。</li>
<li><strong>表达式</strong>：<code>new</code>是一个运算符，可以与类型一起使用，如<code>new int</code>；<code>malloc</code>是一个函数，需要指定分配的字节大小，如<code>malloc(sizeof(int))</code>。</li>
<li><strong>错误处理</strong>：<code>new</code>在内存分配失败时抛出<code>std::bad_alloc</code>异常（除非使用了<code>new (nothrow)</code>），而<code>malloc</code>在失败时返回<code>NULL</code>。</li>
<li><strong>重载</strong>：<code>new</code>和<code>delete</code>运算符可以被重载，允许自定义内存分配和释放的行为；<code>malloc</code>和<code>free</code>则不能被重载，它们是C标准库函数。</li>
<li><strong>使用场景</strong>：<code>new</code>和<code>delete</code>通常用于C++对象的动态分配和释放，而<code>malloc</code>和<code>free</code>更适用于分配基本数据类型的数组或需要手动管理内存大小的场景。</li>
</ol>
</li>
<li><p>new 出来的 array, 也即动态内存中的数组，一定要用 delete [] array 进行删除，否则只会释放第一个元素</p>
</li>
<li><p><strong>explicit</strong> 用于限定函数不能接受隐式类型转换的函数，比如只接受 string 对象，不接受字符串</p>
</li>
<li><p>强制转换操作符</p>
<ul>
<li><p>static_cast</p>
<ul>
<li>基本数据类型之间的转换</li>
<li>派生类与基类类型指针的转换：注意从下向上的转换是安全的，从上向下的转换不一定安全。</li>
</ul>
</li>
<li><p>const_cast</p>
<ul>
<li>作用是转换表达式的const性质。添加或删除</li>
<li>用处一：改变const 指针指向的数据</li>
<li>用处二：让 const 变量传参给非 const函数</li>
</ul>
</li>
</ul>
</li>
<li><p>深拷贝和浅拷贝</p>
<ul>
<li>主要区别在于指针和引用的处理，是不是要深入一层拷贝</li>
</ul>
</li>
<li><p>转换函数：转换函数（也称为类型转换函数）是一种特殊的成员函数，它允许对象在需要时自动转换为另一种类型。<code>operator Type() const;</code> <code>Type</code>可以是任何内置类型、枚举类型、类类型或其他用户定义的类型</p>
</li>
<li><p>线程安全的理解</p>
</li>
<li><p>模版模版参数：模版参数不是类型，而是另一个模版</p>
</li>
<li><p>类模版，函数模版：</p>
<ol>
<li>允许定义类和函数的时候不指定数据类型，而是用类型参数。这样同一个类模板可以用于多种数据类型，而不需要为每种类型重写类定义。类模板通过关键字<code>template</code>和尖括号<code>&lt;&gt;</code>来定义。类模板和函数模板的实例化是在编译时进行的，编译器根据传入的参数类型生成具体的类或函数实现。  </li>
<li>设计类和模版的时候，你认为那些类型可以抽出来允许用户任意指定，那就将其作为模版参数允许用户指定</li>
</ol>
</li>
<li><p>内存泄漏：程序通过 new 申请的内存空间，却没有通过 delete 释放，空间依然保留，原来指向它的指针却失效，造成无法使用。</p>
</li>
<li><p>偏特化</p>
<ol>
<li>数量上的偏：半指定</li>
<li>范围上的偏：T 偏特化为 T*, 只接受指针类型模版参数</li>
</ol>
</li>
<li><p>友元：友元机制是一种允许非成员函数或类访问类的私有（private）和保护（protected）成员的特殊权限设置，从而在不破坏封装性的前提下实现特定操作的访问。</p>
</li>
<li><p>编程范式</p>
<ol>
<li>数据一定在 private, 函数一般在 public</li>
<li>参数返回值尽量用引用<ol>
<li>函数体内临时生成的变量要传出，不能传引用，其余都尽量传引用</li>
</ol>
</li>
<li>类里能加 const 的尽量加</li>
<li>构造函数尽量用参数列初始化</li>
</ol>
</li>
<li><p>Big three: 拷贝构造，拷贝赋值，析构函数</p>
<ol>
<li>对不含指针类型来说，编译器默认的拷贝或复制就够了</li>
<li>对含指针的类型来说，编译器的朴素复制会造成同一个类的实例指向同一块空间，所以一定要自定义 big three</li>
</ol>
</li>
<li><p>动态绑定</p>
<ol>
<li>通过对象调用，即便是虚函数也会是静态绑定</li>
<li>通过指针调用，且用父类指针指向子类对象，则在调用虚函数时候会通过动态绑定先找到虚表位置，再拿到虚函数地址，然后调用</li>
</ol>
</li>
<li><p>临时对象：指在表达式中创建并使用后立即销毁的对象，它们通常用于函数返回值、参数传递、以及在表达式中生成的临时值。临时对象的生命周期只在包含它们的完整表达式内有效，且不能被直接引用或赋值给变量。语法：typename()</p>
</li>
<li><p>inline：C++中的<code>inline</code>关键字是一种函数修饰符，用于建议编译器在编译时将函数体直接嵌入到每个调用点，以减少函数调用的开销，提高程序的执行效率。它通常用于实现小型、频繁调用的函数，如访问器和设置器。<code>inline</code>函数的内联展开由编译器决定，编译器可能会忽略内联请求。</p>
</li>
<li><p>智能指针：C++智能指针是一种自动管理内存分配和释放的模板类，它通过重载指针操作符来模拟指针的行为，同时在适当的时候自动释放分    配的内存，以防止内存泄漏。常见的智能指针类型包括 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。</p>
</li>
<li><p>生命周期</p>
<ol>
<li>auto object 局部 花括号(区块内)</li>
<li>static object 局部 整个程序</li>
<li>global object 全局 整个程序</li>
</ol>
</li>
<li><p>迭代器</p>
<ol>
<li>迭代器也类似于智能指针，一般会模拟指针的 * 和 -&gt; 操作</li>
<li>同时也会重载 ++ – &#x3D;&#x3D; !&#x3D; 操作</li>
</ol>
</li>
<li><p>仿函数：类中重载 （）操作符</p>
</li>
<li><p>auto</p>
<ol>
<li>只有定义同时赋值，编译器才可以推导</li>
<li>用 auto 的前提是你清楚你所定义的数据类型，但是不想写，如臭长的迭代器</li>
</ol>
</li>
<li><p>namespace 机制：<code>namespace</code>是一种封装机制，用于组织代码和防止命名冲突。它允许程序员将相关的函数、类、对象和其他类型定义在同一个命名空间内，从而使得代码更加模块化和易于管理。语法：<code>namespace jj01 &#123; // 定义变量，函数，类等 &#125;</code></p>
</li>
<li><p>引用的理解</p>
<ol>
<li>引用在定义时必须设初值，代表则个引用将来<strong>代表</strong>某变量</li>
<li>实际实现是指针，表像是变量别名</li>
<li>不常用于声明变量，而用于参数类型和返回类型描述</li>
<li>传引用和传同类型变量不影响函数签名</li>
</ol>
</li>
<li><p>继承</p>
<ol>
<li>is - a 关系</li>
<li>构造时先父类构造（虚函数），后子类构造，析构先子类析构，然后父类析构</li>
</ol>
</li>
<li><p>复合</p>
<ol>
<li>has - a 关系</li>
<li>内部拥有一个类，构造时先内部构造，再外部构造，析构先外部析构，再内部析构</li>
</ol>
</li>
<li><p>委托</p>
<ol>
<li>composition by reference</li>
<li>方便设计成 handle&#x2F;body</li>
</ol>
</li>
<li><p>Lambda 函数</p>
<ul>
<li><p>介绍：匿名函数，可以作为一个参数传入接收匿名函数或仿函数的位置，就地写一个小的函数，方便且优雅。lambda 实际执行中被转变成函数对象 。</p>
</li>
<li><p>基本语法：<code>[capture](parameter)-&gt; return_type &#123; /*....*/ &#125;</code></p>
</li>
<li><p>[capture] : [] 内为外部变量的传递方式。</p>
</li>
<li><p>(parameters) ：（）内为形参，和普通函数的形参一样。</p>
</li>
<li><p>-&gt; return_type：返回类型，编译器自动推断，可省略。</p>
</li>
<li><p>参考文献：<a href="https://www.jb51.net/article/232859.htm">C++中的Lambda函数详解</a></p>
</li>
</ul>
</li>
<li><p>仿函数(functor)</p>
<ul>
<li>介绍：又称函数对象（function object），是实现了 （）成员函数的特殊类。与普通的函数指针相比，仿函数能够<strong>封装状态信息、支持继承和多态</strong>等。</li>
<li>基本语法：<code>struct foo &#123; int operator()(args) const &#123; /*...*/ &#125;&#125;;</code></li>
</ul>
</li>
<li><p><a href="https://blog.51cto.com/u_13099480/11337511">继承，复合，委托</a></p>
<ul>
<li>介绍：继承(is-a)，复合(has-a)，委托。</li>
</ul>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/660791531">c++ 实现分割 split() 函数</a></p>
<ul>
<li>利用 stringstream 对象中，&gt;&gt; 符号默认按空白读取（空格，table，换行），getline(str,t,delim) 可以指定分隔符读取</li>
<li>分隔符不是单个字符：利用 string 的 find 函数 和 substr() 函数</li>
</ul>
</li>
</ol>
<h1 id="20240912-字节1面"><a href="#20240912-字节1面" class="headerlink" title="20240912 字节1面"></a>20240912 字节1面</h1><h1 id="我不会的"><a href="#我不会的" class="headerlink" title="我不会的"></a>我不会的</h1><ol>
<li>七层网络协议模型</li>
<li>TCP和UDP区别、优劣、使用场景，滑动窗口原理</li>
<li>红黑树条件</li>
<li>TCP各种请求，有什么区别，列举一些返回码和其含义</li>
</ol>
<h1 id="我会的"><a href="#我会的" class="headerlink" title="我会的"></a>我会的</h1><ol>
<li>中断是什么，对CPU有什么影响</li>
<li>内核态和用户态</li>
<li>进程和线程区别，线程的内存结构（堆、栈）</li>
<li>各种进程调度算法</li>
</ol>
<h1 id="讨论题"><a href="#讨论题" class="headerlink" title="讨论题"></a>讨论题</h1><ol>
<li>当你遇到特别困难的问题时怎么办（生活中、工作中）</li>
</ol>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><p>n &#x3D; 23121<br>A &#x3D; {2, 5, 9}<br>找到由A组成的小于n的最大数<br>A中所有数 0 &lt;&#x3D; A[i] &lt;&#x3D; 9</p>
<p>例如</p>
<p>n &#x3D; 23121<br>A &#x3D; {2, 5, 9}<br>ans &#x3D; 22999</p>
<p>n &#x3D; 22222<br>A &#x3D; {2, 5, 9}<br>ans &#x3D; 2222</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">       s.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">       n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; t) nums.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> minl = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> _max = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = minl; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; nums[<span class="number">0</span>]) minl = i;</span><br><span class="line">        _max = <span class="built_in">max</span>(_max, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> mark = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(minl == s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; _max &gt; nums[<span class="number">0</span>])</span><br><span class="line">    mark = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(minl != s.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = minl; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; nums[<span class="number">0</span>])</span><br><span class="line">        &#123;   mark = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(mark) <span class="comment">// 不降位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; s[i]) j --;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; s.<span class="built_in">size</span>(); k ++)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans.<span class="built_in">assign</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>, nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e: ans) cout &lt;&lt; e;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AFL源码阅读</title>
    <url>/2024/07/06/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>AFL 源码阅读记录</p>
<span id="more"></span>

<ul>
<li><p>main 函数</p>
<ul>
<li><p>函数功能：解析命令参数，</p>
</li>
<li><p>具体过程：</p>
<ul>
<li>命令解析</li>
<li>分别调用 setup_signal_handlers(); check_asan_opts(); 设置信号处理函数，设置 asan；如果是并行 fuzzing ，调用 fix_up_sync() 设置同步</li>
<li>根据环境变量设置运行全局变量，检测可能存在的模式冲突</li>
<li>调用 save_cmdline 保存命令行；调用 fix_up_banner 设置运行时窗口；调用 check_if_tty 测试终端；调用 get_core_count 获取 CPU 核心数，如果开启了 CPU 亲和性，调用 bind_to_free_cpu() 找到空闲核心；调用 check_crash_handling() 查看core pattern 是否设置为 core；调用 setup_post() 设置收尾处理函数；调用 setup_shm() 设置最关键的路径记录向量；调用 init_count_class16() 构建 count_class_lookup16[65536] 阶梯数组；调用 setup_dirs_fds() 设置好输出文件夹；调用 read_testcases() 把输入文件夹的测试用例加入测试 queue；调用 load_auto() 读取输出文件夹中自动生成的字典；<strong>啥时候生成的</strong>？调用 pivot_inputs() 在输出目录中为输入测试用例建立硬链接；<strong>目的是什么？</strong>如果使用 -x 参数设置了 extras_dir，就调用 load_extras 加载字典；如果没有设置 timeout_given，调用 find_timeout() 尝试从先前的运行中读取 exec_tmout（如果设置了 resuming_fuzz）； 调用 detect_file_args(argv + optind + 1) 对参数中的 @@ 进行替换；如果没有设置 out_file，调用 setup_stdio_file() 删除可能的遗留并新建 out_dir&#x2F;.cur_input；<strong>将来谁往里面写</strong>？调 check_binary(argv[optind]) 进行二进制文件检测。</li>
<li>记录当前时间戳，写入 start_time</li>
<li>如果是 qemu 模式，调用 get_qemu_argv(argv[0], argv + optind, argc - optind) 重新设置参数</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li><p>setup_shm 设置的几个关键变量</p>
<ul>
<li>virgin_bits	没有触碰到的路径，在 in_bitmap 为空，也即没有外来引入 bitmap 情况下，初始化为 0xFF</li>
<li>virgin_tmout  没有超时的路径，初始化为 0xFF，<strong>逻辑不通</strong></li>
<li>virgin_crash   没有 crash 的路径，初始化为0xFF</li>
<li>trace_bits       申请匿名共享内存，并加载到 fuzzer 进程空间，用 trace_bits 指向这个地址，将共享内存 id 放到环境变量 __AFL_SHM_ID 中。<strong>为什么要以字符串形式放进去？</strong></li>
</ul>
</li>
<li><p>timeout_given </p>
<ul>
<li>-t 选项参数中 exec_tmout 有 + 后缀，timeout_given &#x3D; 2，否则为 1</li>
<li>没设置 -t，则 timeout_given 为 0</li>
<li>in_place_resume 模式下，超时时间来自于上次运行 out_dir&#x2F;fuzzer_stats 文件中的 exec_timeout 字段，则设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>resuming_fuzz</p>
<ul>
<li>一旦从 queue 读到名称为 id:%06u,orig:%s 测试用例的测试用例，将 resuming_fuzz 设为 1，其余情况皆为 0</li>
</ul>
</li>
<li><p>in_place_resume</p>
<ul>
<li>如果 -i 的参数是 -，则将 in_place_resume 设置为 1。<strong>除了 in_place_resume 还有什么恢复形式</strong>？</li>
</ul>
</li>
<li><p>static u32 find_start_position(void)</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，找到继续 fuzz 的起始点</li>
<li>具体过程：<ul>
<li>找到 out_dir&#x2F;fuzzer_stats，读出其中的 cur_path</li>
<li>如果 cur_path 大于 queued_paths，则返回 0，否则返回 cur_path。</li>
</ul>
</li>
</ul>
</li>
<li><p>static void find_timeout(void) 函数</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，设置 exec_tmout 和   timeout_given</li>
<li>具体过程：</li>
<li>如果是 in_place_resume，读取 out_dir&#x2F;fuzzer_stats 文件，否则读取 in_dir&#x2F;..&#x2F;fuzzer_stats 文件</li>
<li>读取其中的 exec_timeout，都不到，或读到了值小于 4，直接返回没有任何改动</li>
<li>如果读到了并且不小于 4 ，则把 exec_timeout 设置到 exec_tmout，并设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>EXP_ST void detect_file_args(char** argv) 函数</p>
<ul>
<li>函数作用：把参数中 @@ 替换</li>
<li>具体过程：<ul>
<li>逐个遍历 afl-fuzz 的参数，遇到含有 @@ 则停下来处理</li>
<li>如果通过 -f 指定了 out_file，并且 out_file 是自根目录 &#x2F; 开始，则将 @@ 替换为 out_file，如果不是自根目录开始，则将 @@ 替换为 cwd&#x2F;out_file</li>
<li>如果压根没指定 out_file，把 @@ 替换为 out_dir&#x2F;.cur_input</li>
<li>形如 xxx@@xxx, 也对@@进行相同的替换。</li>
</ul>
</li>
</ul>
</li>
<li><p>EXP_ST void setup_stdio_file(void) 函数</p>
<ul>
<li>函数作用：删除可能的遗留并新建 out_dir&#x2F;.cur_input</li>
</ul>
</li>
<li><p>EXP_ST void check_binary(u8* fname) 函数</p>
<ul>
<li>函数作用：确保测试目标存在且是正常的二进制可执行文件，测试是否插桩匹配当前运行模式，</li>
<li>函数过程：<ul>
<li>如果 fname 含有 &#x2F; ，或者 fname 不含 &#x2F;  但 PATH 环境变量是空的，直接拿着 fname 做检测，假如不是常规文件，或者不具备执行权限，或者 size 小于 4，视为不合格 target_path，<strong>报错退出</strong>。</li>
<li>fname 不含 &#x2F;，且 PATH 环境变量不空，就遍历 path 中的路径，并在每个路径下搜索 fname 文件，满足：是常规文件，具备执行权限， size 大于 4，视为合格 target_path，结束遍历。如果遍历所有路径，没找到满足这三个条件的 fname，视为没有合格 target_path，将 target_path 置 0，<strong>报错退出</strong>。</li>
<li>找到合格 target_path 时候，检查 AFL_SKIP_BIN_CHECK 是否被设置，设置则返回，否则观察如果二进制文件在 &#x2F;tmp&#x2F; 或 &#x2F;var&#x2F;tmp&#x2F; 文件夹中，<strong>报错退出</strong>。</li>
<li>将二进制文件直接用 mmap 映射到进程地址空间<ul>
<li>检测到是 shell 脚本，则<strong>报错退出</strong>。</li>
<li>检测到不是 ELF 文件，则<strong>报错退出</strong>。</li>
<li>在非 qemu_mode 且非 dumb_mode 下检测是否插桩，memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1)) 检测方式是在二进制文件中搜索共享内存 id，检测到代表已经完成插桩。</li>
<li>qemu_mode 下，如果也进行了插桩，则<strong>报错退出</strong>。</li>
<li>在二进制文件中搜索到 libasan.so 或 __msan_init，则设置 uses_asan &#x3D; 1</li>
<li>如果在二进制中搜索到 ##SIG_AFL_PERSISTENT## ，则把环境变量 __AFL_PERSISTENT 设为 1，把 persistent_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_PERSISTENT 却被设置了，矛盾，输出报警信息。</li>
<li>如果在二进制中搜索到 ##SIG_AFL_DEFER_FORKSRV## ，则把环境变量 __AFL_DEFER_FORKSRV 设为 1，把 deferred_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_DEFER_FORKSRV 却被设置了，矛盾，输出报警信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static char** get_qemu_argv(u8* own_loc, char** argv, int argc)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>申请大小为 argc + 4 的 char 指针数组 new_argv</li>
<li>把 argv[1] 开始的 argc 项拷贝到 new_argv[3] 开始的位置</li>
<li>填充 argv[1-2], new_argv[2] &#x3D; target_path, new_argv[1] &#x3D; “–”</li>
<li>填充 argv[0]，<ul>
<li>先考虑 AFL_PATH&#x2F;afl-qemu-trace 文件，存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>再看 own_loc&#x2F;afl-qemu-trace （own_loc 如果含有 &#x2F; 的话），存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>前两个路径都没找到，看 BIN_PATH “&#x2F;afl-qemu-trace”，其中 BIN_PATH 在根 makefile 中定义，存在则操作同上</li>
<li>前面都寻找失败，则报错退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static void perform_dry_run(char** argv)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>cal_failures 初始化为 0，用于，获取环境变量 AFL_SKIP_CRASHES 写进 skip_crashes</li>
<li>遍历测试用例队列 queue，做如下事情<ul>
<li>将测试用例内容读入新开辟内存 use_mem 上，<strong>为什么多此一举</strong>？执行 res &#x3D; calibrate_case(argv, q, use_mem, 0, 1)</li>
<li>此时若 stop_soon 不为 0，<strong>函数返回</strong></li>
<li>如果 res &#x3D;&#x3D; crash_mode 或者 res &#x3D;&#x3D; FAULT_NOBITS，打印一下当前元素的 q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us 三个信息</li>
<li>然后根据 res 的值分类处理<ul>
<li>FAULT_NONE：如果当前处理的是队列首元素，也即 q &#x3D;&#x3D; queue，调 check_map_coverage()；如果 crash_mode 被设置，<strong>报错退出</strong>。</li>
<li>FAULT_TMOUT：依据 timeout_given 是否为 0 分别处理<ul>
<li>timeout_given 为 0，报错退出。</li>
<li>timeout_given 不为 0，且为 2 或 3（2代表 -t 参数有 + 号，3代表 in_place_resume 且上次执行设置了 exec_tmout），报警并 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++;</li>
</ul>
</li>
<li>FAULT_CRASH：</li>
<li>如果 crash_mode 被设置，跳过不处理，结束 switch</li>
<li>如果 skip_crashes 被设置，执行 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++，结束 switch</li>
<li>如果前面两个都没设置，而 mem_limit 被设置，打印出可能出错的原因</li>
<li>FAULT_ERROR：代表文件不能执行，结束 switch</li>
<li>FAULT_NOINST：文件没有被插桩，结束 switch</li>
<li>FAULT_NOBITS：useless_at_start++，如果 in_bitmap 和 shuffle_queue 都为 0，报警，结束 switch</li>
</ul>
</li>
<li>如果 q-&gt;var_behavior 被设置，报警 Instrumentation output varies across runs，<strong>什么意思</strong></li>
</ul>
</li>
<li>遍历完成之后，如果 cal_failures 不为 0，根据 cal_failures 和 queued_paths 的相对数据处理<ul>
<li>cal_failures &#x3D;&#x3D; queued_paths，所有测试用例都失败，报错退出</li>
<li>al_failures * 5 &gt; queued_paths，超过 20% 测试用例失败，报警。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) 函数</p>
<ul>
<li>函数作用：</li>
<li><h2 id="具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration"><a href="#具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration" class="headerlink" title="具体过程：- 局部变量  - static u8 first_trace[MAP_SIZE]  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)  - use_tmout &#x3D; exec_tmout  - old_sn &#x3D; stage_name- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace- 开始计时，写入 start_us- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 abort_calibration    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 abort_calibration    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等      - 相等，没有操作，往下流      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb      - 看 q-&gt;exec_cksum 是否有值        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子- abort_calibration"></a>具体过程：<br>- 局部变量<br>  - static u8 first_trace[MAP_SIZE]<br>  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)<br>  - use_tmout &#x3D; exec_tmout<br>  - old_sn &#x3D; stage_name<br>- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大<br>- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;<br>- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever<br>- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace<br>- 开始计时，写入 start_us<br>- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：<br>  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘<br>  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。<br>  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，<br>    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等<br>      - 相等，没有操作，往下流<br>      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb<br>      - 看 q-&gt;exec_cksum 是否有值<br>        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮<br>        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮<br>- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max<br>- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;<br>- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子<br>- <strong>abort_calibration</strong></h2></li>
</ul>
</li>
<li><p>static void write_to_testcase(void* mem, u32 len) 函数</p>
<ul>
<li>函数作用：把 mem 开始的 len 字节作为测试用例写默认的或特指的文件中去。</li>
<li>具体过程：<ul>
<li>如果 out_file 指定了，删除原文件，把 mem 开始的 len 字节作为测试用例写进去。如果 out_file 没指定，则写到 out_fd 里</li>
<li>如果是通过 out_fd 写，则需要截断文件，并移动文件光标。</li>
</ul>
</li>
</ul>
</li>
<li><p>has_new_bits 函数</p>
<ul>
<li>返回 2，发现新 tuples</li>
<li>返回 1，没发现新 tuples，但是命中数量增加</li>
<li>返回 0，没有任何发现</li>
</ul>
</li>
<li><p>persistent_mode</p>
<ul>
<li>“Persistent Mode”（持久模式）允许模糊测试工具在目标程序中更高效地探索执行路径。</li>
<li>可以通过以下方式启用持久模式：<ul>
<li>使用 <code>__AFL_LOOP()</code> 宏来指示循环的开始和结束。</li>
<li>使用 <code>__AFL_INIT()</code> 宏来执行一次性的初始化。</li>
<li>使用 <code>__AFL_FUZZ_TESTCASE_BUF</code> 和 <code>__AFL_FUZZ_TESTCASE_LEN</code> 宏来访问当前的测试用例数据和长度。</li>
</ul>
</li>
</ul>
</li>
<li><p>deferred_mode</p>
</li>
<li><p>afl-qemu-trace</p>
<ul>
<li><a href="https://blog.csdn.net/song_lee/article/details/105082092">https://blog.csdn.net/song_lee/article/details/105082092</a></li>
<li><a href="https://blog.csdn.net/qysh123/article/details/114792891">https://blog.csdn.net/qysh123/article/details/114792891</a></li>
<li><a href="https://airbus-seclab.github.io/AFLplusplus-blogpost/">https://airbus-seclab.github.io/AFLplusplus-blogpost/</a></li>
<li><a href="https://aflplus.plus/docs/env_variables/">https://aflplus.plus/docs/env_variables/</a></li>
<li><a href="https://afl-1.readthedocs.io/en/latest/user_guide.html">https://afl-1.readthedocs.io/en/latest/user_guide.html</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://github.com/nccgroup/TriforceAFL">https://github.com/nccgroup/TriforceAFL</a></li>
<li><a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md</a></li>
</ul>
</li>
<li><p>crash_mode</p>
<ul>
<li>-C 选项代表 crash_mode &#x3D; FAULT_CRASH，仅此设置</li>
</ul>
</li>
<li><p>dumb_mode</p>
<ul>
<li>默认为 0，在有 -n 选项的情况下，如果设置了 AFL_DUMB_FORKSRV 环境变量，dumb_mode &#x3D; 2，否则 dumb_mode &#x3D; 1</li>
</ul>
</li>
<li><p>out_file</p>
<ul>
<li>-f 指定，是等待 fuzz 的测试用例</li>
</ul>
</li>
<li><p>out_fd</p>
<ul>
<li>setup_stdio_file 中被设置为指向 out_dir&#x2F;.cur_input</li>
<li>out_fd 是指向 out_file 的文件描述符？可能的机制是，out_fd 默认指向 out_dir&#x2F;.cur_input，但是当用户指定了 out_file，则 out_file 顶替了默认的 out_dir&#x2F;.cur_input 的作用。</li>
</ul>
</li>
<li><p>var_bytes[i]</p>
</li>
</ul>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL调试准备</title>
    <url>/2023/09/06/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/AFL%E8%B0%83%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>调试 AFL </p>
<span id="more"></span>

<ul>
<li><p>在vscode+mingw64的条件下试图调试AFL,发现缺少头文件</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906163736865.png" alt="image-20230906163736865"></p>
<p>考虑安装VS再尝试</p>
</li>
<li><p>安装vs之后仍然报头文件缺失，然后全局搜索 shm.h 文件，发现本机并没有这个文件。此时恍然大悟，AFL 可能本来就不能再win上运行，<a href="https://www.51cto.com/article/753518.html">查证</a>后果然，为此还有人开发了 win 上的 AFL 工具<a href="https://github.com/ivanfratric/winafl">WinAFL</a>。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906171407166.png" alt="image-20230906171407166"></p>
</li>
<li><p>那么现在的方案有两个</p>
<ul>
<li>在 mac 上调试</li>
<li>在 linux 上直接 gdb 调试。或者 gdb + vscode 可视化调试</li>
</ul>
</li>
</ul>
<p>首先尝试第二种方案：</p>
<ul>
<li><p>读懂 Makefile 文件，给出 -g 编译选项，方便调试。</p>
</li>
<li><p>研究之后发现本来的 Makefile 中编译选项已经包含了 -g 所以都可以直接调试。</p>
</li>
<li><p>下一步思考怎么搭建一个双机调试环境？</p>
</li>
<li><p>退一步学习一下怎么样使用gdb调试。</p>
</li>
<li><p>先进行一个小的实验：<a href="https://xz.aliyun.com/t/4314">初探AFL-Fuzz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插桩编译</span></span><br><span class="line">afl-gcc -g -o test test.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模糊测试</span></span><br><span class="line">afl-fuzz -i input_dir -o output_dir program</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始使用GDB调试AFL</p>
<ul>
<li><a href="https://www.cnblogs.com/suphgcm/p/15498577.html">GDB cheetsheet</a></li>
<li><a href="https://wenku.baidu.com/view/30c4cfbfcf22bcd126fff705cc17552707225e0f.html?_wkts_=1694057567582&bdQuery=gdb+cheetsheet">cheet sheet</a></li>
<li><a href="https://blog.csdn.net/wxh0000mm/article/details/108582238">gdb速查表</a></li>
<li><a href="https://github.com/yimaginer/awesome-cheatsheets/blob/master/tools/gdb.txt">awesome-cheetsheet</a></li>
</ul>
</li>
</ul>
<p>记录调试过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动调试</span></span><br><span class="line">gdb --args afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GDB 前端</span></span><br><span class="line">ctrl-x ctrl-a 更换 CLI/TUI</span><br></pre></td></tr></table></figure>

<p>遇到的问题：<br><a href="http://www.taodudu.cc/news/show-5082273.html?action=onClick">GDB调试显示＜ optimized_out ＞</a></p>
]]></content>
      <tags>
        <tag>AFL</tag>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>docker环境</title>
    <url>/2023/09/07/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/docker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>docker环境</p>
<span id="more"></span>

<ol>
<li>在linux环境安装docker：<a href="https://docs.docker.com/desktop/install/linux-install/">https://docs.docker.com/desktop/install/linux-install/</a></li>
<li>docker权限问题：<a href="https://blog.csdn.net/AS_TS/article/details/131184815">https://blog.csdn.net/AS_TS/article/details/131184815</a></li>
</ol>
<h2 id="exercise1"><a href="#exercise1" class="headerlink" title="exercise1"></a>exercise1</h2><p>在docker环境中作一份代码的fuzzing</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本机下载问题代码</span></span><br><span class="line">git clone https://github.com/alex-maleno/Fuzzing-Module.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 AFL++ 的 docker 容器</span></span><br><span class="line">docker run --rm -it -v /home/tiger/fuzz/Fuzzing-Module://home/Fuzzing-Module 6612ffca640e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 编译示例代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成seeds</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始fuzzing</span></span><br><span class="line">/AFLplusplus/afl-fuzz -i /home/Fuzzing-Module/exercise1/seeds -o out -m none -d -- /home/Fuzzing-Module/exercise1/build/simple_crash</span><br><span class="line"></span><br><span class="line">docker run --rm -it -v &quot;/home/tiger&quot;:&quot;/home/tiger&quot; 6612ffca640e</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LibAFL入门</title>
    <url>/2024/06/15/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/LibAFL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>原文地址：<a href="https://www.atredis.com/blog/2023/12/4/a-libafl-introductory-workshop">LibAFL Introductory workshop — Atredis Partners</a></p>
<p>来自一家很酷的公司：<a href="https://www.atredis.com/careers">Careers — Atredis Partners</a></p>
<hr>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么选择-LibAFL"><a href="#为什么选择-LibAFL" class="headerlink" title="为什么选择 LibAFL"></a>为什么选择 LibAFL</h2><p>Fuzzing（模糊测试）非常棒！在正确的设置下，快速地向目标投掷随机输入可以产生不合理的效果。当开始一个新的目标时，模糊测试的框架可以与你的逆向工程&#x2F;审计工作一起迭代，你可以安心地睡觉，知道你的核心在夜间值班。在寻找漏洞时，我们的时间通常是有限的；任何花在工具上的努力都需要是值得的。LibAFL 是一个很棒的库，可以让我们快速地将模糊测试器适应我们的特定目标。并不是每个目标都适合“解析文件的命令行程序”类别，因此 LibAFL 让我们为特定情况制作模糊测试器。这种适应性为更广泛的目标打开了模糊测试的力量。</p>
<h2 id="为什么举办研讨会"><a href="#为什么举办研讨会" class="headerlink" title="为什么举办研讨会"></a>为什么举办研讨会</h2><p>以下材料来自一个内部研讨会，用作对 LibAFL 的介绍。这篇文章是对研讨会的总结，并包括一个练习和示例的仓库，供你在家跟随。它期望你已经有一些 Rust 和模糊测试概念的理解。（如果你需要复习 Rust：Google 的全面 Rust 是很棒的。）</p>
<p>已经有一些很好的资源可以学习 LibAFL。</p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>这个研讨会旨在增加用 LibAFL 构建的示例模糊测试器的现有语料库，重点是将模糊测试器定制到我们的目标。你还会找到一些入门问题，以便你亲手体验 LibAFL。在整个研讨会中，我们尝试突出库的多功能性和力量，让你看看你可以在哪里将模糊测试器融入你的流程。</p>
<h2 id="课程预告"><a href="#课程预告" class="headerlink" title="课程预告"></a>课程预告</h2><p>顺便说一句，如果你对这类事情（安全工具、漏洞、模糊测试）感兴趣，你可能会对我们的符号执行课程感兴趣。我们计划在 2024 年 2 月与 ringzer0 举行一次虚拟会议。本文末尾有更多信息。</p>
<h2 id="模糊测试器"><a href="#模糊测试器" class="headerlink" title="模糊测试器"></a>模糊测试器</h2><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在整个研讨会中，我们一直在测试一个在 Linux 上运行的简单目标。这个目标本身并不是很有趣，但作为我们模糊测试器的一个很好的示例目标。它逐行接收一些文本，并替换某些标识符（如 <code>&#123;&#123;XXd3sMRBIGGGz5b2&#125;&#125;</code>）为名称。为此，它包含一个具有非常大查找树的函数。在这个函数中，许多查找情况可能导致段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">uid_to_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* uid)</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span> <span class="comment">// 大量的嵌套 switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (nbuf[<span class="number">14</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="comment">// 常规情况，没有段错误</span></span><br><span class="line">        addr = &amp;names[<span class="number">0x4b9</span>];</span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">        <span class="comment">// 一个坏情况</span></span><br><span class="line">        addr = ((<span class="type">const</span> <span class="type">char</span>**)<span class="number">0x68c2</span>);</span><br><span class="line">        <span class="comment">// 这里 SEGFAULT</span></span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>

<p>这为我们提供了一个目标，它有许多不同的代码路径，并且有许多可达到的“漏洞”可以发现。随着我们的进展，我们将适应我们的模糊测试器到这个目标，展示一些常见的方法，我们可以使用 LibAFL 将模糊测试器塑造成一个目标。</p>
<p>你可以在这里找到我们的目标，并且仓库包括一些稍后示例中有用的变体。<a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target.c">.&#x2F;fuzz_target&#x2F;target.c</a></p>
<h2 id="模糊测试器的组成部分"><a href="#模糊测试器的组成部分" class="headerlink" title="模糊测试器的组成部分"></a>模糊测试器的组成部分</h2><p>在我们深入示例之前，让我们快速了解一下现代模糊测试器的内部结构。LibAFL 将模糊测试器分解为可以互换或更改的部分。LibAFL 充分利用了 <a href="https://google.github.io/comprehensive-rust/methods-and-traits/traits.html">Rust 的特性系统</a>来做到这一点。下面我们有一个非常简单的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器的脚本可能像下面这样简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ! [ -f ./core.* ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">head</span> -c 900 /dev/urandom &gt; ./testfile</span><br><span class="line">    <span class="built_in">cat</span> ./testfile | ./target</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上面的简单模糊测试器遵循三个核心步骤。</p>
<ol>
<li>生成一个随机输入</li>
<li>使用新输入运行目标</li>
<li>如果创建的输入导致“胜利”（在这种情况下，胜利是产生核心文件的崩溃），则保留该输入</li>
</ol>
<p>如果你错过了上述任何部分，你将不会有一个非常好的模糊测试器。我们都听说过研究人员将随机输入管道到他们的目标，得到了一个令人兴奋的崩溃，但因为他们没有保存测试用例，所以再也无法重现该漏洞的悲惨故事。</p>
<p>即使有了上述部分，那个简单的模糊测试器也会在发现漏洞方面挣扎。它甚至没有进展的概念！下面我们有一个更现代的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器基于一组现有的输入，这些输入被随机变异以创建新的测试用例。“变异”只是一组可以快速应用于输入的简单修改，以生成新的有趣的输入。重要的是，这个模糊测试器还使用执行目标的观察结果来知道输入是否“有趣”。与仅关心崩溃的模糊测试器不同，具有反馈的模糊测试器可以将变异的测试用例重新路由到要变异的输入集中。这允许模糊测试器通过迭代输入，跟踪目标中有趣的功能来取得进展。</p>
<p>LibAFL 为这些“部分”中的每一个提供了工具。</p>
<ul>
<li>实现 <code>Executor</code> 特性的将使用给定的测试用例运行目标。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html">https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html</a></li>
</ul>
</li>
<li><code>Corpus</code> 特性是用于保存一组测试用例的项目，通常用于输入或解决方案。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html">https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html</a></li>
</ul>
</li>
<li>实现 <code>Scheduler</code> 特性的东西负责从语料库中选择输入以制作下一个测试用例。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html">https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html</a></li>
</ul>
</li>
<li>实现 <code>Mutator</code> 特性的提供在运行前更改输入的修改。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html">https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html</a></li>
</ul>
</li>
<li><code>Feedback</code> 和 <code>Observer</code> 特性提供了有用的工具，用于决定输入是否有用。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html">https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html</a></li>
<li><a href="https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html">https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html</a></li>
</ul>
</li>
</ul>
<p>我们还将看到其他重要的特性。一定要查看特性文档中的“实现者”部分，看看库提供的有用实现。</p>
<h2 id="Exec-模糊测试器"><a href="#Exec-模糊测试器" class="headerlink" title="Exec 模糊测试器"></a>Exec 模糊测试器</h2><p>这就带我们来到了我们的第一个示例！让我们通过使用 LibAFL 的一个基本模糊测试器来逐步了解。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer/src/main.rs">.&#x2F;exec_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>源代码有详细的注释，你应该仔细阅读。这里我们只突出一些关键部分。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = CommandExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = StdState::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            StdRand::<span class="title function_ invoke__">with_seed</span>(<span class="title function_ invoke__">current_nanos</span>()),</span><br><span class="line">            InMemoryCorpus::&lt;BytesInput&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            OnDiskCorpus::<span class="title function_ invoke__">new</span>(PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;./solutions&quot;</span>)).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            &amp;<span class="keyword">mut</span> feedback,</span><br><span class="line">            &amp;<span class="keyword">mut</span> objective,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>我们的模糊测试器使用一个“状态”对象，该对象跟踪输入测试用例的集合、任何解决方案测试用例以及其他元数据。注意我们选择将输入保存在内存中，但将解决方案测试用例保存到磁盘上。</p>
<p>我们使用 <code>CommandExecutor</code> 来执行我们的目标程序，它将运行目标进程并传入测试用例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            <span class="title function_ invoke__">havoc_mutations</span>(),</span><br><span class="line">            <span class="number">9</span>,                 <span class="comment">// 最大变异迭代次数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stages</span> = tuple_list!(StdMutationalStage::<span class="title function_ invoke__">new</span>(mutator));</span><br></pre></td></tr></table></figure>

<p>我们为输入构建了一个非常简单的管道。这个管道只有一个阶段，它将为每个测试用例随机选择一组变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">scheduler</span> = RandScheduler::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fuzzer</span> = StdFuzzer::<span class="title function_ invoke__">new</span>(scheduler, feedback, objective);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载我们状态中的初始语料库</span></span><br><span class="line">        <span class="comment">// 由于我们在这个模糊测试器中缺乏反馈，我们必须强制执行</span></span><br><span class="line">        state.<span class="title function_ invoke__">load_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> mgr, &amp;[PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;../fuzz_target/corpus/&quot;</span>)]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊测试</span></span><br><span class="line">        fuzzer.<span class="title function_ invoke__">fuzz_loop</span>(&amp;<span class="keyword">mut</span> stages, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> state, &amp;<span class="keyword">mut</span> mgr).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error in fuzz loop&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过一个调度器和一些反馈（这里我们使用 <code>ConstFeedback::False</code> 来没有任何反馈，除了目标反馈，这是一个 <code>CrashFeedback</code>），我们可以加载我们的初始条目并开始模糊测试。我们使用创建的阶段、选择的执行器、状态和一个事件管理器来开始模糊测试。我们的事件管理器将让我们知道当我们开始获得“胜利”时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan exec_fuzzer]$ ./target/release/exec_fuzzer/</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 3, objectives: 0, executions: 3, exec/sec: 0.000</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 3, objectives: 1, executions: 3, exec/sec: 2.932</span><br><span class="line">[Stats #0] run time: 0h-0m-15s, clients: 1, corpus: 3, objectives: 1, executions: 38863, exec/sec: 2.590k</span><br><span class="line">[Objective #0] run time: 0h-0m-20s, clients: 1, corpus: 3, objectives: 2, executions: 38863, exec/sec: 1.885k</span><br></pre></td></tr></table></figure>

<p>我们脆弱的目标很快就开始给我们崩溃，即使没有反馈。从一组有用的输入开始有助于我们的变异能够找到崩溃的输入。</p>
<p>这个简单的执行模糊测试器为我们提供了一个良好的基础，我们可以在此基础上添加更多功能。</p>
<h2 id="带自定义反馈的-Exec-模糊测试器"><a href="#带自定义反馈的-Exec-模糊测试器" class="headerlink" title="带自定义反馈的 Exec 模糊测试器"></a>带自定义反馈的 Exec 模糊测试器</h2><p>没有反馈，我们就不能有效地迭代有趣的输入。目前我们的随机变异必须一次性生成一个崩溃的案例。如果我们能向模糊测试器添加反馈，那么我们就可以识别出做了一些有趣事情的测试用例。我们将这些有趣的测试用例循环回我们的测试用例集中，进行进一步的变异。</p>
<p>我们可以从许多不同的来源获取这些信息。对于这个示例，让我们使用 <code>fuzz_target/target_dbg</code> 二进制文件，这是我们目标的调试输出版本。通过查看这个调试输出，我们可以开始识别有趣的案例。如果一个测试用例让我们得到了我们之前没有见过的调试输出，那么我们可以认为它是有趣的，值得进一步迭代。</p>
<p>LibAFL 库中没有这种反馈的现有实现，所以我们必须自己制作！如果你想自己尝试，我们在仓库中提供了一个模板文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/exec_fuzzer_stderr_template">.&#x2F;exec_fuzzer_stderr_template&#x2F;</a></p>
<p>LibAFL 仓库提供了一个 <code>StdErrObserver</code> 结构，我们可以将其与我们的 <code>CommandExecutor</code> 一起使用。这个观察者将允许我们的自定义反馈结构接收我们运行的 <code>stderr</code> 输出。我们所要做的就是创建一个实现 <code>Feedback</code> 特性的 <code>is_interesting</code> 方法的结构，我们就应该可以开始了。在该方法中，我们提供了状态、变异输入、观察者。我们只需要从 StdErrObserver 获取调试输出，并确定我们是否到达了新的位置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Feedback&lt;S&gt; <span class="keyword">for</span> <span class="title class_">NewOutputFeedback</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: UsesInput + HasClientPerfMonitor,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">        _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">        _input: &amp;S::Input,</span><br><span class="line">        observers: &amp;OT,</span><br><span class="line">        _exit_kind: &amp;ExitKind</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">        OT: ObserversTuple&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 Ok(false) 对于不有趣的输入</span></span><br><span class="line">        <span class="comment">// 返回 Ok(true) 对于有趣的输入</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我鼓励你自己尝试实现这个反馈。你可能想要找到一些启发式方法来忽略无帮助的调试消息。我们希望避免报告太多的输入作为有用的，这样我们就不会过度填充我们的输入语料库。输入语料库是我们用于生成新测试用例的输入集。如果语料库中有太多实际上并没有帮助我们挖掘胜利的输入，我们将浪费大量时间。理想情况下，我们希望这些输入尽可能小且运行速度快，同时在我们的目标中执行独特的路径。</p>
<p>在我们的解决方案中，我们简单地保持一组已看到的哈希。如果我们看到它导致了一个独特的哈希，我们就会报告输入是有趣的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer_stderr/src/main.rs">.&#x2F;exec_fuzzer_stderr&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">            _input: &amp;S::Input,</span><br><span class="line">            observers: &amp;OT,</span><br><span class="line">            _exit_kind: &amp;ExitKind</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">           <span class="keyword">where</span> EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">                 OT: ObserversTuple&lt;S&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">observer</span> = observers.match_name::&lt;StdErrObserver&gt;(&amp;<span class="keyword">self</span>.observer_name)</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;A NewOutputFeedback needs a StdErrObserver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            hasher.<span class="title function_ invoke__">write</span>(&amp;observer.stderr.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">contains</span>(&amp;hash) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">insert</span>(hash);</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这最终非常快地找到了“有趣”的输入，并迅速增加了我们的输入语料库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 308, objectives: 0, executions: 4388, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 0, executions: 4423, exec/sec: 2.520k</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 1, executions: 4423, exec/sec: 2.497k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 310, objectives: 1, executions: 4532, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 311, objectives: 1, executions: 4629, exec/sec: 2.521k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率反馈"><a href="#代码覆盖率反馈" class="headerlink" title="代码覆盖率反馈"></a>代码覆盖率反馈</h2><p>依赖程序的正常副作用（如调试输出、系统交互等）并不是深入探索目标的可靠方法。使用这种反馈，我们可能会错过许多有趣的特性。许多现代模糊测试器的首选反馈是“代码覆盖率”。通过观察哪些代码块正在被执行，我们可以了解哪些输入暴露了有趣的逻辑。</p>
<p>然而，收集这些信息并不总是直接的。如果你可以访问源代码，你可能可以使用编译器来为代码添加这些信息。如果没有，你可能必须通过二进制修改、仿真或其他来源动态地为你的目标添加工具。</p>
<p>AFL++ 提供了一个版本的 clang，用于编译器级别的工具，提供代码覆盖率反馈。LibAFL 可以观察这种工具生成的信息，我们可以使用它作为反馈。我们有一个使用 <code>afl-clang-fast</code> 构建的目标。有了这个构建（ <code>target_instrumented</code>），我们可以使用 LibAFL 的 <code>ForkserverExecutor</code> 与我们的工具目标进行通信。<code>HitcountsMapObserver</code> 可以使用共享内存来接收每次运行的覆盖率信息。</p>
<p>你可以在这里看到我们模糊测试器的代码。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_fuzzer/src/main.rs">.&#x2F;aflcc_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem_provider</span> = UnixShMemProvider::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem</span> = shmem_provider.<span class="title function_ invoke__">new_shmem</span>(MAP_SIZE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// 将 id 写入环境变量以供 forkserver 使用</span></span><br><span class="line">        shmem.<span class="title function_ invoke__">write_to_env</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shmembuf</span> = shmem.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line">        <span class="comment">// 基于该缓冲区构建观察者，与目标共享</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">edges_observer</span> = <span class="keyword">unsafe</span> &#123;HitcountsMapObserver::<span class="title function_ invoke__">new</span>(StdMapObserver::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shared_mem&quot;</span>, shmembuf))&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用观察到的覆盖率来反馈基于获得最大覆盖率</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">feedback</span> = MaxMapFeedback::<span class="title function_ invoke__">tracking</span>(&amp;edges_observer, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 这次我们可以使用 fork 服务器执行器，它使用 instrumented in fork server</span></span><br><span class="line">    <span class="comment">// 它通过分叉部分实例化的过程而不是每次从头开始，从而获得更多的每秒执行次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_instrumented&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">        .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>编译的 fork 服务器还应该减少我们需要实例化运行的时间，通过分叉部分实例化的过程而不是从头开始。这应该抵消我们工具的一些成本。</p>
<p>执行时，我们的模糊测试器迅速找到了新的过程路径，建立了我们有趣的案例语料库，并指导我们的模糊测试器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan aflcc_fuzzer]$ ./target/release/aflcc_fuzzer</span><br><span class="line"></span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 0, executions: 19152, exec/sec: 1.823k</span><br><span class="line">[Objective #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.762k</span><br><span class="line">[Stats #0] run time: 0h-0m-11s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.723k</span><br><span class="line">[Testcase #0] run time: 0h-0m-11s, clients: 1, corpus: 101, objectives: 1, executions: 20250, exec/sec: 1.821k</span><br></pre></td></tr></table></figure>

<h2 id="自定义变异"><a href="#自定义变异" class="headerlink" title="自定义变异"></a>自定义变异</h2><p>到目前为止，我们一直在使用 <code>havoc_mutations</code>，你可以看到这里是一组对许多目标都非常好的变异。</p>
<p><a href="https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296">https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296</a></p>
<p>这些变异中的许多对我们的目标来说是浪费的。为了到达易受攻击的 <code>uid_to_name</code> 函数，输入首先必须通过 <code>valid_uid</code> 检查。在这个检查中，范围之外的字符 <code>A-Za-z0-9\-_</code> 被拒绝。许多 <code>havoc_mutations</code>，例如 <code>BytesRandInsertMutator</code>，将引入不在该范围内的字符。这导致许多测试用例被浪费。</p>
<p>有了关于我们目标的这些知识，我们可以使用一个自定义变异器，它只会在所需的范围内插入新的字节。实现 <code>Mutator</code> 特性很简单，我们只需要提供一个 <code>mutate</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;I, S&gt; Mutator&lt;I, S&gt; <span class="keyword">for</span> <span class="title class_">AlphaByteSwapMutator</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        I: HasBytesVec,</span><br><span class="line">        S: HasRand,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                return Ok(MutationResult::Mutated) when you mutate the input</span></span><br><span class="line"><span class="comment">                or Ok(MutationResult::Skipped) when you don&#x27;t</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想自己尝试这个，欢迎使用 <code>aflcc_custom_mut_template</code> 作为起点。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_mut_template/">.&#x2F;aflcc_custom_mut_template&#x2F;</a></p>
<p>在我们的解决方案中，我们使用一组变异器，包括我们的新 <code>AlphaByteSwapMutator</code> 和一些现有的变异器。这个集合应该会产生更多的有效测试用例，使其到达 <code>uid_to_name</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们将指定我们的自定义变异器，以及另外两个有助于增长或缩小的变异器</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            tuple_list!(</span><br><span class="line">                AlphaByteSwapMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesDeleteMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesInsertMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            ),</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>然后在我们的变异器中，我们使用状态的随机源来选择位置，并从一组有效字符中选择一个新的字节。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里我们应用我们的随机变异</span></span><br><span class="line">            <span class="comment">// 对于我们的目标，简单地交换一个字节应该是有效的</span></span><br><span class="line">            <span class="comment">// 只要我们的新字节是 0-9A-Za-z 或 &#x27;-&#x27; 或 &#x27;_&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空输入</span></span><br><span class="line">            <span class="keyword">if</span> input.<span class="title function_ invoke__">bytes</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择一个随机字节</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte</span>: &amp;<span class="keyword">mut</span> <span class="type">u8</span> = state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(input.<span class="title function_ invoke__">bytes_mut</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不要替换标签字符 &#x27;&#123;&#123;&#125;&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> *byte == <span class="string">b&#x27;&#123;&#x27;</span> || *byte == <span class="string">b&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在我们可以将该字节替换为一个已知好的字节</span></span><br><span class="line">            *byte = *state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(&amp;<span class="keyword">self</span>.good_bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 技术上我们应该说“跳过”如果我们用它自己替换一个字节，但这现在没问题</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Mutated)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>就是这样！自定义变异器与系统的其余部分无缝协作。能够像这样快速调整模糊测试器是适应目标的好方法。结合性能测量，这样的实验可以帮助我们快速迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 76, objectives: 1, executions: 2339, exec/sec: 1.895k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.933k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.928k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 78, objectives: 1, executions: 2392, exec/sec: 1.933k</span><br></pre></td></tr></table></figure>

<h2 id="示例问题"><a href="#示例问题" class="headerlink" title="示例问题"></a>示例问题</h2><p>到这一点，我们有一个单独的目标，你可能想要尝试！它是一个包含一个小迷宫的程序，并给你一个机会创建一个模糊测试器，使用一些自定义反馈或变异来更好地遍历迷宫并发现崩溃。尝试我们在这里介绍的一些概念，并看看你的模糊测试器有多快可以解决迷宫。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/maze_target/">.&#x2F;maze_target&#x2F;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[jordan maze_target]$ ./maze -p</span><br><span class="line"></span><br><span class="line">██████████████</span><br><span class="line">█.██......█ ██</span><br><span class="line">█....██ █.☺  █</span><br><span class="line">██████  █ ██ █</span><br><span class="line">██   ██████  █</span><br><span class="line">█  █  █     ██</span><br><span class="line">█ ███   ██████</span><br><span class="line">█  ███ ██   ██</span><br><span class="line">██   ███  █  █</span><br><span class="line">████ ██  ███ █</span><br><span class="line">█    █  ██ █ █</span><br><span class="line">█ ████ ███ █ █</span><br><span class="line">█          █  </span><br><span class="line">████████████</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### #### #</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #...@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-2s, clients: 1, corpus: 49, objectives: 0, executions: 5745, exec/sec: 2.585k</span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### ####@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #....#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-3s, clients: 1, corpus: 50, objectives: 0, executions: 8892, exec/sec: 2.587k</span><br></pre></td></tr></table></figure>

<h2 id="更快地进行模糊测试"><a href="#更快地进行模糊测试" class="headerlink" title="更快地进行模糊测试"></a>更快地进行模糊测试</h2><h2 id="持久模糊测试器"><a href="#持久模糊测试器" class="headerlink" title="持久模糊测试器"></a>持久模糊测试器</h2><p>在前面的示例中，我们使用了 <code>ForkserverExecutor</code>，它与 <code>afl-clang-fast</code> 插入到我们目标中的 fork 服务器一起工作。虽然 fork 服务器通过减少每个目标进程的启动时间给了我们很大的速度提升，但我们仍然需要为每个测试用例创建一个新进程。如果我们可以在一个进程中运行多个测试用例，我们可以大大加快我们的模糊测试。在一个目标进程中运行多个测试用例通常被称为“持久模式”模糊测试。</p>
<p>正如 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/61e27c6b54f7641a168b6acc6ecffb1754c10918/docs/fuzzing_in_depth.md?plain=1#L371">AFL++ 文档</a>中所说：</p>
<blockquote>
<p>基本上，如果你不以持久模式对目标进行模糊测试，那么你就是在业余地进行模糊测试，而不是专业地进行模糊测试。</p>
</blockquote>
<p>一些目标与持久模式不兼容。每次运行都会改变大量全局状态的任何内容都可能遇到麻烦，因为我们希望每个测试用例尽可能独立运行。即使对于适合持久模式的目标，我们通常也需要为目标代码创建一个框架。这个框架只是我们编写的一些代码，用于调用目标进行模糊测试。<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md">AFL++ 文档中关于 LLVM 的持久模式</a>是编写这些类型框架的一个很好的参考。</p>
<p>当我们创建了这样的框架时，插入的 fork 服务器将检测到持久的能力，甚至可以使用共享内存来提供测试用例。LibAFL 的 <code>ForkserverExecutor</code> 可以让我们利用这些持久框架。</p>
<p>使用持久框架的模糊测试器与我们之前的模糊测试器没有太大变化。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/persistent_fuzzer/src/main.rs">.&#x2F;persistent_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>主要变化在于告诉我们的 <code>ForkServerExecutor</code> 它 <code>is_persistent(true)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_persistent&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">is_persistent</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">            .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><code>ForkserverExecutor</code> 负责使这一切发生。我们的大部分工作都投入到实际创建一个有效的框架中！如果你想尝试自己制作，我们已经为你准备了一些模板，让你开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent_template.c">.&#x2F;fuzz_target&#x2F;target_persistent_template.c</a></p>
<p>在我们的框架中，我们要注意每次运行后重置状态，以便我们尽可能接近原始状态。任何修改的全局变量、堆分配或运行的副作用，可能会改变未来运行的行为，需要被撤销。未能清除程序状态可能导致误报或不稳定。如果我们希望这个模糊测试器的成功测试用例也能使原始目标崩溃，那么我们需要尽可能地模拟原始目标的行为。</p>
<p>有时，模拟原始目标并不值得，而是使用我们的框架来针对更深层次的表面。例如，在我们的目标中，我们可以直接针对 <code>uid_to_name</code> 函数，然后在以后将解决方案转换为原始目标的解决方案。我们还会希望在我们的框架中调用 <code>valid_uid</code>，以确保我们不会报告永远不会对我们的原始目标起作用的误报。</p>
<p>你可以在这里检查我们的持久框架；我们选择为每行反复调用 <code>process_line</code> 并注意清理我们自己。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent.c">.&#x2F;fuzz_target&#x2F;target_persistent.c</a></p>
<p>在那里之前，我们看到了大约每秒 2k 次执行的模糊测试器，使用代码覆盖率反馈，现在我们看到大约每秒 5k 或 6k，仍然只有一个客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 171, objectives: 4, executions: 95677, exec/sec: 5.826k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.860k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.821k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.863k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.798k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.866k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.855k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.867k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.853k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 176, objectives: 4, executions: 98488, exec/sec: 5.866k</span><br></pre></td></tr></table></figure>

<h2 id="进程内模糊测试器"><a href="#进程内模糊测试器" class="headerlink" title="进程内模糊测试器"></a>进程内模糊测试器</h2><p>使用 AFL++ 的编译器和 fork 服务器并不是实现一个进程中多个测试用例的唯一方法。LibAFL 是一个极其灵活的库，支持各种场景。<code>InProcessExecutor</code> 允许我们在与我们的模糊测试逻辑相同的进程中直接运行测试用例。这意味着如果我们能以某种方式与我们的目标链接，我们就可以在同一进程中进行模糊测试。</p>
<p>LibAFL 的多功能性意味着我们可以将我们的整个模糊测试器构建为库，我们可以将其链接到我们的目标中，甚至可以动态地预加载到我们的目标中。LibAFL 甚至支持 <code>nostd</code>（不依赖于操作系统或标准库的编译），因此我们可以将我们的整个模糊测试器视为一个 blob 注入到我们目标的环境。</p>
<p>在我们的示例中，我们将我们的模糊测试器与我们的目标构建为静态库，并使用 Rust 的 FFI 直接调用 C 代码。</p>
<p>通过提供一个 <code>build.rs</code> 文件来构建我们的模糊测试器并使其与我们的目标链接，Rust 编译将使用该文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/inproc_fuzzer/build.rs">.&#x2F;inproc_fuzzer&#x2F;build.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_dir</span> = <span class="string">&quot;../fuzz_target&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_lib</span> = <span class="string">&quot;target_libfuzzer&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制我们链接文件 &#x27;libtarget_libfuzzer.a&#x27;</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;</span>, &amp;target_dir);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=static:+whole-archive=&#123;&#125;&quot;</span>, &amp;target_lib);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=build.rs&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了工具来包装 clang 编译器，如果你希望创建一个编译器，它将自动将你的模糊测试器注入到目标中。你可以在 LibAFL 示例中看到这一点。</p>
<p>我们还需要一个框架来处理这个目标，这样我们就可以将测试用例作为缓冲区传递，而不是让目标从 <code>stdin</code> 读取行。我们将使用 <code>libfuzzer</code> 使用的公共接口，这让我们创建一个名为 <code>LLVMFuzzerTestOneInput</code> 的函数。LibAFL 甚至有一些助手函数可以为我们执行 FFI 调用。</p>
<p>我们的框架可以与我们为持久模式模糊测试创建的框架非常相似。我们还要注意与持久模式模糊测试中相同的全局状态或内存泄漏，这些可能会使我们的模糊测试不稳定。同样，如果你想要自己制作框架，我们有一个模板供你参考。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_libfuzzer_template.c">.&#x2F;fuzz_target&#x2F;target_libfuzzer_template.c</a></p>
<p>在目标中定义了 <code>LLVMFuzzerTestOneInput</code> 并制作了静态库后，我们的模糊测试器可以直接调用框架进行每个测试用例。我们定义了一个 <code>harness</code> 函数，我们的执行器将使用测试用例数据调用该函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架</span></span><br><span class="line">        <span class="comment">// 调用 libfuzzer 风格的框架</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="comment">// 这只是一些不错的调用 libfuzzer C 函数的调用</span></span><br><span class="line">            <span class="comment">// 但我们不需要使用 libfuzzer 框架来进行进程内模糊测试</span></span><br><span class="line">            <span class="comment">// 我们可以调用任何链接的函数，只要它是一个框架</span></span><br><span class="line">            <span class="title function_ invoke__">libfuzzer_test_one_input</span>(buf);</span><br><span class="line">            <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = InProcessExecutor::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> harness,</span><br><span class="line">            tuple_list!(edges_observer),</span><br><span class="line">            &amp;<span class="keyword">mut</span> fuzzer,</span><br><span class="line">            &amp;<span class="keyword">mut</span> state,</span><br><span class="line">            &amp;<span class="keyword">mut</span> restarting_mgr,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这种与 libfuzzer 框架的轻松互操作性很好，我们再次看到比我们之前的模糊测试器有巨大的速度提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan inproc_fuzzer]$ ./target/release/inproc_fuzzer</span><br><span class="line"></span><br><span class="line">启动中</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-16s, clients: 2, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">                  (CLIENT) corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000, edges: 0/37494 (0%)</span><br><span class="line">...</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k, edges: 136/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k, edges: 137/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k</span><br><span class="line">                  (CLIENT) corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k, edges: 137/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-20s, clients: 2, corpus: 103, objectives: 6, executions: 106626, exec/sec: 28.32k</span><br></pre></td></tr></table></figure>

<p>在这个模糊测试器中，我们还在利用 LibAFL 提供的一个非常重要的工具：低级消息传递（LLMP）。这提供了多个客户端之间的快速通信，并让我们有效地将模糊测试扩展到多个核心甚至多台机器。<code>setup_restarting_mgr_std</code> 辅助函数创建了一个事件管理器，该管理器将管理客户端，并在它们遇到崩溃时重新启动它们。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">monitor</span> = MultiMonitor::<span class="title function_ invoke__">new</span>(|s| <span class="built_in">println!</span>(<span class="string">&quot; &#123;s&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们使用一个重新启动管理器，每次崩溃时都会重新启动</span></span><br><span class="line">        <span class="comment">// 我们的进程</span></span><br><span class="line">        <span class="comment">// 这将设置一个主机管理器，我们将不得不启动其他进程</span></span><br><span class="line">        <span class="keyword">let</span> (state, <span class="keyword">mut</span> restarting_mgr) = <span class="title function_ invoke__">setup_restarting_mgr_std</span>(monitor, <span class="number">1337</span>, EventConfig::<span class="title function_ invoke__">from_name</span>(<span class="string">&quot;default&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法设置重启器！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有客户端将从上面的调用中返回</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;我们是客户端！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种速度提升很重要，可以使你找到重要的漏洞或找不到。另外，在冬天让你的房间变暖一些感觉很好。</p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>当然，并不是所有的目标都很容易与链接或使用编译器进行工具化。在这些情况下，LibAFL 提供了一些有趣的工具，如 <code>libafl_frida</code> 或 <code>libafl_nyx</code>。在下一个示例中，我们将使用 LibAFL 的修改版 QEMU 为我们没有内置工具化的二进制文件提供代码覆盖率反馈。修改版的 QEMU 将向我们的模糊测试器公开代码覆盖率信息以进行反馈。</p>
<p>设置将类似于我们的进程内模糊测试器，但现在我们的框架将负责在目标中运行仿真器。默认情况下，仿真器状态不会为你重置，你将希望重置每次运行之间更改的任何全局状态。</p>
<p>如果你想自己尝试，请参阅<a href="https://docs.rs/libafl_qemu/0.10.1/libafl_qemu/emu/struct.Emulator.html">仿真器文档</a>，并随时从我们的模板开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/qemu_fuzzer_template">.&#x2F;qemu_fuzzer_template&#x2F;</a></p>
<p>在我们的解决方案中，我们首先执行一些初始化，直到一个断点，然后保存堆栈和返回地址。我们将不得不每次运行重置堆栈，并在返回地址上放置一个断点，以便我们可以在调用后停止。我们还在目标中映射一个区域，可以放置我们的输入。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(mainptr);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pc</span>: GuestReg = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Pc).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">remove_breakpoint</span>(mainptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 ret 地址，以便我们可以使用它并停止</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">retaddr</span>: GuestAddr = emu.<span class="title function_ invoke__">read_return_address</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(retaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">savedsp</span>: GuestAddr = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Sp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在让我们在目标中映射一个区域，我们将用于输入。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inputaddr</span> = emu.<span class="title function_ invoke__">map_private</span>(<span class="number">0</span>, <span class="number">0x1000</span>, MmapPerms::ReadWrite).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Input page @ &#123;inputaddr:#x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在在框架本身中，我们将输入并将其写入目标，然后开始在目标函数中执行。这次我们直接执行 <code>uid_to_name</code> 函数，并使用一个变异器，该变异器不会添加任何 <code>valid_uid</code> 会停止的无效字符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">len</span> = buf.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制我们的输入大小</span></span><br><span class="line">            <span class="keyword">if</span> len &gt; <span class="number">1024</span> &#123;</span><br><span class="line">                buf = &amp;buf[<span class="number">0</span>..<span class="number">1024</span>];</span><br><span class="line">                len = <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将我们的测试用例写入内存，以 null 终止</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr, buf);</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr + (len <span class="keyword">as</span> <span class="type">u64</span>), <span class="string">b&quot;\0\0\0\0&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 根据需要重置寄存器</span></span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Pc, parseptr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Sp, savedsp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_return_address</span>(retaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Rdi, inputaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行直到我们的返回地址断点</span></span><br><span class="line">            <span class="comment">// 或崩溃</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果我们没有崩溃，我们很好</span></span><br><span class="line">            ExitKind::<span class="literal">Ok</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这种仿真可以非常快，特别是如果我们可以在每次运行之间不必重置大量状态。通过在这里针对更深层的函数，我们可能会很快达到崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 54, objectives: 0, executions: 33349, exec/sec: 31.56k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 32.85k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 31.59k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 0, executions: 36124, exec/sec: 32.87k</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 1, executions: 36124, exec/sec: 28.73k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了一些有用的助手，如 <code>QemuAsanHelper</code> 和 <code>QemuSnapshotHelper</code>。甚至还有支持全系统仿真，而不是用户模式仿真。能够有效地使用仿真器进行模糊测试可以打开一个全新的目标世界。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>我们从一些初始输入开始，然后简单地变异它们的方法对于某些目标来说可能非常有效，但对于更复杂的输入则不那么有效。如果我们从一个像这样的 javascript 输入开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现有的变异可能会产生以下结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>\<span class="title function_">x00</span> (a &lt;\u003c b) &#123;</span><br><span class="line">    <span class="title function_">somefu</span>(a;;;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能会在解析器中发现一些漏洞，但不太可能在任何 javascript 引擎中发现更深层次的漏洞。如果我们想要锻炼引擎本身，我们将希望主要产生有效的 javascript。这是生成的一个很好的用例！通过定义一个语法，描述有效的 javascript 看起来像什么，我们可以生成大量的测试用例来对抗引擎。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"></p>
<p>正如你在上面的图表中看到的，仅靠生成我们就不再使用变异+反馈循环。有许多成功的模糊测试器仅靠生成就获得了胜利（<a href="https://github.com/googleprojectzero/domato">domato</a>、<a href="https://boofuzz.readthedocs.io/en/stable/">boofuzz</a>、<a href="https://www.atredis.com/blog/2022/03/29/veni-midi-vici-conquering-cve-2022-22657-and-cve-2022-22664">一堆奇怪的 midi 文件</a>），但我们希望在我们的模糊测试中有一些形式的反馈和进展。</p>
<p>为了在我们的生成中利用反馈，我们可以创建一个生成数据的中间表示（IR）。然后我们可以将有趣的案例反馈到我们的输入中，以便进一步变异。</p>
<p>所以我们之前的 javascript 可以像这样表达为令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (var a), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func,</span><br><span class="line">            (arg_list (var a))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们对这种标记版本的变异可以做的事情包括用其他有效的令牌替换令牌或向树添加更多节点，创建一个稍微不同的输入。然后我们可以像以前一样使用这些 IR 输入和变异，结合代码覆盖率反馈。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
<p>现在对 IR 的变异可能会产生像这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (const 0), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func</span><br><span class="line">            (arg_list</span><br><span class="line">                (func_call some_func,</span><br><span class="line">                    (arg_list ((var a), (var a)))</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这将呈现为有效的 javascript，并且如果它产生有趣的反馈，可以进一步变异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(<span class="title function_">somefunc</span>(a,a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 提供了一些很棒的工具，帮助你拥有一个带有反馈的生成模糊测试器。LibAFL 中包含了一个 <a href="https://github.com/nautilus-fuzz/nautilus">Nautilus 模糊测试器</a>的版本。为了使用它与我们的例子，我们首先定义一个语法，描述我们目标的有效输入是什么样的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/grammar.json">.&#x2F;aflcc_custom_gen&#x2F;grammar.json</a></p>
<p>有了 LibAFL，我们可以将这个语法加载到一个 <code>NautilusContext</code> 中，我们可以使用它进行生成。我们使用 <code>InProcessExecutor</code>，在我们的框架中，我们接受一个 <code>NautilusInput</code>，我们将其呈现为字节并传递给我们的 <code>LLVMFuzzerTestOneInput</code>。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/src/main.rs">.&#x2F;aflcc_custom_gen&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不能使用普通的字节变异，所以我们使用在我们生成器树上工作的变异</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">        tuple_list!(</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRecursionMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>我们还需要生成一些初始 IR 输入并指定要使用的变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">must_load_initial_inputs</span>() &#123;</span><br><span class="line">        <span class="comment">// 与从初始语料库加载不同，我们将生成 9 个 NautilusInputs 的初始语料库</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">generator</span> = NautilusGenerator::<span class="title function_ invoke__">new</span>(&amp;genctx);</span><br><span class="line">        state.<span class="title function_ invoke__">generate_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> generator, &amp;<span class="keyword">mut</span> restarting_mgr, <span class="number">9</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Created initial inputs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>有了这一切，我们可以运行并获得生成、代码覆盖率和进程内执行的结合优势。为了进一步改进这一点，我们可以随着对我们目标的更好理解而改进我们的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                  (CLIENT) corpus: 145, objectives: 2, executions: 40968, exec/sec: 1.800k, edges: 167/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k, edges: 167/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k, edges: 167/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-27s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.755k</span><br></pre></td></tr></table></figure>

<p>注意，我们保存的解决方案只是序列化的 <code>NautilusInputs</code>，并且在原始目标上使用时将不起作用。我们创建了一个单独的项目，将这些解决方案呈现为字节。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/gen_solution_render/src/main.rs">.&#x2F;gen_solution_render&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: NautilusInput = NautilusInput::<span class="title function_ invoke__">from_file</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tree_depth</span> = <span class="number">0x45</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">genctx</span> = NautilusContext::<span class="title function_ invoke__">from_file</span>(tree_depth, grammarpath);</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;PLvkLizOcGccywcS&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">&#123;&#123;EGgkWs-PxeqpwBZK&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;hlNeoKiwMTNfqO_h&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0 | ../fuzz_target/target</span><br><span class="line"></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="示例问题-2"><a href="#示例问题-2" class="headerlink" title="示例问题 2"></a>示例问题 2</h2><p>这给我们带来了第二个带回家的问题！我们有一个聊天客户端，它容易受到许多问题的影响。通过好好利用生成和&#x2F;或仿真，可以使对二进制文件的模糊测试变得更容易。在你发现一些嘈杂的漏洞时，你可能希望在你的模糊测试器中避免这些路径，或者在你的目标中修补这些漏洞。漏洞经常会掩盖其他漏洞。你可以在这里找到目标。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/chat_target">.&#x2F;chat_target&#x2F;</a></p>
<p>以及一个可以模糊测试聊天客户端的示例解决方案。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/chat_solution/src/main.rs">.&#x2F;chat_solution&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Ping from    16937944: DDAAAATt&#x27;AAAAPt&#x27;%222%%%%%%%9999&#x27;pRR9&amp;&amp;%%%%%%2Tt&#123;&#x27;&#x27;pRt&#x27;%99999999&#x27;pRR9&amp;&amp;&amp;%%%%%%999AATt&#x27;%&amp;&#x27;pRt&#x27;%TTTTTTTTTTTTTT9999999&#x27;a%&#x27;AAATTt&#x27;% --</span><br><span class="line">-- Error sending message: Bad file descriptor --</span><br><span class="line">[Stats #0] run time: 0h-0m-5s, clients: 1, corpus: 531, objectives: 13, executions: 26752, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-5s, clients: 1, corpus: 532, objectives: 13, executions: 26760, exec/sec: 0.000</span><br><span class="line">-- Ping from    16937944: DDAAAATT&#x27;%&#x27;aRt&#x27;%9999&#x27;pRRT&#x27;%&#x27;LLLLLLLLLLLa%&#x27;nnnnnmnnnT&#x27;AA&#x27;&#x27;&#x27;</span><br><span class="line">A&#x27;&#x27;p%&#x27;&#x27;A9999&#x27;pRRT&#x27;pRR -- </span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个研讨会的目标是展示 LibAFL 的多功能性，并鼓励它的使用。希望这些示例能激发你一些关于如何将自定义模糊测试器整合到你的一些目标中的想法。如果你有任何问题或发现我们示例中的任何问题，请让我们知道。或者，如果你有一个有趣的目标，并希望我们为你找到漏洞，请与我们联系。</p>
<h2 id="课程推广"><a href="#课程推广" class="headerlink" title="课程推广"></a>课程推广</h2><p>再次感谢你的阅读！如果你喜欢这类内容，你可能会对我们的课程“Practical Symbolic Execution for VR and RE”感兴趣，你将学习如何为以下内容创建你自己的符号执行框架：逆向工程、去混淆、漏洞检测、漏洞开发等。下一次公开课程将在 2024 年 2 月作为 ringzer0 的 BOOTSTRAP24 的一部分。我们也可以根据要求提供私人课程。</p>
<p>更多信息在这里。<br><a href="https://ringzer0.training/trainings/practical-symbolic-execution.html">https://ringzer0.training/trainings/practical-symbolic-execution.html</a></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1566943528908-J56DPCZRQ9SVG4TFPP27/WhiskeyBirdTextOverlayWhite.png?format=1500w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1701794251926-ZA8KEPB15YFCJ0QRW122/johannes-weber-wcspluM_Iqw-unsplash.jpg?format=1000w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
        <category>翻译文章</category>
      </categories>
      <tags>
        <tag>LibAFL</tag>
      </tags>
  </entry>
  <entry>
    <title>xp系统上做漏洞检测</title>
    <url>/2024/09/05/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/XP%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%81%9A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>rust语言与数据导向编程</p>
<span id="more"></span>
<p>一个安全网课网站：<a href="http://www.securitytube.net/groups?operation=view&groupId=5">SecurityTube</a>，年久失修，唯一价值可能是参照上面找资源</p>
<p>比如上面的一个在 XP SP3 平台漏洞利用的课在油管上的地址：<a href="https://www.youtube.com/watch?v=f-1zIFb-zpw&list=PL6qa4C74KbMBo0BMM9ZdcFlDLkArwA3SF">Exploit Research Megaprimer</a></p>
<p>比如一个讲linux 汇编的课：<a href="https://www.youtube.com/watch?v=K0g-twyhmQ4&list=PLyqno_bgl3e-zLBZGdi_zsPQYPQUlZYe4">Assembly Primer For Hackers </a></p>
<p>但是这样的课或许不一定非要在这里学</p>
]]></content>
      <categories>
        <category>漏洞检测</category>
      </categories>
      <tags>
        <tag>xp系统</tag>
      </tags>
  </entry>
  <entry>
    <title>rust语言与数据导向编程</title>
    <url>/2023/12/05/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/rust%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>rust语言与数据导向编程</p>
<span id="more"></span>

<p>原文地址：<a href="https://kyju.org/blog/rustconf-2018-keynote/">https://kyju.org/blog/rustconf-2018-keynote/</a></p>
<p>这篇文章是关于 RustConf 2018 大会上的闭幕主题演讲的内容。以下是文章的主要内容翻译：</p>
<hr>
<p>我承诺在 RustConf 2018 的闭幕主题演讲中做两件事：</p>
<ol>
<li>我会将演讲的幻灯片放到网上。</li>
<li>我会在我的博客上发布演讲的长篇版本。</li>
</ol>
<p>​	2.a. 我实际上会为此目的创建一个博客。</p>
<p>……我花了该死的时间来做这件事。终于，我做到了我承诺会做的事情！</p>
<p>如果你还没有看到并且想看，你可以在这里看到我做的现场演讲。</p>
<p>演讲的幻灯片（有少量勘误）现在已经托管在这里。</p>
<p>所以，我在演讲中说我会发布一个可能更有趣的长篇版本，包括我无法在大约30分钟的时间槽中放入的内容。下面我包含的是我演讲的原始长篇版本，但我最初的意图并不是像这样发布。最初我想再整理一下，使其不那么像一堵文字墙，但当我开始做这件事时，我意识到我只是在完全重写它，以那种速度我永远不会发布它，而我 <em>承诺</em> 我会及时发布。</p>
<p>我对此并不满意，回想起来，我认为我为大约30分钟的演讲剪掉的很多东西可能是明智的剪掉的。我认为关于控制台开发的部分非常投机，并没有什么帮助，而最后关于语言边界特别困难的部分，虽然是真的，但有点离题。然而，人们似乎非常感兴趣，并且（非常正确地）提醒我我还没有发布这个，所以与其进一步拖延，我会给你我制作的非常轻微编辑的演讲文本版本。请记住，这是在我意识到我永远不会在30分钟内适应之前 :)。这是用非常非正式、对话的风格写的，因为这是为我演讲的素材。</p>
<p>不再赘述了……</p>
<hr>
<h2 id="RustConf-2018-演讲的草稿"><a href="#RustConf-2018-演讲的草稿" class="headerlink" title="RustConf 2018 演讲的草稿"></a>RustConf 2018 演讲的草稿</h2><p>这是我在 RustConf 2018 主题演讲中想要谈论的内容的非常粗略的大纲。</p>
<p>这次演讲假设你除了一些 Rust 的知识外，还知道一些 C++，并且有很多 C++ 代码示例，但我希望它们足够明显，不会分散那些可能不习惯 C++ 的人的注意力。</p>
<h2 id="演讲的基本论点："><a href="#演讲的基本论点：" class="headerlink" title="演讲的基本论点："></a>演讲的基本论点：</h2><p>Rust 通过设计，使某些编程模式比其他模式更痛苦。这是一件好事！事实证明，对于游戏开发来说，在 Rust 中最容易处理的模式与在 <em>任何</em> 语言中最容易处理的游戏开发模式非常相似。</p>
<p>不幸的是，我不得不以艰难的方式学到这一点！</p>
<p>Rust 极大地奖励了数据导向设计，具有简单、易于理解的所有权语义，这对于游戏开发来说是个好消息。我怀疑这通常也是正确的，不仅仅是对游戏开发！（但我能知道什么？）</p>
<h2 id="你为什么要听我说，我是谁？"><a href="#你为什么要听我说，我是谁？" class="headerlink" title="你为什么要听我说，我是谁？"></a>你为什么要听我说，我是谁？</h2><p>我是 Starbound 的首席程序员，我是 Chucklefish 最初的成员之一，当时我们都是通过 IRC 工作。当 Chucklefish 决定我们应该有一个人被称为“技术领导”时，我是技术领导。我仍然与 Chucklefish 有外围合作，但自从我回到美国后，我现在更独立地工作了。</p>
<p>但是，老实说，我不确定你 <em>应该</em> 听我说！我帮助发布了一个（1）完整的商业游戏，这次演讲的一些部分是基于我帮助制作的一个商业游戏的警示故事，关于什么 <em>不</em> 该做。</p>
<p>我绝对觉得你不应该根据我的建议做出任何……真正的 <em>成熟</em> 商业决策。我不能确定 Rust 是否适合你，或者你是否应该或不应该用 Rust 制作你的游戏，当然，可能还有更大的问题，这取决于你是独立开发者，你的个人技能水平和容忍度以及偏好，以及如果你是一家公司，你需要什么工具和引擎，中间件等。</p>
<p>我所能说的是，我个人将在未来可预见的时间内使用 Rust 进行游戏开发（和其他事情！），如果你想知道为什么，或者如果你已经决定你想使用 Rust 并想知道你将要面对什么，那么这次演讲可能很有用。</p>
<p>这次演讲将比我更喜欢的更……模糊。我通常更习惯于给出具体的非常技术性的建议，在那里我可以从第一原理几乎证明我的观点，但像架构建议或一般建议这样的事情可能永远不会那么明确。我确实认为这仍然是 _有用的_，这就是我为什么要做这件事（并且人们似乎感兴趣），但请记住：这都是我个人的看法，伙计。</p>
<h2 id="你-怎么-甚至用-Rust-制作游戏？"><a href="#你-怎么-甚至用-Rust-制作游戏？" class="headerlink" title="你 怎么 甚至用 Rust 制作游戏？"></a>你 <em>怎么</em> 甚至用 Rust 制作游戏？</h2><p>过去一年左右，我收到了很多问题，基本上在问：</p>
<blockquote>
<p>如何从零开始用 Rust 制作游戏？不，说真的……怎么做。我的意思是，我<br>可以看到你 <em>理论上</em> 怎么做，但不知何故当我尝试应用<br>我习惯的其他语言的模式时，我只是遇到很多问题？<br>我听说这被称为“与借用检查器战斗”，但……这似乎并没有真正 <em>帮助</em> 我。我做错了什么？</p>
</blockquote>
<p>或者，也许是像这样的：</p>
<blockquote>
<p>我可以看到如果你喜欢非常严格的控制，Rust 是很棒的，我可以看到它<br>被用于小型实用程序或安全性至关重要的地方，但它<br>看起来非常限制性！我真的看不出你如何在不到处遇到这些限制的情况下制作像游戏这样大的东西。你如何在不需要 Rc<RefCell> 和 Arc<Mutex> 的情况下构建像游戏这样的东西？</Mutex></RefCell></p>
</blockquote>
<p>这些问题（稻草人）当然是关于游戏的，但它们也反映了我见过的关于 Rust 的普遍情绪。如果不是很明显，我不同意这种情绪（毕竟我在 RustConf），我认为对我来说最好的方式是谈论为什么我不同意它，是通过谈论我所知道的，所以我将从游戏的角度来谈论这个问题。</p>
<p>这次演讲可以只是我走上讲台说“天啊，没那么难！数据导向设计！如果你在制作游戏，使用 ECS！……谢谢。”然后走下舞台，从某种角度来看，我确实觉得 <em>可以</em> 这么简单，但我认为这里有一个更重要的根本点，这就是这次演讲的内容。这个问题的非常非常简短的答案是：如果你忘记面向对象设计，而是只专注于你的游戏状态（或你正在制作的任何东西）的数据表示，并且你努力不使事情比它真正需要的更复杂，事情实际上可以相当简单！这次演讲将缓慢地向一个简单的 Rust 中的 ECS 实现工作，并尝试为每一步提供理由，但不是 <em>所有</em> 步骤都是必要的。我甚至不认为使用某种特定的设计模式如 ECS 是必不可少的，我认为更重要的更大的点是放下一些习惯，至少 <em>我</em> 有这些习惯，使事情比它们需要的更困难，尤其是在 Rust 中。</p>
<p>对一些人来说，我在这次演讲中所说的可能 _显而易见_。如果这对你来说都是显而易见的，那很好，但这些对我来说并不总是显而易见的。事实上，我之所以如此喜欢 Rust 的部分原因是，我并不是通过尝试用 Rust 构建游戏学到这些教训的，我大部分是在第一次尝试 Rust 之前，从我早期在 Starbound 中犯的错误中学到的。我需要有人来指责以展示什么 <em>不</em> 应该做，所以非常方便的是，我有一个如此好的例子在我的过去。</p>
<p>我肯定会重复其他人已经给出的一些建议。事实上，其中一些已经变得众所周知，几乎已经成为陈词滥调：继承是坏的，面向对象大多是坏的，ECS 设计是好的，等等。希望在这些 <em>是</em> 真的程度上，我提供了更多的证据，并描述了为什么这些在借用检查器的存在下尤其重要，但希望我也能给这些增加一些细微差别，这对其他想要用 Rust 进行游戏开发的人也会有所帮助。</p>
<h2 id="你怎么甚至制作游戏"><a href="#你怎么甚至制作游戏" class="headerlink" title="你怎么甚至制作游戏"></a>你怎么甚至制作游戏</h2><p>当然，这些问题只会在你尝试从头开始设计游戏架构时出现，当然，许多人实际上不会这样做。事实上，通常给独立开发者的建议是 <em>永远</em> 不要制作你自己的引擎，如果你使用像 Unity 或 Unreal 这样的引擎来制作你的游戏，很多这些决定将为你做出。</p>
<p>我绝对 <em>没有</em> 遵循这个建议。事实上，我认为 Starbound 直接违反了你通常给新独立开发者的每一条建议：</p>
<ul>
<li><p>不要制作你自己的引擎<br>(Starbound 基本上是在 SDL &#x2F; libogg &#x2F; libvorbis &#x2F; libfreetype 等之上用裸 C++ 编写的)</p>
</li>
<li><p>总是制作一个原型，并计划扔掉它<br>(我用来演示两周的代码与 1.0 版本是同一血统)</p>
</li>
<li><p>说真的，不要制作你自己的引擎，只使用 Unity &#x2F; Unreal &#x2F; Godot 等<br>(我们甚至没有使用 boost！事实上，在某个时候我们添加了我们自己的 c++17 类的版本，比如 std::optional 和 std::variant，因为当时比开始依赖 boost 更容易。我们还自己想出了一种系统来做 2D 纹理图集，因为我们找不到一种好的方法来做如此多小纹理的离线纹理图集，这些小纹理不容易分组)</p>
</li>
<li><p>你的第一款游戏应该是简单的，你应该制作一些简单的东西，你可以在短时间内发布。<br>(在 Starbound 中，你可以有一个玩家持有的物品，运行它自己的 Lua 脚本，这会影响玩家的物理属性，可以与其他物品和玩家拥有的能力合作，这些能力也有自己的脚本，也可以影响玩家的物理属性（同时），同时给玩家脚本化的状态效果，这些效果可以向大多数实体都有的通用状态数据库添加他们自己的自定义统计数据，这些统计数据也可以从脚本中控制。还有一个完整的糟糕的 DSL，用于绘制材料块，这些块在视觉上以任意复杂的方式连接在一起)</p>
</li>
</ul>
<p>我绝对不是想告诉任何人制作 <em>任何</em> 类似我制作的第一款商业游戏的东西，不要跟随我的脚步，我不认为我会推荐给任何人。然而，实际上有很多独立开发者不使用 Unreal &#x2F; Unity 风格的游戏引擎，而是使用更多的“库”风格的游戏引擎，他们只使用单个库来提供特定功能，或者使用主要提供渲染，音频和输入的小“框架”，并自己创建他们制作的游戏的基本结构。（我曾经有一个移植公司称这种“旧学校”开发风格，这让我非常沮丧）</p>
<ul>
<li><p>任何使用 XNA 或 MonoGame 制作的游戏。XNA &#x2F; MonoGame 肯定在单个包中提供了很多（渲染、声音、输入），但它们不决定游戏本身的架构。这包括 Terraria 和 Stardew Valley，只是举两个例子。</p>
</li>
<li><p>任何由 Jonathan Blow 制作的游戏（Braid, The Witness）</p>
</li>
<li><p>任何由 Zach Barth 制作的游戏（Zachtronics）。他曾表示，当他开始开发游戏时，他从一个裸事件循环（输入 &#x2F; 更新 &#x2F; 渲染）开始。（注意：我找不到这个的来源，所以我希望我没有误解他，我认为他在我现在找不到的采访中说过）</p>
</li>
<li><p>任何由 Supergiant 制作的游戏（Bastion, Transistor, Pyre）</p>
</li>
<li><p>完全在内部制作的 Chucklefish 游戏：显然 Starbound，还有 Wargroove（使用通用 C++ 引擎 halley 制作，但引擎的主要开发人员是 Wargroove 的主要开发人员）。</p>
</li>
<li><p>还有很多很多我没有列出的，许多 2D 游戏是这样制作的，一些 3D 游戏也是如此。有 <em>几十个</em> 我们，我告诉你。</p>
</li>
</ul>
<p>显然，如果我的建议不适用，你决定使用像 Unity 或 Unreal 这样决定了大部分游戏结构的有偏见的游戏引擎，那么我并不是试图说服你离开。显然，如果你使用其中之一，并且你很高兴，那么我不会试图说服你离开。显然，如果你使用其中之一，Rust 可能就不可能了，除了非常非常外围的事情，但老实说，我仍然认为最终 Rust 会找到进入这些商业主流游戏引擎产品的方式，只是时间问题。</p>
<p>不过，目前，最有可能使用 Rust 并发现这次演讲有用的人是其他从头开始的独立类型，以及一些在内部制作大量技术的 AAA 工作室（Ready at Dawn!, EA SEED!）。我也相信，迟早会有使用 Rust 的 Unity 或 UE 竞争对手！</p>
<p>那么好吧，假设你决定制作一款游戏，你 <em>不打算</em> 使用像 Unreal 或 Unity 这样决定大部分游戏结构的有偏见的游戏引擎，你决定使用 Rust，那么这样的东西会是什么样子？</p>
<h2 id="过去是如何制作游戏的"><a href="#过去是如何制作游戏的" class="headerlink" title="过去是如何制作游戏的"></a>过去是如何制作游戏的</h2><p>所以，在过去，游戏主要是以“数据导向”的方式工程化的，这纯粹是出于必要。当你的目标控制台有 128KB 的 RAM（SNES）时，就没有多少抽象的余地。我将把这个时代称为视频游戏开发的“行动回放”时代。如果你不知道，这些是作弊设备，有点像“游戏精灵”或“游戏鲨鱼”，如果你知道的话，你可以在每一帧修补游戏的 RAM 状态。“游戏精灵”和类似的设备允许你修补游戏卡带的 ROM，但“行动回放”设备实际上让你插入钩子到比如说，VBlank 处理程序，覆盖每一帧的实际内存值，以比如说给你无限生命等。</p>
<p>这之所以有效，是因为显然在 128KB 的 RAM 中，你不太可能有 malloc 的实现！。每一字节的存储都是非常宝贵的，所以大多数这个时代的游戏都是设计得非常可预测的手动管理它们整个游戏状态在内存中。在 NES &#x2F; SNES 时代，内存如此之少，通常图形表示你的游戏（瓦片，精灵）和你的逻辑表示你的游戏是相同的，如果你眯着眼睛看，你会看到“实体”结构，但通常游戏可以跟踪的“事物”的最大数量是如此之少，以至于没有足够的空间用于任何通用性。这有时也被称为游戏开发的“场外治愈力”时代，因为一旦你离开屏幕，游戏关卡的那部分通常就被遗忘了（敌人神奇地被治愈了）。</p>
<p>想象一下，如果你要为 NES 编写一个 Rust 游戏（可能真的很难，但不是不可能？至少不比 C 难，C 同样真的很难。我相当确定基本上所有 SNES 时代的游戏都是用汇编语言编写的。），你可能会定义一个单一的静态数据结构，像这个完全虚构的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">ProjectileType</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EnemyType</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EnemyBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Tile</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PlayerProjectile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> proj_type: ProjectileType,</span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> enemy_type: EnemyType,</span><br><span class="line">    <span class="keyword">pub</span> behavior: EnemyBehavior,</span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> player_pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> player_vel: Vector2&lt;<span class="type">i8</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> player_health: <span class="type">i8</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你想要屏幕上超过 4 个炮弹？不行，如果玩家发射更多，清除最旧的以腾出空间，或者等到它们击中</span></span><br><span class="line">    <span class="comment">// 某些东西或移出屏幕（像洛克人一样）。</span></span><br><span class="line">    <span class="keyword">pub</span> player_projectiles: [<span class="type">Option</span>&lt;PlayerProjectile&gt;; <span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有关卡数据都存储在这个常量内存块中。</span></span><br><span class="line">    <span class="keyword">pub</span> level_tiles: [[Tile; <span class="number">64</span>]; <span class="number">64</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏幕上有 8 个敌人，之后，你必须等待敌人消失才能生成更多（在 Kirby&#x27;s Adventure 中，这在工具辅助速通中被高度滥用）</span></span><br><span class="line">    <span class="keyword">pub</span> enemies: [Enemy; <span class="number">8</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过这种方式了解软件的工作原理，即使你这是一个虚构的例子。</p>
<p>这里需要注意的一件事是，由于每个 SNES 游戏很可能是用汇编语言编写的，几乎可以肯定没有“数据隐藏”这样的事情，游戏的整个状态在任何时候都可以被更新循环访问。</p>
<p>这种每个内存位置都很宝贵，对象被仔细地放置在其中的时代实际上持续了很长时间，至少一直到 N64。</p>
<p>让我们看另一个我比较熟悉的例子，它仍然牢固地处于这个时代，但其设计在我看来更接近现代游戏引擎。我最喜欢的游戏之一：Mario 64。Mario 64 很有趣，因为它是 3D 的，除了低多边形简单图形外，它真的 <em>那么</em> 不同于现代 3D 平台游戏吗？然而，它仍然牢固地处于“行动回放”时代的游戏，当你进入一个“游戏世界”（你可以像马里奥一样奔跑和跳跃）时，你可以可靠地告诉（或多或少）所有的关卡数据将生活在 N64 的广阔，豪华的 4 个 MB 的 ram 中。有一个可预测的内存块用于关卡几何，用于许多不同的关卡标志等，但游戏中的大部分动态内容都以通用的“实体”（或“对象”）的形式存在，就像现代游戏引擎一样。在 Mario 64 中，实体结构都是完全 608 字节长，并且有一个硬限制为 240 个（有时这有点少，比如在 Bowser in the Fire Sea 中，限制为 232 个对象）。</p>
<p>我们实际上不知道 Mario 64 是用什么语言编写的，但它 <em>可能</em> 是 C，所以这可能是一个时代，如果你有一台时间机器和一个强烈的愿望想要一个更好的系统语言来自未来，你可以很容易地使用 Rust 制作商业 Nintendo 64 游戏。让我们采取很多艺术自由，并想象这样一个游戏的结构，尽可能直接地翻译成 Rust：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityAnimation</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="comment">// 这个实体是否初始化并且活跃，或者它是否死亡并且可以被覆盖。</span></span><br><span class="line">    <span class="keyword">pub</span> initialized: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，这真的很有趣。在 Mario 64 中，所有实体被划分为“重要”和“不重要”的实体。重要的实体是</span></span><br><span class="line">    <span class="comment">// 像马里奥自己，硬币，敌人等。不重要的实体是像风效果或从马里奥的屁股踩出来的星星</span></span><br><span class="line">    <span class="comment">// 这样的效果。当游戏用完实体插槽时，它将删除不重要的实体以为重要的实体腾出空间。如果游戏</span></span><br><span class="line">    <span class="comment">// 试图创建超过 240 个重要的实体（或在 BitFS 中为 232），它将挂起。</span></span><br><span class="line">    <span class="keyword">pub</span> important: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> position: Vector3&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> rotation: Vector3&lt;<span class="type">f32</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我认为在真正的 Mario 64 中，大多数这样的事情是指针，但它们也可以很容易地是索引。这</span></span><br><span class="line">    <span class="comment">// 被证明是相当重要的。</span></span><br><span class="line">    <span class="keyword">pub</span> animation: EntityAnimation,</span><br><span class="line">    <span class="keyword">pub</span> behavior: EntityBehavior,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> visible: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> damage_mario_on_touch: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> home_in_on_mario: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用计时器，用于许多动画和游戏目的</span></span><br><span class="line">    <span class="keyword">pub</span> timer: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// 通用动作，对不同的实体类型有不同的用途</span></span><br><span class="line">    <span class="keyword">pub</span> action: <span class="type">u8</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多的东西...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldRenderGeometry</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldCollisions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> world_render_geometry: WorldRenderGeometry,</span><br><span class="line">    <span class="keyword">pub</span> world_collisions: WorldCollisions,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真的，不超过 240</span></span><br><span class="line">    <span class="keyword">pub</span> entities: [Entity; <span class="number">240</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而不是指针，我们存储一个索引到实体数组中。</span></span><br><span class="line">    <span class="keyword">pub</span> mario_entity: EntityIndex,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多的东西...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这些表示的具体细节并不是真的很重要，重要的是：</p>
<ul>
<li><p>游戏状态的表示（尽管这里被极大地简化了）在真正的游戏中仍然非常 _简单_。它非常可预测，并且易于 RAM 值戳，这里并没有真正的“抽象”，一切都是相当字面和</p>
</li>
<li><p>专门建造的。</p>
<ul>
<li><p>我们不能确定 N64 时代所有游戏使用的语言，但我们知道至少有一些标题肯定是 C（Shadows of the Empire），并且很可能在大多数情况下是 C。游戏结构都倾向于像 Mario 64 那样简单和可预测，你可以想象游戏状态主要被表示为全局 C 结构或结构数组。</p>
</li>
<li><p>我在这里猜测，但 <em>可能</em> 没有太多的“数据隐藏”，你可以想象这些游戏的结构更像是一个巨大的静态全局结构，包含“所有游戏状态”，对游戏的所有代码都是可见的。</p>
</li>
<li><p>偶尔有指向函数的指针，但似乎没有太多的面向对象的东西。似乎没有 vtables，甚至没有多少像 vtables 这样的东西，或者类似的东西。这可能是纯粹的猜测，并且肯定只是非专家的意见，但从我对 SNES - N64 时代标题的内存布局和设计的“广泛”研究来看，通常感觉你可以从数据格式中想象出构成引擎的基本、无聊、专门制作的 C 代码。</p>
</li>
</ul>
<p>好的，想象一下你将以与最初设计非常相似的方式编写 Mario 64，但是在 Rust 中。你将有效地编写一个巨大的、程序化的、单一用途的游戏引擎，在一个更漂亮的 C 中，但在其核心，仍然像 C。有效地你的游戏引擎是类似于（即将到来的戏剧性过度简化）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityAnimation</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="comment">// ... 见上文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldRenderGeometry</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldCollisions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="comment">// ... 见上文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 所有的游戏状态，道德上是一个全局变量。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = GameState &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// 每一次这个循环都是 1 帧，对于一个 60fps 的游戏来说是 16ms。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们一次捕获整个输入，在一帧的开始。甚至真的不需要像输入事件这样复杂的东西，因为在</span></span><br><span class="line">        <span class="comment">// 像 Mario 64 这样的东西中，真正发生的读取控制器状态就是读取控制器状态的特定内存区域。在这里，</span></span><br><span class="line">        <span class="comment">// 我们只是在帧的开始这样做，在真正的 Mario 64 中我相信每一帧都会在不同的系统中分布。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让我们有一系列函数根据上一个游戏状态和输入改变游戏状态</span></span><br><span class="line">        <span class="comment">// 我们将这种非常简单的模式命名为一个“系统”。</span></span><br><span class="line">        <span class="comment">// 设置马里奥内部的状态标志以开始跳跃，或者也许设置一个标志来表示你是否暂停。</span></span><br><span class="line">        <span class="title function_ invoke__">input_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pos += vel * dt; 应用重力。对所有实体进行碰撞检测和响应</span></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个实体运行实体逻辑，这可能会分派到 update_mario, update_baddies, update_platforms 等。</span></span><br><span class="line">        <span class="title function_ invoke__">entity_logic_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染当前的游戏状态。在 N64 时代，这在某些方面比现在简单得多，但即使在那时也可能仍然相当混乱和有状态的，所以也许我们的游戏状态包括加载的图形资源的状态。</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取实体的状态标志并触发新的音频，这和渲染一样混乱和有状态的。</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 VBlank</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vblank</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重复。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我不是推荐你以这种方式制作游戏！然而，即使你认为这 100% 是一个荒谬的过度简化，或者你认为即使你可以以这种方式制作一个大型复杂的游戏，它也会变成一个程序化的泥球，让我们来看一下这个一段时间，看看是否有任何优势，然后再完全否定它。显然有一个巨大的、明显的劣势，那就是整个游戏状态对所有系统都是可见和可变的，如果某些东西意外地改变了，你可能不知道去哪里查找以找出是什么在不当的方式改变游戏状态。没有人 <em>真的</em> 建议在现代时代编写软件，将所有状态作为实际上的全局变量。</p>
<p>然而，这里有一个优势，那就是通过一点点关心，你可以以 100% 安全的 Rust 编写游戏，几乎肯定不会遇到借用检查器的问题。你可能无法安全地使用 _指针_，因为 <em>肯定</em> 如果你使用指针，你的整个游戏状态将有内部指针指向自身，所以我们需要对 Mario 64 风格进行一个修改，那就是在所有会有指针的地方，改为存储到某个数组的索引。这个的经典例子是我们 GameState 中的“mario_entity”字段。这可能看起来过于限制性，但经过一些思考，它变得清晰，特别是如果你有常量限制（你甚至没有 malloc，记住！），你总是可以添加像 <code>all_the_textures: [TextureDescriptor; 256]</code> 这样的内容，并使用这个静态数组的整数索引来描述纹理，而不是像指针这样的东西。另一个原因是这在借用检查器方面是有帮助的，因为 Rust 非常擅长让你为不同的字段分割借用，所以既然我们假设的引擎中的一切都是一个巨大的嵌套公共结构体，你应该总是能够读取游戏状态并改变每个系统所需的确切部分。记住，大多数“行动回放”时代的游戏都是这样编写的，通常没有任何 malloc-ing，最多有一些非常有限的东西像“分配”只从一个固定数组中，而且大多数东西都或多或少地仔细地放置在某个静态结构中。</p>
<p>这种风格的另一个批评是，你可能会说使用索引而不是指针在严格意义上是“安全”的，但可能只是技术上的，你正在用指针的 UB 和潜在崩溃来换取“随机但未指定”的行为，如果你访问了错误的或过时的索引，可能会引发 panic。你说得对，顺便说一下！我们将稍后再讨论这个问题，但只是现在接受这是可能的和安全的，这种设计并没有直接反对借用检查器。</p>
<p>好的，现在我已经描述了一个你 <em>可能</em> 会用 Rust 编写游戏的方式，这种方式在道德上与最古老的游戏架构非常接近。我并不是在为你的下一款游戏或其他什么而提倡这个，但确实有一些现在编写的游戏比这更少，以直接的、单一用途的程序化风格编写。我不会叫出具体的游戏，但我见过很多以这种方式编写的游戏，通常包裹在一层薄薄的面向对象的外表中。我见过游戏源代码有一个单一的 <strong>12k</strong> 行世界生成函数。这不是对这种游戏的侮辱，甚至边际上也不是，做这些事情的人通常是绝对的天才，他们只是非常擅长知道关心什么和不关心什么。这里确实有真正的智慧！</p>
<p>但我仍然不是在提倡这个。让我们将这称为“UR-game-architecture”，我们将回到这一点。这是从底层接近“数据驱动！使用 ECS！”的答案，让我们现在从顶层接近这个。</p>
<h2 id="太多的面向对象"><a href="#太多的面向对象" class="headerlink" title="太多的面向对象"></a>太多的面向对象</h2><p>现在我们已经涵盖了可能最简单的混乱的过程化 C 风格的游戏引擎设计，让我们尝试应用面向对象设计的原则，看看这是否是一种改进。我将以 Starbound 或 Starbound 的某种简化为例，因为我有幸对它了解很多，并且手头有它的源代码，所以我在描述它时不会 <em>太</em> 多地撒谎。</p>
<p>面向对象的原则是什么？并不是每个人都完全同意面向对象是什么，但我会包括一些基本的、希望没有争议的要点：</p>
<ul>
<li>单一职责原则 - 对象应该有一个单一的逻辑集的职责，方法应该在这些职责集中执行一个操作。</li>
<li>封装 - 你应该将数据与操作它的函数绑定在一起，使它们免受外部干扰和误用。这允许你通过改变类的内部表示而不改变其行为来进行重构。</li>
<li>抽象，或“里斯科夫替代原则”，或类似的 - 你应该能够用一个派生类替换另一个，只要它们共享相同的基类并通过该基类（或接口，或其他什么）使用。</li>
<li>接口隔离，或最少耦合原则等 - 一个类对另一个类的依赖应该使用尽可能小的接口。</li>
</ul>
<p>在实际层面上，面向对象语言通常有一些重要的特性来支持面向对象设计，即对象方法、私有对象数据、继承、虚拟方法等。我主要会谈论 C++，因为它有很多面向对象的陷阱，它是我所知道的，并且它是超级流行的语言，用于“我要制作我自己的引擎”的游戏开发人群。</p>
<p>我们将尝试这些原则，并看看它们如何被误用于游戏开发，然后讨论即使它们经常失败于游戏开发（这现在是一个“众所周知”的状态），它们在 Rust 中失败得 <em>更</em> 壮观。用这些原则 <em>是</em> 可能制作游戏的，而且它们并不是 <em>全部</em> 都是普遍糟糕的想法。我并不是面向对象的 _支持者_，但至少有一些好的想法是与面向对象相关或从面向对象中产生的（所有这些 Rust 都有，并且可以很好地执行）。</p>
<ul>
<li><p>点运算符或“后缀函数”。如果你是 Haskeller，这是“类型导向名称解析”，而不是通常的情况，即“名称导向类型解析”。一种“强大”的方式，避免必须用非常短的公共名称来限定 100 个不同的函数，或者为所有事情都有 C 风格的前缀。对 IDE 也很棒！</p>
</li>
<li><p>具有法律（合同）的接口 - Rust traits！没有继承在望，它们最好时是小的，并且围绕它们有有意义的规则，但如果你看它们，它们有点像 C++ 纯虚类。它们 _很棒_，就像 Haskell 类型类很棒一样。 </p>
</li>
<li><p>数据隐藏 - 能够隐藏数据以维护不变性是非常宝贵的，没有它，就不可能安全地将接口暴露给不安全的</p>
</li>
<li><p>代码。在小范围内非常有用，以及与“库”代码一起使用。</p>
<p>所以只是为了记录，我不是在挑剔上面的好部分，这些是好的，甚至很棒。有了这个，让我们看看面向对象设计的其他部分如何失败于游戏开发。</p>
<p>所以，表面上游戏似乎很适合面向对象，因为当你试图想出面向对象的设计时，有一些明显的“对象”会跳出来。以 Starbound 为例，像“玩家”，“NPC”，“怪物”这样的事物是很容易理解的概念，是我们游戏中对象的明显候选者，让我们从这些开始。我们还将包括一个“世界”类，像 Mario 64 示例一样，是一些现场游戏场所的基本结构（我们故意跳过像接口、菜单等事情，专注于游戏引擎的核心部分）。我还将不得不切换到 C++，因为其中一些将很难用 Rust 表达。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line"></span><br><span class="line">    Vec2F aim_position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId focused_entity;</span><br><span class="line">    <span class="type">float</span> food_level;</span><br><span class="line">    <span class="type">bool</span> admin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有很多...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    MonsterAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId current_target;</span><br><span class="line">    DamageRegion damage_region;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    Vec2F aim_position;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    <span class="comment">// 嗯，我们可能需要一个接口和向下转型？</span></span><br><span class="line">    HashMap&lt;EntityId, <span class="type">void</span>*&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>马上，我们看到了数据类型中的重复结构，可能这些应该是有自己的方法的子对象，让我们稍微勾画一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line">    Vec2F aim_position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line">    HumanoidState humanoid;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId focused_entity;</span><br><span class="line">    <span class="type">float</span> food_level;</span><br><span class="line">    <span class="type">bool</span> admin;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line"></span><br><span class="line">    MonsterAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId current_target;</span><br><span class="line">    DamageRegion damage_region;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line">    HumanoidState humanoid;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, <span class="type">void</span>*&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到目前为止，这还不错，但这仍然只是描述了我们游戏中的数据结构。记住，我们谈论的面向对象原则之一是封装，你想要为这些结构（我们应该叫它们类！）暴露最小的接口和方法，并且只暴露必要的内容。另外，world 内部的 entities 中有一个 void 指针，我们可能不应该有这个，我们需要以某种方式存储我们的实体，让我们在这个时候制作一个 Entity 接口，同时我们也是在制作它的时候为所有实体的共同事物制作一个 Entity 接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先声明 World 以将其传递给 Entity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InputState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderState</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚接口！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 好吧，*肯定* 所有实体都会有一个位置，这可能是 const 的。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有实体都有速度吗？实际上可能不是，可能还有一些静态实体，所以我们跳过速度。还有</span></span><br><span class="line">    <span class="comment">// 其他共同的字段吗？老实说，可能有一些值得放在这里，但如果没有立即想到的案例，可能</span></span><br><span class="line">    <span class="comment">// 不会有*太多*，也许它们都会返回 Maybe 或者其他什么，但这听起来作为一个接口并不是很有用？我们将</span></span><br><span class="line">    <span class="comment">// 只是为这些制作更多的接口，坚持面向对象设计！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，我们肯定必须更新每个实体，可能还要渲染它，所以让我们为此定义一些方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，我们肯定必须将实体的世界传递给它的更新方法，因为例如玩家必须能够做</span></span><br><span class="line">    <span class="comment">// 像生成投射物实体这样的事情，怪物和 NPC 可能也是如此。另外，怪物必须知道玩家在哪里才能攻击他们！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让我们假设这些不是太状态化的和混乱的，每个实体都可以以某种合理的方式“自己渲染自己”。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 没有私有数据！我们肯定知道我们应该优先考虑组合而不是继承，因为我们以前听说过这个，所以只有纯</span></span><br><span class="line">    <span class="comment">// 虚拟接口给我们！这可能是面向对象设计的 *可能* 基本上已经死了的一个方面？我实际上不确定，但我知道这已经被讨论到死了，所以我们不必再打这个</span></span><br><span class="line">    <span class="comment">// 死马了。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line">    HumanoidState m_humanoid;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPC</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line">    HumanoidState m_humanoid;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以在我们继续之前，为什么我在这里麻烦 <code>EntityId</code> 这些东西？这是 C++，我们不能用指针吗？好吧，事实证明这样做是非常 <em>不安全</em> 的，所以所有我见过的游戏引擎（在没有花哨垃圾收集器的语言中）都采用的是有一些形式的“实体 id”到实际实体指针的映射，并将这个映射保存在一个地方的模式。原因是，在 C++ 中，假设每个实体都保留一个 shared_ptr 或某种形式的 downcasted shared_ptr。那么问题就来了，World 现在是一个巨大的引用循环球，实体可能永远不会被销毁，这是一个巨大的问题。另一方面，如果它们保留了原始指针，它们将不断地失效，这往往会导致难以解决的短暂错误，所以几乎没有人这样做（至少，没有人保留原始指针 &#x2F; 引用很长时间）。你可以使用例如 weak_ptr，这有时被使用，但往往有其他原因使用 ids，因为它们对网络编程很有用，并且可以更容易地从磁盘保存和加载。这很有趣，因为这是我们在“UR-game-architecture”中必须做出的主要改变，以使其与 Rust 兼容，但这在游戏引擎中非常 <em>非常</em> 常见！</p>
<p>（在游戏引擎中，EntityId 通常是一个像 int 这样不断增加的东西，可能是一个不循环的 uint64_t 或者是一个循环的 uint32_t，这样做是为了让 EntityId 永远不会或很少被重新使用。这样，如果一个实体消失了，通常任何监控它的都会注意到它已经走了，而不是被其他实体立即取代。这里还有一个模式叫做“代际索引”，这很重要，我稍后会谈论）</p>
<p>好的，所以这似乎是… 真的可以制作一个复杂的游戏吗？我可以想象一个 <em>非常</em> 简单的游戏，你可以用这些类和接口制作，但让我们更详细地看看我们会碰到什么问题。</p>
<p>让我们想想一个怪物需要跟踪一个玩家。它们可能会遍历世界上所有的实体，过滤只有玩家，按距离排序（在现实中你会使用某种空间哈希 &#x2F; kd-tree），然后跟踪最近的一个。实际上这似乎基本上可能与这个一样！好的，新要求：怪物应该首先跟踪健康值最低的玩家。呃哦，好吧，玩家的健康是私有的，所以我们最好为这个做一个公共访问器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们 <em>可以</em> 只让健康公开，但面向对象设计！如果健康值降到某个值以下，就会触发某个动画状态怎么办？关于伤害呢？当然，单一职责原则说明一个 <em>怪物</em> 不应该负责设置一个 <em>玩家</em> 的健康。</p>
<p>好的，新要求：怪物不应该去追标记为“管理员”的玩家。好的，添加一个访问器！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_admin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好的，我们制作了一个小原型游戏，但还没有伤害发生，所以让我们开始设置伤害。嗯，玩家的伤害系统应该放在哪里？可能玩家应该减少他们的健康，因为这是 <em>他们</em> 的健康……或者怪物可以这样做，因为这是 <em>他们的</em> 伤害区域？我不知道，我会说这是玩家的工作。我猜这意味着我们需要怪物的访问器来获取他们的伤害区域：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> DamageRegion&amp; <span class="title">damage_region</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这正在变成很多访问器。我们 <em>可以</em> 只开始公开更多的事情，但面向对象原则是什么？我们应该尽可能少和有限地暴露接口，这样我们就可以改变我们的实现而不需要重构。也许这不会 <em>那么</em> 糟糕。</p>
<p>好的，新要求：某些怪物只有在玩家靠近他们触摸地面时才会激怒。好的，这将需要更多的访问器，但因为我们一直在遵循关于代码重用的好的面向对象原则，我们有内部成员 m_physics 类型 <code>Physics</code>，它是唯一知道实体是否接触地面的东西。所以，我想 Physics 需要一个访问器来获取其内部状态 <code>Physics::onGround</code> 然后 <em>Player</em> 需要一个访问器 <code>Player::onGround</code> 这反过来将使用 <code>Physics::onGround</code>。好的，这正在变成 <em>很多</em> 访问器。</p>
<p>感觉就像每次有新需求进来，你都必须对可能曾经是合理的接口“再打更多的洞”。8 个月后，大部分半游戏都是这样建造的，有很多这些洞被戳穿。很多代码没有清晰的地方，因为它涉及到多个实体，很多逻辑上相似的功能被分散在几个文件中。“面向对象的问题在于一切都发生在别处”。</p>
<p>新需求来了：我有一个特殊物品的想法，当玩家拿着它靠近特定类型的敌人时，它会发光。触发这个的敌人应该害怕这个物品并后退，但有一种特殊的动画，他们被发光的物品迷住了。这只对达到某些特定任务目标的玩家有效。</p>
<p>你沮丧地举起双手，这将需要 4 个单独的模块来了解所有其他模块的内部（玩家、物品、怪物、动画）。你增加了更多的访问器和特殊接口。事情一团糟。</p>
<p>所以这些是虚构的例子，但它们与我 <em>很多</em> 经历的真实事情并没有太大的不同。这就是为什么现在普遍认为面向对象在游戏开发中 <em>大多数</em> 只是阻碍。数据隐藏在游戏之外的代码中除了在边缘保持不变性之外，几乎没有什么用处，其中事情更小，更有限。你的游戏中很多有趣的行为最终会跨越许多数据类型，并不自然地“属于”任何特定的实体。很多实体类型 80% 或 60% 与其他类型相似，很难重用代码，我们在实体中添加的模块越多，以帮助重用代码，就增加了更多的层次。与我们的 UR-架构相比，我们获得了什么？不是所有东西都对所有功能可见，即使我们不断增加更多的访问器，它也几乎是这样？也许在代码组织上稍微好一些，但有时 _更糟_？</p>
<p>好的，显然这在 C++ 中有很多缺点，并不是每个游戏都像 Starbound 那样有如此多的疯狂一次性功能。也许这只是一个极端的例子，通常这并不是那么糟糕的问题？让我们看看如果你尝试在 Rust 中这样做会发生什么！ _马上_，事情开始变得 _困难_。让我们回到 C++ 中最简单的面向对象版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedefs...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entity definitions...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>部分翻译成 Rust：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">input</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, input_state: &amp;InputState);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, world: &amp;<span class="keyword">mut</span> World);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, render_state: &amp;<span class="keyword">mut</span> RenderState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    player_ids: <span class="type">Vec</span>&lt;EntityId&gt;,</span><br><span class="line">    entities: HashMap&lt;EntityId, Rc&lt;Entity&gt;&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使在这个很小的例子中，你已经可以看到这将是一个巨大的麻烦。首先，World 拥有每个 Entity，但每个 Entity 有一组可变的方法，其中之一必须接受一个 World 的可变引用。这不会起作用，因为你将可变地借用一个 Entity，然后必须再次可变地借用它以传递一个 World 引用（这可能会包含 self Entity）。为了做到这一点，可能 <em>每个</em> Entity 实现都需要内部可变性，否则它们将没有办法获取 World 引用，而且 World 可能也需要内部可变性，因为它也需要通过不可变引用传递。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">input</span>(&amp;<span class="keyword">self</span>, input_state: &amp;InputState);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">self</span>, world: &amp;World);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, render_state: &amp;<span class="keyword">mut</span> RenderState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    player_ids: RefCell&lt;<span class="type">Vec</span>&lt;EntityId&gt;&gt;,</span><br><span class="line">    entities: RefCell&lt;HashMap&lt;EntityId, Rc&lt;Entity&gt;&gt;&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，现在我们在实体更新期间不会有借用错误，但现在一切都必须在 RefCell 里面？也许我们可以将我们整个状态放在一个 RefCell 里面，这样就不会太难？我们已经讨论了复杂行为非常跨领域的倾向，如果有以下情况：</p>
<p>一个怪物伤害了一个玩家，这触发了玩家播放一个音效作为受伤的音效，但出于游戏原因，这也触发了一个逻辑声音，其他生物可以对它做出反应。也许有一些特定的怪物类型会有群体行为？所以，伤害一个玩家触发了一个外部突变（音频），内部突变（健康），然后可能触发怪物，它们有自己的内部突变（目标实体）。也许这一切都是从怪物开始的，所以控制流从怪物到玩家，然后 <em>回到</em> 怪物。如果你在调试怪物，现在你已经通过间接触发你自己结构体方法中的突变触发了 <em>诡异的动作在</em> 远处。除了，Rust 不允许这样做，（这甚至可能不会在 RefCell 中类型检查），所以在 Rust 中的版本是，你简单地得到了一个 RefCell panic。</p>
<p>让我们继续，假设实体有一些标签或动态标签集，让我们将这个添加到我们的 C++ Entity 接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> List&lt;Tag&gt; <span class="title">tags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设你分析了你的游戏，简单地返回一个 <code>List&lt;Tag&gt;</code> 的副本正在消耗大量的 CPU 时间，所以你将接口改为这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> List&lt;Tag&gt;&amp; <span class="title">tags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是假设这样的改变是可能的，不是一个等待发生的使用后释放错误，这通常是这种情况。好吧，Rust 应该能让我们免于使用后释放，如果你将这个翻译成 Rust 版本会发生什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tags</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;Tag&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我使生命周期不省略，以使其明显，但这表明这个方法返回一个单一的 Vec 引用，它借用了 _整个实体_。那是.. 有帮助的，但如果你想要稍后调用任何可能发生变异的其他方法，那也没有帮助。如果这有内部可变性并且在 RefCell 里面，这也是不可能的，将不得不返回 <code>std::cell::Ref</code>。一切都很难，比在 C++ 中更难。你上 IRC 寻求帮助，你得到了一个好意但可能不太有帮助的答案：“你只是在与借用检查器战斗的阶段。”</p>
<p>情况可能会更糟。Entity 很稀疏，即使是 Starbound 中真正的 <code>Entity</code>，假设你将这些相同的原则应用到 <code>World</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tile</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, index: Vector2&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> WorldTile &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巨大的额外成员...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你有一个足够大的 <code>World</code> 结构，即使没有像纯虚拟接口（或在 Rust 中，特征）这样的东西，你仍然会遇到问题。访问一个瓦片应该借用 <em>整个世界</em> 吗？如果世界的所有字段都是公开的，事情会更容易，这样你就可以借一部分世界，从而允许你变异其他部分，这正是你可以做的，如果世界只是一个具有普通公共成员的结构体。这变得更加重要，世界越大，数据隐藏就越不重要，你越进入“应用”级别，情况就越糟，因为你的游戏随着你不断添加功能而变得越来越复杂。我们不是在写引擎，我们只是在 Rust 中直接写一个简单的游戏，所有的数据都必须去某个地方！</p>
<p>如果你正在写像这样的方法，更明显的是你可以使一个大型复合结构的字段公开，并且分割借用会有帮助，但想象一下你没有这样设计事情。想象一下你有 <em>两种</em> 世界，一个用于服务器，一个用于客户端。这正是 Starbound 的工作方式，并且有一个大型复杂的“世界”接口在客户端和服务器之间共享。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tile</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, index: Vector2&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> WorldTile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巨大的额外特征方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 <em>不可能</em> “只让字段公开”，不管“面向对象”原则或不，就像 Entity。更多的“与借用检查器战斗”。面向对象原则指导你尽可能松散地耦合，一个很常见的策略是，不是让对象直接依赖于彼此，而是通过一个纯接口相互依赖。</p>
<p>Starbound <em>充满了</em> 这些，Entity 和 World 只是其中两个。它们 <em>放大</em> 了借用问题，通过 <em>放大</em> 你被迫借用的数量！</p>
<p>我不认为我 <em>完全</em> 能在我的 30 分钟演讲中完全证明我说的一切，这只是 <em>一点点</em> 表面，但希望我至少给了你 <em>一个</em> 我来自哪里 _的想法。我知道对你们中的一些人来说，这听起来会非常主观，可能只对特定类型的软件（游戏）听起来像有用的建议。另外，对你们中的许多人来说，这可能是无聊的，你已经都知道了，但它仍然希望看到这与一个并非每个人都参与的行业的关系。</p>
<p>但是，话虽如此，这里有一些我的收获：</p>
<ul>
<li><p>对于游戏，面向对象 <em>真的</em> 没有帮助。我列出的面向对象的有用部分是好的，但当你不是在写“库”代码，而是在写游戏时，数据隐藏 <em>一般</em> 不是有用的，只是浪费了大量的努力和时间。你的游戏数据越多，它就越会因为你不断尝试而改变，这就越糟糕。</p>
</li>
<li><p>思考“对象”与数据类型在游戏设计中听起来表面上很吸引人，但实际上是 <em>积极</em> 有害的。大多数行为并不“附加”到任何数据，如果你开始这样思考，可能会很难停止。不要将你游戏的数据表示与操作它的系统混为一谈！</p>
</li>
<li><p>有时我觉得，我宁愿处理一个单一的 12k 行巨型程序，也不愿处理一个纠缠不清的对象球。</p>
</li>
<li><p>Carmack 引用：“有时，优雅的实现只是一个函数。不是一个方法。不是一个类。不是一个框架。只是一个函数。”</p>
</li>
<li><p>有时，如果你必须写很多混乱的过程状态变化，只是 <em>诚实</em> 地处理它们，用长（也许不是 12k 行）的过程是最佳策略。诚实地面对正在发生的事情的混乱，隐藏在其他函数或方法中并不会有所帮助，它只会让事情出错时更加困惑。如果可以把事情拿出来，它们是简单和纯粹的函数，那就去做吧，但把混乱的过程真相保持原样！另一个 Carmack 的事情。</p>
</li>
<li><p>我发现思考决定游戏状态的结构类型非常容易，也很有启发性。你经常可以从代码库中学习几乎所有你需要知道的东西，只是看看所有的类型定义。如果你在看 C++，如果你只看结构成员及其关系并忽略所有的代码，这通常会告诉你比看函数名称更多的东西。我花了很多时间阅读 Haskell 代码，他们有一种模式，通常在 Rust 中被模仿，他们有一个模块叫做“Types”，只有……一些库所需的所有类型。我有点喜欢这个，我认为 Rust 非常适合这种编程。</p>
</li>
</ul>
<p>我在这里有点调皮，但什么告诉你更多，这个接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="function">List&lt;EntityPtr&gt; <span class="title">entityQuery</span><span class="params">(RectF <span class="type">const</span>&amp; boundBox)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是这个结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    SpatialHash2D&lt;EntityId, <span class="type">float</span>, EntityPtr&gt; entitySpatialMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然，这里有很多信息来自类型的 _名称_，显然 <code>SpatialHash2D</code> 是它自己的结构，有自己的子类型，但如果你很好地命名你的类型，这个观点仍然成立，你看到一个明显的面包屑路径可以跟随，以理解接口可能隐藏了什么（你的空间实体查询可能会很快，你不应该期望查询会以实体数量的线性时间进行）。</p>
<p>我问过我们是否可以使用面向对象来改进我们的 UR-架构，令人惊讶的是，我们 _基本上不能_。除了像点运算符和数据隐藏这样有用的东西之外，这些在库代码中很有用，游戏的大规模结构并没有真正得到面向对象的帮助。我们需要一种方法来处理没有制造面向对象混乱的单个巨大可变公共嵌套结构的负面影响。我们现在从顶层接近 ECS 答案。</p>
<h2 id="回到开始。"><a href="#回到开始。" class="headerlink" title="回到开始。"></a>回到开始。</h2><p>我们的“面向对象架构”在 Rust 中完全失败了，让我们从我们知道会起作用的东西开始，我们的“UR-架构”，并尝试改进它。这是一个相当标准的 ECS 转换，你可能以前见过。</p>
<p>我读过很多 ECS 解释，我知道有一个相当好的解释，还有 <em>很多</em> 真正令人困惑的糟糕解释，希望我可以以一种很好的方式解释这个，专注于 <em>数据</em> 表示，并且对 Rust 特别有用。</p>
<p>让我们从我们的简单“Starbound”开始，再次写下我们游戏的状态表示，但这次是用 Rust。没有方法，没有函数，只有数据类型。这将与上面的 Mario 64 示例“UR-架构”非常相似，有一些小的添加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    animation_state: HumanoidAnimationState,</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    humanoid: HumanoidState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    animation_state: MonsterAnimationState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">    damage_region: DamageRegion,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    humanoid: HumanoidState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    behavior: NpcBehavior,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Player</span>(Player),</span><br><span class="line">    <span class="title function_ invoke__">Monster</span>(Monster),</span><br><span class="line">    <span class="title function_ invoke__">Npc</span>(Npc),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entities: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Entity&gt;&gt;,</span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = <span class="title function_ invoke__">initial_game_state</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">player_control_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line">        <span class="title function_ invoke__">npc_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line">        <span class="title function_ invoke__">monster_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vsync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与 Mario 64 示例相比，这里有几个变化。首先，我们试图使用 Rust 功能，如枚举和像 Option 这样的数据类型，而不是如此努力地模仿 C。很棒的是，突然之间，我们游戏状态的结构有更少的可能无效状态！例如，如果我们试图使用一个统一的“Entity”与一个类型代码，像 Mario 64 那样，将会有必须手动保持的不变性，这些不变性表明某些字段的状态取决于实体的类型。现在，许多这些不变性自然地因为求和类型是如此伟大而消失了。这很有趣，因为它使封装变得不那么重要，即使一切都是公开的，也有一些不变的性不能被打破。还有一些不变的性不能以这种方式表达，例如，数组的玩家 ID 可能需要仅指向 Player 类型的实体！</p>
<p><code>entities: Vec&lt;Option&lt;Entity&gt;&gt;</code> 也很有趣。由于我们的一些实体将索引到这个数组作为对其他实体的“指针”，因此有意义我们不应该在数组中移动实体。如果我们分配了一堆实体然后删除了我们分配的第一个实体，我们不应该移动每个实体，而是将其设置为 None，这样数组的其余部分就会保持在原位。在分配时，我们可能会遍历数组寻找第一个 None 空槽，如果没有找到，将一个新的实体推到末尾。</p>
<p>这很有趣，因为它与“Mario 64”示例中的静态数组的工作方式非常相似。</p>
<p>除了这些变化，这并不是一个巨大的偏离。所有的游戏状态仍然在道德上是全局的，每个系统仍然可能是大的和程序化的。但这里的事情是……我真的不认为这很糟糕？</p>
<p>老实说，如果我正在做一个游戏制作比赛的游戏，这可能就是我会编写我的游戏的方式！</p>
<p>我不会编写底层图形或音频代码，但如果我正在做一个简单的 2D 游戏或非常简单的 3D 游戏，这对我来说是可行的。我的游戏状态可能是一个相当复杂的结构体，充满了其他结构体，我可能有很多“系统”（记住，这里只是普通函数）在不同的文件中，这很好。我会选择一个非常简单的图形 API，尽可能少的状态，以尽可能减少“加载”和“卸载”图形数据的麻烦，同样适用于音频 API，这将是游戏的结构。如果我必须使用一个非常混乱和有状态的图形或音频系统，我会在最初创建游戏状态时预加载所有内容，将所有内容都放在某个 Assets 结构体中，就这样。</p>
<p>有很多 Rust 的高级图形和声音 API 实际上使这变得非常容易。</p>
<p>但是，这种模式显然并不完美，除了一切都是全局公开的。首先，我们的每个实体类型中都有很多重复的数据，例如 <code>Physics</code> 在 Player、Monster 和 Npc 中重复。在我们的 <code>physics_system</code> 函数中，可能有一些共性，这进一步分解为另一个函数，但 <code>physics_system</code> 肯定 <em>肯定</em> 必须理解有 3 种不同的实体类型，它们都有物理。每当我们添加一个实体类型时，可能这个系统必须改变其实现，并且老实说，可能 <em>非常非常多</em> 的系统在添加实体类型时必须改变。</p>
<p>另外，随着我们添加更多的实体，我们可能会开始发现很大一部分将被一遍又一遍地重复。也许“Monster”太具体了，你将它分解为“FlyingMonster”和“GroundMonster”，但它们共享 80% 的相同字段，反过来，这两个又与 Player 共享 50% 的字段。</p>
<p>这在某些方面比拥有一个统一的实体类型要好，但在某些方面实际上更糟？这还不错，但让我们看看是否可以做得更好。让我们回到像 Mario 64 示例那样有一个统一的 Entity 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有不同类型的字段，一个实体可以拥有，按逻辑分组...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    animation_state: HumanoidAnimation,</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterState</span> &#123;</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">    animation_state: MonsterAnimationState,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcState</span> &#123;</span><br><span class="line">    behavior: NpcBehavior,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实体是所有可能的实体字段的集合，我们让每个人都有一个选项。在这种情况下，</span></span><br><span class="line"><span class="comment">// 我们失去了一些类型安全性，因为这样可以表达更多的无效状态，其中一些组合可能没有意义。</span></span><br><span class="line"><span class="comment">// 另外，也许现在没有意义让一个实体缺少位置，所以即使在这里是可选的，所有实体都必须有物理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    physics: <span class="type">Option</span>&lt;Physics&gt;,</span><br><span class="line">    health: <span class="type">Option</span>&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    humanoid: <span class="type">Option</span>&lt;HumanoidState&gt;,</span><br><span class="line">    player: <span class="type">Option</span>&lt;PlayerState&gt;,</span><br><span class="line">    monster: <span class="type">Option</span>&lt;MonsterState&gt;,</span><br><span class="line">    npc: <span class="type">Option</span>&lt;NpcState&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entities: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Entity&gt;&gt;,</span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = <span class="title function_ invoke__">initial_game_state</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">player_control_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line">        <span class="title function_ invoke__">npc_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line">        <span class="title function_ invoke__">monster_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vsync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好的，这很有趣。显然，我们在这里失去了一些不变性，因为更多的潜在无效实体可能会被创建，但有一些巨大的优势。一个突出的是，我们 <code>physics_system</code> 的实现可能大大简化了，只需循环遍历所有实体并突变 <code>physics</code> 字段（如果它们有的话）。这比循环遍历实体并匹配实体类型要简单得多。</p>
<p>仍然有一些结构仅对每种“逻辑”实体类型有效，显然，让某物同时是 NPC 和怪物是没有意义的，所以这是一个需要保持的不变性。这很有趣，因为每个“类型”的数据量变小了。让我们更进一步改变它，并分离出更多的字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItems</span> &#123;</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Aggression</span> &#123;</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了对称，让我们让 Health 成为结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Health</span>(<span class="type">f32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hunger</span> &#123;</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    physics: <span class="type">Option</span>&lt;Physics&gt;,</span><br><span class="line">    huamnoid_animation: <span class="type">Option</span>&lt;HumanoidAnimation&gt;,</span><br><span class="line">    humanoid_items: <span class="type">Option</span>&lt;HumanoidItems&gt;,</span><br><span class="line">    monster_animation: <span class="type">Option</span>&lt;MonsterAnimation&gt;,</span><br><span class="line">    npc_behavior: <span class="type">Option</span>&lt;NpcBehavior&gt;,</span><br><span class="line">    health: <span class="type">Option</span>&lt;Health&gt;,</span><br><span class="line">    hunger: <span class="type">Option</span>&lt;Hunger&gt;,</span><br><span class="line">    player: <span class="type">Option</span>&lt;PlayerState&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以有很多方法可以表达每个实体可能包含的字段，它们都有优点和缺点。在这种情况下，通过以这种方式转换我们的字段类型，有几件事情变得可以表达，以前是不可能的！例如，由于我们将 <code>food_level</code> 字段从 Player 中分离出来并称之为 <code>Hunger</code>，我们现在可以表达不是 Player 但饥饿的实体，所以现在我们可以描述饥饿的 NPC。另外，在分离出 <code>Aggression</code> 之后，我们可以表达敌对的 NPC！</p>
<p>然而，也许我们可以表达具有怪物类型动画的东西，也可以携带人类物品，也许这实际上是逻辑上无效的，所以这里有一个取舍。尽管如此，这仍然很有趣，并解决了在需要重复代码来表达或从单一类型中提取的实体类型之间存在很多共同性的问题。</p>
<p>现在，可能已经很清楚我要去哪里了，但这种模式，其中实体由一个或多个命名部分组成，并且它们是按需指定的，是非常常见的。实际上，这些部分通常被称为“组件”！我们现在有了所有的实体、组件和系统，所以如果你眯着眼睛看，这就是一个“ECS”系统所需要的一切，但这实际上非常简单！通过专注于我们状态的数据表示，这与我们开始的没有太多步骤。</p>
<p>让我们再做一个实际上无关紧要的改变，但这将在一秒钟内帮助我们。此外，我们将开始称我们一直在定义的所有这些部分为“组件”，以强化这一点：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有这些组件向量必须具有相同的长度，这是当前的实体数量。</span></span><br><span class="line">    physics_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;PhysicsComponent&gt;&gt;,</span><br><span class="line">    humanoid_animation_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HumanoidAnimationComponent&gt;&gt;,</span><br><span class="line">    humanoid_items_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HumanoidItemsComponent&gt;&gt;,</span><br><span class="line">    monster_animation_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;MonsterAnimationComponent&gt;&gt;,</span><br><span class="line">    npc_behavior_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;NpcBehaviorComponent&gt;&gt;,</span><br><span class="line">    aggression_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;AggressionComponent&gt;&gt;,</span><br><span class="line">    health_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HealthComponent&gt;&gt;,</span><br><span class="line">    hunger_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HungerComponent&gt;&gt;,</span><br><span class="line">    player_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;PlayerComponent&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是经典的“结构数组”到“数组结构”的转换。应该很清楚（几乎）完全相同的信息可以在这两种表示之间表达。有一些新的不变性需要维护，即每个组件 Vec 的长度必须相同，但并没有真正的新信息。当你像这样写出类型时，这些变化实际上看起来相当简单，而不是在我们的面向对象架构中，像这样的变化可能被认为是不可能的重构。显然我们还需要在这里改变很多系统，每次我们进行这些更改时，但能够独立思考数据是有价值的。</p>
<p>“数组结构”的转换通常是 ECS 介绍中真正关注的，然后他们开始谈论性能问题和缓存行为，这可能会有点令人困惑和不知所措。他们不是错了，但我不认为这是重要的部分。这就是为什么我以这种方式介绍 ECS，因为我认为很多解释都错过了这一点，从某种角度看，这些变化实际上相当无聊和正常。你可能有这种结构，或者你可能有之前的结构，也许一个比另一个性能更好，但你没有通过选择一个而不是另一个来彻底改变编程范式。从数据导向的角度来看，这些事情并不是颠覆性的，它们只是性能优化。这里还有很多其他的潜在优化可以做，但我认为我们已经达到了有人可能会称之为“ECS 系统”的最低限度。</p>
<p>这里有一些对 Rust 用户的一般性建议，不仅仅是游戏开发者：</p>
<ul>
<li><p>仅仅思考状态的结构是非常有力的，通常“方法”和“对象”会碍事。没有人会认为在结构体上拥有方法是“太多的面向对象”，但它确实将你的程序与你的耦合在一起，即使只是组织上的。数据结构设计和简单的模块组织都很重要，但不要将它们混为一谈！我确信“ECS 设计”在游戏开发中如此出色，是因为它迫使你思考你的数据而不是被卡在面向对象模式中，而不是“数组结构”的魔力。这是可以应用于 Rust 一般性的一个教训。</p>
</li>
<li><p>你可以用索引到 Vec 的方式做很多事情。这比自我借用或 Rc&lt;Ref</p>
</li>
<li><p>Cell&gt; 容易得多。</p>
<p>好的，让我们停下来谈谈 <code>EntityIndex</code>。我真的认为，大多数时候当你发现自己在 Rust 中遇到自我借用时，普通的 Vec 和索引应该是你首先使用的工具。还有其他工具，比如各种竞技场 crates，租赁等，但我认为通常你应该先尝试 Vec。一般来说，这些问题发生在你试图表示某种图结构时（ECS 只是一个非常平的图……有点），即使在 C++ 中，这通常也是给出的建议！（见 Andrei Alexandrescu 的性能演讲，他最喜欢的数据结构在世界上是 std::vector，“只使用 vector！”）像竞技场分配器这样的工具很棒，实际上非常高效，并且有可以与多种类型一起使用的版本，但它们不能是 ‘static 除非添加自我借用。自我借用解决方案像租赁是 _最后的手段_。这不值得，继续你的生活，只是使用 Vec 和索引。</p>
<p>话虽如此，它们确实有一些缺点。在我们的实体示例中，我们一直对如何找到“空闲” EntityIndexes 以及“删除”如何工作这个问题视而不见，因为实际上并不那么好。分配一个“实体”的成本不是恒定的，因为我们必须扫描 Vec 寻找空闲条目。删除实体更便宜，但它有不好的特性。我们可以删除一个实体，这会释放 Vec 中的一个插槽，但然后可能的情况是下一个分配的实体将使用相同的索引。如果我们在删除之前确保没有未解决的“索引引用”到这个实体，这很好，但如果我们搞砸了呢？我们将在不知不觉中得到一个“随机其他实体”，而无法告诉它实际上被从我们下面移除了！另外，这两种情况在“数组结构”转换后变得更糟，因为现在我们有多个数组而不是一个，以及我们如何管理“实体索引”现在是悬而未决的。我们将同时解决这两个问题。</p>
<h2 id="代际索引是很棒的。"><a href="#代际索引是很棒的。" class="headerlink" title="代际索引是很棒的。"></a>代际索引是很棒的。</h2><p>所以这是我最喜欢的模式之一，我不确定在 Rust 社区中是否广为人知，但我相信在游戏开发中广为人知。</p>
<p>我们一直在使用 <code>EntityIndex</code> 来识别和查找存储在 Vec 中的实体。这非常类似于我在 C++ mini-Starbound 中使用的模式，我使用了一个 <code>EntityId</code>，这是一个递增的整数 ID 来存储实体，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br></pre></td></tr></table></figure>

<p>两者都是从整数到某些值的抽象映射。在 Vec 的情况下，它基本上是最快可能的数据结构，索引到数组，而在 <code>HashMap</code> 的情况下，它要慢得多，但 <code>HashMap</code> 要灵活得多！首先，只有总条目数的上限，而不是，比如说，索引的最大大小。<code>HashMap</code> 可以很好地工作，如果你从 1,000,000,000 或 1 开始键值。这在上述删除问题中很重要。如果我们使用 <code>HashMap</code> 和键类型 <code>u32</code> 或甚至 <code>u64</code> 来索引，我们可以只让新索引始终递增（最终会回绕）。这样，你可以或多或少地保证没有索引会被重新使用，或者至少在索引被重新使用之前会是“很长一段时间”。在 <code>u64</code> 的情况下，如果你重新使用了一个索引，你的游戏技术可能已经有“云”在名称中，所以你可能有更多的问题：)。但是 <code>HashMap</code> 比 Vec 慢 :(</p>
<p>是否有办法在使用整数索引到 Vec 的情况下获得这种属性？有，它被称为“代际索引”！</p>
<p>而不是只使用一个整数索引，我们制作一个“代际索引”类型，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你可以使用其他类型，如果这些类型对于 usize / u64 来说太大</span></span><br><span class="line"><span class="meta">#[derive(Eq, PartialEq, etc...)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndex</span> &#123;</span><br><span class="line">    index: <span class="type">usize</span>,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GenerationalIndex</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们制作一个叫做“代际索引分配器”的东西：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocatorEntry</span> &#123;</span><br><span class="line">    is_live: <span class="type">bool</span>,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndexAllocator</span> &#123;</span><br><span class="line">    entries: <span class="type">Vec</span>&lt;AllocatorEntry&gt;,</span><br><span class="line">    free: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GenerationalIndexAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">allocate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> GenerationalIndex &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true 如果索引之前被分配过，现在被释放了</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deallocate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_live</span>(&amp;<span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（有更快的实现方式，但这一个实际上相当不错。另外注意，这是数据隐藏的一个明显好的用途）。</p>
<p>基本思想是你可以“分配”向量索引就像你有了 <code>Vec&lt;Option&lt;Entry&gt;&gt;</code>，但你会永远不重新使用索引。它的工作原理是这样的，你分配一个索引并得到一个带有真实索引 0 的 <code>GenerationalIndex</code>，它也会有“代”0。如果你删除那个索引，它会进入一个空闲索引池，所以下次你分配一个索引时，你可能会得到另一个带有真实索引 0 的代际索引，但关键是代际现在将是 1。代际索引永远不会被重新使用，因为代际总是会递增，然而“真实索引”将始终是“小的”，在最大总条目数的顺序上。这样，你可以使用快速索引到 Vec 而没有简单索引的许多“指针样”属性！</p>
<p>我说这种模式在 Rust 社区中不是广为人知，但至少有一点谎言，因为有一个最近发布的 crate 建立在这个想法上叫做“slotmap”，它很棒！但是，它缺少一个对我们的例子至关重要的功能，那就是在“slotmap”中，你只能为特定的 SlotMap 分配索引，你不能分配索引并重新使用它们用于不同的 SlotMaps。有用，但如果这些概念是分开的，就像我们在这里概述的那样，它将更有用得多。索引到 Vec 已经是在遇到“自我借用”时应该首先使用的工具，代际索引使它变得更好。“slotmap”比我先发布了一个 crate：(，所以这算是一个功能请求 :)</p>
<p>我们将继续制作一个比 <code>Vec&lt;Option&lt;T&gt;&gt;</code> 更易于使用的类型，以存储我们的实际数据：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayEntry</span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 GenerationalIndex 到一些 Value T 的关联数组。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndexArray</span>&lt;T&gt;(<span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;ArrayEntry&lt;T&gt;&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; GenerationalIndexArray&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 为某个代际索引设置值。可能会覆盖过去的代际值。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex, value: T) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个代际索引的值，代际必须匹配。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以有了这个新的抽象，让我们再次改变我们的引擎：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们放弃了索引或 ID 后缀，因为没有其他“实体”类型会混淆。 但不要忘记，这并不“包含”</span></span><br><span class="line"><span class="comment">// 任何东西，它只是一种索引或 ID 或句柄或任何你想要的称呼。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Entity 到某种类型 T 的映射</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line"></span><br><span class="line">    physics_components: EntityMap&lt;PhysicsComponent&gt;,</span><br><span class="line">    humanoid_animation_components: EntityMap&lt;HumanoidAnimationComponent&gt;,</span><br><span class="line">    humanoid_items_components: EntityMap&lt;HumanoidItemsComponent&gt;,</span><br><span class="line">    monster_animation_components: EntityMap&lt;MonsterAnimationComponent&gt;,</span><br><span class="line">    npc_behavior_components: EntityMap&lt;NpcBehaviorComponent&gt;,</span><br><span class="line">    aggression_components: EntityMap&lt;AggressionComponent&gt;,</span><br><span class="line">    health_components: EntityMap&lt;HealthComponent&gt;,</span><br><span class="line">    hunger_components: EntityMap&lt;HungerComponent&gt;,</span><br><span class="line">    player_components: EntityMap&lt;PlayerComponents&gt;,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;Entity&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>太棒了！我们现在几乎是一个完整的 ECS 系统。</p>
<p>对 Rust 用户的收获：显然代际索引是很棒的，但出于某种原因它们在 C++ 中更受欢迎，但它们可能对 Rust 更有用！对“slotmap”的作者，请将分配器单独公开，这非常有用！如果这不在你的范围或你想要的 API 提供，我可以发布一个类似的 crate，它可以做到这一点。</p>
<h2 id="动态类型在非常受控的数量中实际上是相当不错的。"><a href="#动态类型在非常受控的数量中实际上是相当不错的。" class="headerlink" title="动态类型在非常受控的数量中实际上是相当不错的。"></a>动态类型在非常受控的数量中实际上是相当不错的。</h2><p>好的，我们现在非常接近一个“真正的” ECS 系统（像 specs！）可能的工作方式。我们还没有解决的最大问题仍然是一切都是相当全局的。更重要的是，每个“系统”（对我们来说，仍然只是一个普通函数的花哨名称）都依赖于我们游戏状态中的 <em>所有</em> 类型，这可能是相当大的。大多数游戏将生活在一个 crate 中，这些模块之间的依赖关系图表真的没有什么好担心的，但仍然改变“GameState”中的任何内容至少 <em>理论上</em> 会影响每个系统。</p>
<p>让我们看看我们能做些什么？</p>
<p>我想强调一下，在我们继续之前，这是 _可选的_。你可能会觉得这是不必要的复杂性，你可能是对的！这确实是大多数 ECS 实现中的东西，所以它值得涵盖，只是为了理解它们，并且当试图构建一个库来做到这一点时，它是 <em>或多或少</em> 无法避免的。</p>
<p>为此，我们需要 <code>anymap</code> crate，但 <code>mopa</code> crate 也会起作用。我们需要一个容器，可以存储我们放入其中的 <em>每种</em> 类型的一个精确副本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AnyMap</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AnyMap</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, t: T) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们如何使用这个来存储我们的组件？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line">    <span class="comment">// 我们假设这将只包含 `EntityMap&lt;T&gt;` 类型的类型。 这是动态的，所以类型系统在这里不再有帮助，</span></span><br><span class="line">    <span class="comment">// 你可以使用 `mopa` crate 使这稍微更好。</span></span><br><span class="line">    entity_components: AnyMap,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;Entity&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，而不是存储游戏特定的数据，让我们继续使用动态类型！我们将说我们的游戏状态是一个动态集合的实体与组件，并且 <em>也</em> 是其他类型的动态集合，每种类型一个。我们将这些称为“资源”。我们还将 <code>GameState</code> 的名称更改为更准确的东西。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ECS</span> &#123;</span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line">    <span class="comment">// 充满了像 `EntityMap&lt;T&gt;` 这样的类型。</span></span><br><span class="line">    entity_components: AnyMap,</span><br><span class="line"></span><br><span class="line">    resources: AnyMap,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们到达了一个实际的 ECS 数据结构可能看起来的样子。</p>
<p>我添加了一个“资源” AnyMap，因为这也是很常见的模式，它意味着你的整个游戏状态可以在这个“ECS”结构中表达。我们称它为“ECS”，但重要的是，真的没有提到“系统”。我实际上不喜欢通过谈论行为来描述 ECS，因为我认为虽然它可能很重要，但它真的是次要的。如果我们的“系统”是纯函数在一个循环中，或者它们是更花哨的东西，这两种都捕捉到了 ECS 设计的重要部分。</p>
<p>所以，你现在可能会对动态类型的引入感到不满和突然。让我们停下来想想这给我们带来了什么。假设你为你的游戏得到了一个新的功能请求，比如说你需要一个新的疯狂的特殊怪物，它有一些内部的计数器。每次你杀死怪物时，它会将自己复制成两个并递减计数器，像九头蛇的头一样复制。这意味着你可能需要一个新的组件类型，比如说 <code>EnemyDuplicationLevel</code> 或其他什么。有了动态类型，你可以添加这个组件而不会“打扰”你的其他系统，因为如果没有导入新模块，它们不可能“看到”ECS 有这样一个组件。资源也是如此，你可以向你的模型添加新数据类型而不会“打扰”现有的系统。</p>
<p>这种论证的理由可能看起来相当薄弱，而且确实如此。为了获得完整的画面，我们需要更进一步。我将加快速度，这样我们可以到达结尾，我可以展示一个完整的画面，我认为这是一个“现代”游戏引擎设计，你可能用于中型或大型项目。它实际上并不比这更远，但最后几个功能都是相关的，单独使用它们并不那么有用。</p>
<h2 id="“注册表”模式"><a href="#“注册表”模式" class="headerlink" title="“注册表”模式"></a>“注册表”模式</h2><p>现在我们已经引入了动态类型，这里有一个我喜欢的设计模式，我认为在 Rust 中还没有真正看到过（我确定它存在，我只是没有看到）。我将称其为“注册表模式”。</p>
<p>在像 specs 这样的 ECS 实现中，有一个步骤，你“注册”一个类型与你的 ECS，这会在某个 AnyMap 或相当于 AnyMap 的地方插入一个条目。使用未注册的组件类型通常是一个错误。让我们再进一步，不要将“注册”与 ECS 本身联系起来，让我们制作我们自己的“注册表”。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ComponentRegistry</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ComponentRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 注册一个组件，组件必须实现一个特殊特征才能允许</span></span><br><span class="line">    <span class="comment">// 例如从 JSON 配置中加载。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register_component</span>&lt;T: Component&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为所有注册的组件设置 ECS 的条目</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup_ecs</span>(&amp;<span class="keyword">self</span>, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从给定的配置中加载一个实体到给定的 ECS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_entity</span>(&amp;<span class="keyword">self</span>, config: Json, ecs: &amp;<span class="keyword">mut</span> ECS) <span class="punctuation">-&gt;</span> Entity &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也将为“资源”做一个</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ResourceRegistry</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ResourceRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 资源特征提供从 JSON 和其他东西中加载。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register_resource</span>&lt;T: Resource&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为所有注册的资源设置 ECS 的条目</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup_ecs</span>(&amp;<span class="keyword">self</span>, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过从给定的配置中加载来向给定的 ECS 添加资源。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_resource</span>(&amp;<span class="keyword">self</span>, config: Json, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们将它们在一个大型的全局常量中使用 lazy_static 绑定在一起！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们向项目中添加一个组件时，有两个步骤。首先，将组件添加到某个地方作为一个 Rust 模块，然后将其添加到这个列表中。为了增加便利性，这个函数可以放在包含组件模块本身的 lib.rs 中。如果你非常花哨，你也可以有一些“插件架构”来实现这一点，将相关的组件 / 资源组合在一起成为“插件”。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">load_component_registry</span>() <span class="punctuation">-&gt;</span> ComponentRegistry &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">component_registry</span> = ComponentRegistry::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    component_registry.register::&lt;PhysicsComponent&gt;();</span><br><span class="line">    component_registry.register::&lt;PlayerComponent&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">load_resource_registry</span>() <span class="punctuation">-&gt;</span> ResourceRegistry &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: ComponentRegistry,</span><br><span class="line">    <span class="keyword">pub</span> resources: ResourceRegistry,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> REGISTRY: Registry = Registry &#123;</span><br><span class="line">        components: <span class="title function_ invoke__">load_component_registry</span>(),</span><br><span class="line">        resources: <span class="title function_ invoke__">load_resource_registry</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我喜欢这种模式，因为如果你眯着眼睛看，这几乎就像你在 Java 中可能找到的全局类型注册表。它感觉有点“企业级”，但非常有用！它也类似于具有内置编辑器的全功能、全面的引擎，你可能会通过某些菜单或 GUI 添加组件类型，它最终会存储在某些项目配置文件中。在这种情况下，而不是项目配置文件，它只是一个辅助的 Rust 代码。</p>
<p>这种模式最终非常有用！想象一下你有一些可以从 JSON 配置文件中加载的游戏状态。每个资源和组件都可以从 JSON 中加载，所以你只需要添加一个组件或资源类型，然后添加条目到数据格式，加载游戏并看到它（除了你需要一个新的系统来理解新类型，我们会在几秒钟内到达）。</p>
<p>所以到目前为止，这是一个正在变成“真正的”ECS 游戏引擎的东西的草图。我喜欢这个，因为到目前为止，除了一些必要的库功能外，我几乎没有谈论过函数或系统！我之所以这样做，是因为我不喜欢通过谈论行为来引入这个概念，我真的认为考虑我们如何描述我们的状态是一种更有用的方法来接近这个。</p>
<p>有了这个，很容易看出你如何也可以很容易地添加一个 <code>SystemRegistry</code> 与之相匹配。我们的系统只是函数，所以这将允许你以稍微更复杂的方式将函数添加到你的主循环中。这里可能的一个补充是允许系统有一些配置，这样你也许可以为它们配置可调参数，甚至使用相同的函数多次，但具有不同的参数。然而，通常建议尽量不要给你的系统 _状态_，这样你可以将你的游戏状态限制为组件和资源。如果你的游戏状态只是组件和资源，你通常可以做一些很酷的事情，比如克隆它们（像模拟器一样保存状态！）或轻松地序列化它，这在像系统闭包这样的东西中更难实现。</p>
<p>对普通 Rust 的收获：注册表模式实际上相当不错。在 Starbound 中有一个“根”对象，它有点像这个，每个类型都注册了，但它比这里描述的更具有状态性。它是只读的，但它是通过读取资产构建的。我实际上喜欢“类型注册表”的想法，当你想使用 AnyMap 这样的动态类型时，这是必要的，这两种模式很好地结合在一起，以限制“一切都依赖于一切”的问题。</p>
<h2 id="ECS-是游戏的-SQL"><a href="#ECS-是游戏的-SQL" class="headerlink" title="ECS 是游戏的 SQL"></a>ECS 是游戏的 SQL</h2><p>让我稍微揭开帷幕。我们到目前为止描述了什么：一种声明特殊类型键（实体）的方式，以及与这些键相关联的一系列记录（组件），另外还有定义不与这些键配对的记录的方式（资源）。我们引入了动态类型，并展示了一种模式，让你可以在一个地方定义你拥有的所有记录类型（有点像模式）。在我构建的真正的 ECS 中，我甚至有执行组件的原始“查询”的方式，比如说“给我所有具有位置的实体，可选具有速度，但不具有质量”。</p>
<p>这听起来可能非常熟悉，如果确实如此，有很好的理由。ECS 就是游戏的 SQL。一个非常、非常、非常有限的 SQL 形式，但精神上非常相似。定义你的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据模式，加载它，对它进行查询，然后更新它。非常有限的 SQL，其中每个查询可能必须在不超过几微秒的时间内运行。</p>
<p>我早些时候说过我读过很多糟糕的 ECS 介绍和一个好介绍。我不是第一个提到 ECS 和 SQL 之间平行的人，早在 2009 年，就有一篇文章关注 MMO 的这一点。</p>
<p>所以，如果这是真的，我们为什么不能只使用像 sqlite 这样的来存储我们的游戏状态？有趣的是，你可能真的可以做到这一点，但很难在 16 毫秒内运行查询足够快。让我们想想这将带来什么好处！哦，天哪，我需要为游戏制作一个保存格式..不，它是 SQL，我已经完成了。哦，我需要更新每个人的保存文件格式..写一些外部 SQL 更新脚本，你已经完成了！</p>
<p>哦，我想给游戏的任意状态保存的能力？完成了。我注意到一个错误，我想将游戏状态回滚到 30 秒前，然后逐步通过它，运行查询以查看何时产生了一个坏状态？完成了。所有这些仔细引入的代际索引概念，SQL 已经有了，它们是具有自动递增的键（更像是 <code>HashMap&lt;EntityId, T&gt;</code> 真的）。</p>
<p>那时，你的每个系统基本上将是一系列查询，从 SQL 中获取数据，进行一些更新，然后将其写回 SQL。我们已经将性感的游戏开发变成了无聊的老式 web 开发！（web 开发可以是性感的，游戏开发可以是无聊的，只是记录）</p>
<p>唯一的问题是我 <em>相当</em> 确定它慢了大约两个数量级，无法工作，但它是一个不错的想法，并且它是有用的，可以进行比较！</p>
<p>我认为这很重要，因为我看到很多关于“什么使某物成为纯粹的 ECS”的辩论，我认为这最终是非常愚蠢的。</p>
<ul>
<li><p>如果实体可以有多个组件，它是 ECS 吗？好吧，多个组件和只包含 Vec 的组件之间的差异非常非常少，但它仍然是 ECS。如果你有两个表是 1 到 N 而不是 1 到 1，它仍然是 SQL 吗？是的，当然。</p>
</li>
<li><p>如果我的组件有方法，它仍然是 ECS 吗？是的，添加组件方法并不是世界末日，特别是如果有一个小的局部不变性需要维护。SQL 是关于数据的，但它也有存储过程来维护不变性。</p>
</li>
<li><p>如果我需要两个不同的 ECS 集合，或者我把很多数据放入资源中，它仍然是 ECS 吗？我应该使用“单例实体”还是资源？它仍然是 SQL 如果我有两个不同的数据库，或者分开一个顶级表吗？是的，当然！</p>
</li>
</ul>
<p>……等等</p>
<p>这个类比不是完美的，但我认为这确实是一种启示。目前正在进行有关如何使更有能力的 ECS 系统具有组件图和组件与实体之间的子关系等的研究，当然这是可以的。SQL 已经有了所有这些，它是一种语言和一套软件，用于表达 <em>所有种类</em> 的数据关系，只是游戏通常有更简单的需求，将基本上总是在内存中，并且有纳秒或微秒的时间要求，所以我们妥协并制作了新工具。</p>
<p>这是另一个我做这次演讲的原因，帮助进一步揭开“ECS”的神秘面纱，并展示我们是如何来到这里的，并给出一些观点。</p>
<h2 id="一切都出错的地方"><a href="#一切都出错的地方" class="headerlink" title="一切都出错的地方"></a>一切都出错的地方</h2><p>（注意：我不知道我是否需要这一段，我只是在兜售我想要做的 <em>其他</em> 演讲。也许这不重要？这次演讲已经可能非常非常长了）</p>
<p>我一开始就声称，我见过的态度对借用检查器过于怀疑，认为它太限制性，这是胡说八道。我仍然绝对相信这一点，但我想快速谈谈我不断遇到问题的唯一地方，我真的 <em>只有</em> 遇到麻烦的地方，我不断感到受限。当然，随着项目规模的增长，<em>某些事情</em> 必须出错，对吧？好吧，我有一个例子，尽管这个问题并不局限于 Rust，它只是更 <em>立即</em> 痛苦（注意到一个模式？）。</p>
<p>语言边界很难。</p>
<p>所以，这里的问题都很难简洁地解释。我不确定我能否像以前一样提出小而有限的例子，而不深入到细节中，并使这次演讲的长度翻倍。我写了一个完整的 crate（rlua）来尝试解决这个问题，经过大量的工作，我可以自信地说我 <em>某种程度上</em> 只解决了一半。</p>
<p>我有一个组件的表示，你可以选择读取或写入每个组件（它们存储在 RwLocks 中以实现系统并发）。我想让 Lua 能够读取一组系统，所以我有一个 Lua 脚本对 ECS 存储执行“查询”。我所需要做的就是能够将 Lua 传递“RwLockReadGuard”（实际上是包含这个的结构）的查询返回，但是……</p>
<p>RwLockReadGuard 不是静态的。哦，我猜我只能在查询 API 中而不是在开始时一次性传递 Lua 查询锁定……那将是非常慢的，也不安全，查询应该在整个时间内锁定。我猜我可以使用租赁 crate……哦，天哪，租赁 crate 很难，这太可怕了。（后来我能够使用 rlua 的“范围”系统解决这个问题，但仍然很糟糕）。</p>
<p>最好你的系统不要有状态，对吧？通常系统应该将数据存储在它们操作的组件中，如果它们逻辑上相关，或者可能存储在自定义资源中，或者简单地存储一些缓存值，但要准备好如果系统重新加载，缓存将被重置。不要依赖不能被保存 &#x2F; 恢复 &#x2F; 序列化的数据。这很棒，直到你写了一个 Lua 系统，因为将值从 Lua 中提取出来实际上是真的很难。你不能将 Lua 状态存储在资源中，因为它不是 Sync，你也不能将 Lua 数据与状态分开存储，因为 Lua 内部状态和外部句柄真的不是 Sync。你可以使用一些神奇的 Lua 注册表键来解决这个问题，但如果你每个系统都有自己的 Lua 实例，如果你尝试在错误的上下文中使用 Lua 值，你就制造了一个脚枪，而且它们也不是可序列化的。</p>
<p>你可以制作一个数据类型，它仅限于数据而不是内部 Lua 类型，但然后你必须在它和非 lua 表示之间编写编组，所以每次你的脚本系统读取或写入这个存储，它都是 <em>非常慢</em> 的。一些慢速是来自复制数据，但大部分是来自本质上的 Lua API 慢速。</p>
<p>一切都很难，如果你真的尝试，它是可以工作的，但你感觉它应该比这更简单。这甚至比 C++ 中的等价物更难，但 C++ 中的等价物实际上和这一样糟糕，你只是在 Rust 中更快地注意到它。</p>
<p>至少没有不断的崩溃和 shared_ptr 循环了？</p>
<p>看起来有点类似于我们之前的情况，我们尝试了面向对象的错误方法。不幸的是，在 rlua 的情况下，有一些基于 Lua 内部 C API 如何工作的硬性限制，它可能接近我能提供的最好的东西。</p>
<p>语言边界很难，尤其是当它们有非常不同的限制集合的语言之间，比如 Rust 和 Lua（或 C++ 和 Lua）。特别是当被包含语言中的垃圾收集器与宿主语言中的垃圾收集器接触时，一切都不会工作，什么都不会被收集。（在 C++ &#x2F; Rust 中，这是 shared_ptr &#x2F; Arc，是的，这些是一种垃圾收集器）</p>
<p>我提到这个是因为我认为 Lua 非常受游戏开发者的欢迎，我经常收到关于如何将 rlua 与像 specs 这样的东西结合的问题，我认为这真的很难，并且违背了我在这次演讲中提出的更大观点。我认为这可能是 <em>独特地</em> 难，因为语言边界非常棘手，情况并不比 C++ 中的更糟或更好，它稍微更难，但更安全，只是稍微更难不是一个很好的答案，当在 C++ 中它仍然非常困难时。</p>
<p>我还提到这个，因为我可能很快就会有一个答案！我考虑做的 <em>另一个</em> 演讲是描述我认为是一种新颖的方式，在 Rust 中安全地实现语言运行时，它们有垃圾收集，并且是零成本的，并且具有快速、大部分无痛（或尽可能）的绑定体验。</p>
<p>与此同时，在你添加游戏引擎的脚本层之前，请仔细考虑。问题是，我 <em>爱</em> 游戏引擎中的脚本层（出于可修改性和许多其他原因），所以我无论如何都会这样做，但这不是一个轻松的决定，它可以消耗大量的时间和精力。我想让这更无痛，并且使一个安全、快速的 Lua 在 Rust 中感觉像家一样，就像 PUC-Rio 的 Lua 在 C 中感觉像家一样。我将来会谈论这个！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我这次演讲有多个目的：</p>
<ul>
<li>为那些只有小规模项目经验的人，走过一个中等规模 Rust 项目的设计理念。</li>
<li>展示一些陷阱的例子，人们可能会陷入其中，从而“与借用检查器战斗”，并帮助更具体地了解如何至少部分地越过这个阶段。</li>
<li>展示数据导向编程有多么棒，以及它对游戏和 Rust 是多么合适的</li>
<li>展示在 Rust 中应用的游戏开发模式，这些模式在 Rust 出现之前就已经出现了，仍然似乎是一个很好的选择。</li>
</ul>
<p>我谈论了很多在其他语言中经过艰苦斗争的模式，只有在费力地探索了最终不成功的解决方案的空间后才会出现。有趣的是，那些最终效果不佳的解决方案通常会更快地在 Rust 中引起痛苦，它们更响亮，更烦人。我认为这是一件好事，我喜欢有工具让糟糕的模式感觉和它们一样糟糕。Rust 在这方面 _很棒_。</p>
<p>但你可以把这里的大部分教训同样容易地应用在 C++ 中吗？在 C 中吗？是的，绝对可以。即使你是那种即使没有这种语言压力也不会犯这些错误的人（你比我强多了），还有很多其他的好处。</p>
<p>我实际上没有机会谈论 Rust 的所有好处或谈论我使用 Rust 的一般经验，因为我只有 30 分钟，而这一点可能已经超过了 30 分钟。</p>
]]></content>
      <categories>
        <category>rust语言</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约漏洞检测论文</title>
    <url>/2024/09/05/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>智能合约漏洞检测论文</p>
<span id="more"></span>

<p>来自 dblp 搜索结果，<a href="https://dblp.org/search?q=fuzz%20smart%20contract">https://dblp.org/search?q=fuzz%20smart%20contract</a></p>
<ol>
<li>ContractFuzz<strong>er:</strong> Fuzz<strong>ing</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>Fuse: An Architecture for</strong> Smart Contract Fuzz <strong>Testing Service</strong></li>
<li><strong>Harvey: A Greybox</strong> Fuzz<strong>er for</strong> Smart Contract<strong>s</strong></li>
<li><strong>A</strong> Fuzz <strong>Testing Service for Assuring</strong> Smart Contract<strong>s</strong></li>
<li><strong>SoliAudit:</strong> Smart Contract <strong>Vulnerability Assessment Based on Machine Learning and</strong> Fuzz <strong>Testing</strong></li>
<li><strong>Robot Coalition Formation Based on</strong> Fuzz<strong>y Cooperative Games over Blockchain-Based</strong> Smart Contract<strong>s</strong></li>
<li>Fuzz<strong>y Cooperative Games Usage in</strong> Smart Contract<strong>s for Dynamic Robot Coalition Formation: Approach and Use Case Description</strong></li>
<li><strong>Efficient Funds Allocation System Based on</strong> Fuzz<strong>y Logic and</strong> Smart Contract<strong>s.</strong></li>
<li><strong>Learning to</strong> Fuzz <strong>from Symbolic Execution with Application to</strong> Smart Contract<strong>s.</strong></li>
<li><strong>EOSFuzzer:</strong> Fuzz<strong>ing EOSIO</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>Towards</strong> Smart <strong>Hybrid</strong> Fuzz<strong>ing for</strong> Smart Contract<strong>s</strong></li>
<li><strong>sFuzz: An Efficient Adaptive</strong> Fuzz<strong>er for Solidity</strong> Smart Contract<strong>s</strong></li>
<li><strong>EthPloit: From</strong> Fuzz<strong>ing to Efficient Exploit Generation against</strong> Smart Contract<strong>s.</strong></li>
<li><strong>Testing Ethereum</strong> Smart Contract<strong>s: A Comparison of Symbolic Analysis and</strong> Fuzz <strong>Testing Tools</strong></li>
<li><strong>Echidna: effective, usable, and fast</strong> fuzz<strong>ing for</strong> smart contract<strong>s.</strong></li>
<li><strong>EOSFuzzer:</strong> Fuzz<strong>ing EOSIO</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>sFuzz: an efficient adaptive</strong> fuzz<strong>er for solidity</strong> smart contract<strong>s</strong></li>
<li><strong>I Can Get Some Satisfaction:</strong> Fuzz<strong>y Ontologies for Partial Agreements in Blockchain</strong> Smart Contract<strong>s</strong></li>
<li><strong>GasFuzzer:</strong> Fuzz<strong>ing Ethereum</strong> Smart Contract <strong>Binaries to Expose Gas-Oriented Exception Security Vulnerabilities</strong></li>
<li>HFContractFuzzer: Fuzzing Hyperledger Fabric Smart Contracts for Vulnerability Detection. <a href="https://dblp.org/db/conf/ease/ease2021.html#DingLLZ21">EASE 2021</a>: 321-328</li>
<li>ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts. <a href="https://dblp.org/db/conf/eurosp/eurosp2021.html#TorresIGS21">EuroS&amp;P 2021</a>: 103-119</li>
<li>echidna-parade: a tool for diverse multicore smart contract fuzzing.<a href="https://dblp.org/db/conf/issta/issta2021.html#GroceG21">ISSTA 2021</a>: 658-661</li>
<li>SMARTIAN: Enhancing Smart Contract Fuzzing with Static and Dynamic Data-Flow Analyses.<a href="https://dblp.org/db/conf/kbse/ase2021.html#0001K0GGC21">ASE 2021</a>: 227-239</li>
<li>Increasing Fuzz Testing Coverage for Smart Contracts with Dynamic Taint Analysis.<a href="https://dblp.org/db/conf/qrs/qrs2021.html#JiDQGWW21">QRS 2021</a>: 243-247</li>
<li>Ambulance Vehicle Routing under Pandemic with Fuzzy Cooperative Game via Smart Contracts. <a href="https://dblp.org/db/conf/vehits/vehits2021.html#SmirnovT21">VEHITS 2021</a>: 538-545</li>
<li><strong>AntFuzzer: A Grey-Box</strong> Fuzz<strong>ing Framework for EOSIO</strong> Smart Contract<strong>s</strong></li>
<li><strong>TokenAuditor: Detecting Manipulation Risk in Token Smart Contract by Fuzzing.</strong> <a href="https://dblp.org/db/conf/qrs/qrs2022.html#CaoZFHZ22">QRS 2022</a>: 651-662</li>
<li><strong>Effectively Generating Vulnerable Transaction Sequences in Smart Contracts with Reinforcement Learning-guided Fuzzing.</strong> <a href="https://dblp.org/db/conf/kbse/ase2022.html#SuDZZL22">ASE 2022</a>: 36:1-36:12</li>
<li><strong>SynTest-Solidity: Automated Test Case Generation and Fuzzing for Smart Contracts.</strong> <a href="https://dblp.org/db/conf/icse/icse2022c.html#OlsthoornSDP22">ICSE-Companion 2022</a>: 202-206</li>
<li><strong>Smart Contract Fuzzing for Enterprises: The Language Agnostic Way.</strong> <a href="https://dblp.org/db/conf/comsnets/comsnets2022.html#PaniNPVMR22">COMSNETS 2022</a>: 1-6</li>
<li><strong>An Empirical Study on the Effects of Entry Function Pairs in Fuzzing Smart Contracts.</strong> <a href="https://dblp.org/db/conf/compsac/compsac2022.html#AshrafC22">COMPSAC 2022</a>: 1716-1721</li>
<li><strong>Grey-box Fuzzing Based on Execution Feedback for EOSIO Smart Contracts.</strong> <a href="https://dblp.org/db/conf/apsec/apsec2022.html#LiWYSFS22">APSEC 2022</a>: 1-10</li>
<li><strong>Privacy-preserving smart contracts for fuzzy WordNet-based document representation and clustering using regularised K-means method.</strong> <a href="https://dblp.org/db/journals/ijahuc/ijahuc40.html#ThathaBH22">Int. J. Ad Hoc Ubiquitous Comput. 40(1&#x2F;2&#x2F;3)</a>: 2-9 (2022)</li>
<li><strong>Are We There Yet? Unraveling the State-of-the-Art Smart Contract Fuzzers.</strong> <a href="https://dblp.org/db/conf/icse/icse2024.html#Wu0YCJWLZ24">ICSE 2024</a>: 127:1-127:13</li>
</ol>
]]></content>
      <categories>
        <category>智能合约</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>LibAFL学习资料整理</title>
    <url>/2024/09/05/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/libfuzz%E6%8B%93%E8%8D%92/</url>
    <content><![CDATA[<p>LibAFL学习资料</p>
<span id="more"></span>

<p>libfuzz：</p>
<p>LibAFL github 仓库：<a href="https://github.com/AFLplusplus/LibAFL">https://github.com/AFLplusplus/LibAFL</a></p>
<p><a href="https://www.youtube.com/watch?v=3RWkT1Q5IV0">Fuzzers Like Lego @rC3 - YouTube</a>中讲到：没有最好的 fuzzer,只有针对使用常见特异性改造的 fuzzer 才是好 fuzzer, AFL 作为奠基石，但是在各个环节都是由改进空间的。</p>
<p>另一个pre:<a href="https://www.youtube.com/watch?v=PWB8GIhFAaI">LibAFL: The Advanced Fuzzing Library - Andrea Fioraldi &amp; Dominik Maier @FuzzCon Europe 2021</a></p>
<p>libfuzz 文档介绍：<a href="https://aflplus.plus/libafl-book/getting_started/crates.html">Crates - The LibAFL Fuzzing Library (aflplus.plus)</a></p>
<p>fuzz101实验：<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">fuzz101</a></p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>NYX官网：<a href="https://nyx-fuzz.com/">Nyx (nyx-fuzz.com)</a></p>
<p>NYX一个 pre:<a href="https://www.youtube.com/watch?v=f5uhWesvjZ8">Thorsten Holz - Fuzz Testing and Beyond (youtube.com)</a></p>
<p>欠缺的知识图谱：</p>
<p>符号执行</p>
<p>污点分析</p>
<p>qemu模式</p>
<p>asan</p>
<p>frada</p>
<p>实操：</p>
<p>漏洞复现</p>
<p>gdb调试</p>
<p>ida使用</p>
<p>逆向能力</p>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>LibAFL</tag>
      </tags>
  </entry>
  <entry>
    <title>符号执行</title>
    <url>/2023/12/05/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>rust语言与数据导向编程</p>
<span id="more"></span>

<p>原文地址：<a href="https://www.atredis.com/blog/2022/10/29/symbolic-triage-making-the-best-of-a-good-situation"><strong>Symbolic Triage: Making the Best of a Good Situation</strong></a></p>
<hr>
<p><strong>符号执行：在好情况下做到最好 — Atredis Partners</strong></p>
<p>符号执行有时会被误解。通用的符号执行工具在面对足够复杂的目标时，很难证明其价值。然而，我发现在某些特定的情况下，符号执行可以非常有帮助。其中一种情况是在处理来自模糊测试器的大量崩溃时，尤其是在处理复杂或不透明的目标时。这就是我之前遇到的“好情况”，我的模糊测试器给了我大量的崩溃，这些崩溃抵抗了常规的最小化和去重。通过构建一个小型的符号调试器，我管理了一个从模糊测试案例到完全理解的更快的响应时间。</p>
<p>在这篇文章中，我想分享我为崩溃分类编写符号执行工具的过程，并尝试突出我使用的一些技巧，使工具更有效和灵活。这里的例子都使用了伟大的<a href="https://triton-library.github.io/">Triton</a>库来进行我们的象征执行和求解。所有示例的代码都托管在：<a href="https://github.com/atredis-jordan/SymbolicTriagePost">github.com&#x2F;atredis-jordan&#x2F;SymbolicTriagePost</a></p>
<blockquote>
<p>（顺便说一下，我们有一个课程！）你是否在你的工作流程中进行逆向工程和符号执行，或者想要这样做？</p>
<p>你是否正在使用模糊测试，但希望找到更多机会来改进它，并发现更深入、更有趣的漏洞？</p>
<p>你能否在网络空间与控制台牛仔一起混？</p>
<p>我们开发了一个为期4天的课程，名为“实用符号执行用于VR和RE”，专为这些目标量身定制。它既有趣又实用，有很多演示和实验室，让你练习以创造性的方式应用这些概念。如果你对此感兴趣，可以在本文底部找到更多信息。希望在那里见到你！</p>
</blockquote>
<p>我们将使用_Procmon64.exe_中的一堆崩溃作为我们的示例。Procmon解析PML（进程监视器日志）文件非常容易出错，我们可以在短时间内从模糊测试会话中快速获得大量崩溃。它是一个大型的不透明二进制文件，崩溃具有一些非确定性，因此有用的工具将帮助我们加快逆向工程的努力。请注意，我们并没有尝试在Procmon中找到漏洞；因此，尽管我们将在这里讨论的这些漏洞对攻击者来说似乎并不特别有用，但我也不会在不久的将来打开任何不受信任的PML文件。</p>
<p>我通过制作一些非常小的PML文件并将Jackalope对准目标，收集了一堆崩溃。几个小时后，我们有大约200个奇怪的崩溃可以玩。许多崩溃是不稳定的，偶尔才会重现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">..\\Jackalope\\Release\\fuzzer.exe -iterations_per_round 30 -minimize_samples false -crash_retry 0 -nthreads 32 -in - -resume -out .\\out -t 5000 -file_extension PML -instrument_module procmon64.exe -- procmon64.exe /OpenLog @@ /Quiet /Runtime 1 /NoFilter /NoConnect</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Jackalope对Procmon的PML解析器进行模糊测试</p>
</blockquote>
<h2 id="一个简单的调试器"><a href="#一个简单的调试器" class="headerlink" title="一个简单的调试器"></a>一个简单的调试器</h2><p>在所有这些符号执行的炒作中，我们的第一步是不要使用符号执行！知道何时转向符号执行，何时仅使用仿真或调试器是一个好技能。在这种情况下，我们将编写一个非常简单的调试器，使用Windows调试API。这个调试器可以用来重新运行我们的崩溃输入，找出它们的稳定性，看看它们是否都发生在主线程中，收集堆栈跟踪等。</p>
<p>此外，拥有一个程序化调试器在我们开始符号执行时将非常有用。我们将在稍后讨论这个问题，首先让我们的调试器启动。</p>
<blockquote>
<p>快速旁注。我这里所有的代码示例都是用Python编写的，因为我喜欢在调试器中能够进入IPython。我在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/win_types.py">win_types.py</a>文件中定义了一堆ctypes结构。我建议有一些程序化的方式来生成你需要的类型。可以查看<a href="https://github.com/horsicq/PDBRipper">PDBRipper</a>或<a href="https://github.com/microsoft/microsoft-pdb/blob/master/cvdump/cvdump.exe">cvdump</a>作为一个好的开始。</p>
</blockquote>
<p>好的，所以我们首先想要一个调试器，可以运行进程直到它崩溃并收集异常信息。基本前提是我们开始一个被调试的进程（我们在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L77">triage.py中的_connect_debugger_函数</a>），然后等待它直到我们得到一个未处理的异常。像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handle, main_tid = connect_debugger(cmd)</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;process&quot;</span>, <span class="number">3</span>, <span class="string">f&quot;: -- &quot;</span>)</span><br><span class="line"></span><br><span class="line">event = dbg_wait(handle, <span class="literal">None</span>)</span><br><span class="line">code = event.dwDebugEventCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> code == EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; Closed with no crash&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> code == EXCEPTION_DEBUG_EVENT:</span><br><span class="line">    <span class="comment"># 需要调查的异常</span></span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; crashed:&quot;</span>)</span><br><span class="line">    er = event.u.Exception.ExceptionRecord</span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, exceptionstr(handle, er, event.dwThreadId))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    log(<span class="string">&quot;process&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; hit unexpected Debug Event &quot;</span>)</span><br><span class="line"></span><br><span class="line">dbg_kill(handle)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>triage.py的handle_case的一部分，运行单个测试案例</p>
</blockquote>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1325b83b-f8de-419b-b515-2802b291355d/crash.png" alt="img"></p>
<p><em>运行上述代码以获取崩溃的异常信息</em></p>
<p>许多崩溃不会每次都发生，因为某些非确定性。在我们的调试器中多次运行所有测试案例，我们可以构建一个最稳定的崩溃的图景，如果它们保持在主线程中，以及发生了什么类型的异常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx008_00000xxxxxxxx5AA_1.PML -- 100% (18) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x5aa</span><br><span class="line">        EXCEPTION_STACK_BUFFER_OVERRUN(0xc0000409) @ 0x83c</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx008_00000xxxxxxxx5AA_2.PML -- 100% (34) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x5aa</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx063_00000xxxxxxxx3ED_1.PML -- 100% (34) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x3ed</span><br><span class="line">...</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx3D4_00000xxxxxxxxED1_2.PML -- 52% (23) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed1</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx234_00000xxxxxxxxED4_3.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx3CA_00000xxxxxxxxED1_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed1</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx5EC_00000xxxxxxxx0A2_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx5EF_00000xxxxxxxxF27_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xecb</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxxB46_00000xxxxxxxxFF4_1.PML -- 44% (18) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx25A_00000xxxxxxxxED4_1.PML -- 38% (21) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xecb</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x19d read at 0x184</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从多次运行中收集的信息</p>
</blockquote>
<blockquote>
<p>让我再快速旁注一下。Windows异常很棒，因为它们可以包含额外的信息。异常记录告诉我们访问违规是读取还是写入，以及导致故障的指针。在Linux上，这很难以编程方式获取，因为SEGFAULT只是一个SEGFAULT。在这里，我们可以使用我们的符号执行引擎仅提升出错的指令。引擎将为我们提供有关发生什么加载或存储的缺失信息，让我们区分无聊的NULL读取和令人兴奋的超出页面末尾的写入。</p>
</blockquote>
<h2 id="让我们的符号执行运行起来，以及一些技巧"><a href="#让我们的符号执行运行起来，以及一些技巧" class="headerlink" title="让我们的符号执行运行起来，以及一些技巧"></a>让我们的符号执行运行起来，以及一些技巧</h2><p>现在我们有一个使用Windows调试API（或_ptrace_或任何其他）的简单调试器。现在我们可以将我们的符号引擎混合到其中。计划是使用我们的调试器运行目标，直到我们的输入在某个地方的内存中。然后我们将输入标记为符号，并在我们的符号引擎中跟踪其余的指令。</p>
<blockquote>
<p>将输入标记为“符号”这里意味着我们正在告诉我们的引擎这些值将被跟踪为变量，而不仅仅是数字。这将让我们看到的所有表达式都是以我们的输入变量的形式，比如“rax: (add INPUT_12 0x12)”而不是只是“rax: 0x53”。一个更好的术语可能是“混合的”（具体-符号），因为我们仍然使用这些输入字节的实际值，只是在它们上面添加了符号信息。不过，我在这篇文章中还是使用了符号这个术语。</p>
</blockquote>
<p>我们的调试器会告诉我们何时到达异常。从那里我们可以在崩溃时的状态中检查我们符号输入的信息。对于访问违规，我们希望能够看到被解引用的指针是符号的“_(0xwhatever + INPUT_3c)_”或其他一些符号表达式，显示我们的输入中是什么导致了崩溃。</p>
<p>这些信息对于根本原因分析崩溃（我们将在下一节中看到一些处理这些信息的很酷的技巧）非常有用。我们收集这些符号信息，这样我们就可以利用保持我们在崩溃路径上的约束，以及我们自己的约束，并将这些发送到求解器。使用求解器，我们可以问“什么输入会使这个指针变成X？”这让我们能够快速识别一个Write-What-Where从Read8-AroundHere，或者一个Write-That-ThereGiveOrTake100。我们可以在跟踪的任何点中断我们的象征性调试器，并使用求解器来回答我们的问题。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/41d0f85f-c26e-4c2e-9ae9-ba6e318403c6/check_value.png" alt="img"></p>
<p><em>在断点处停止，并看到什么输入会使RBX等于0x12340000</em></p>
<p>注意：我应该指出，严格来说，使用调试器并不是必需的。我们可以只加载_procmon64.exe_及其库到我们的象征执行引擎中，然后在没有调试器的帮助下模拟指令。如果你看到<a href="https://github.com/JonathanSalwan/Triton/tree/master/src/examples">Triton存储库中的伟大示例</a>，你会注意到它们没有跟随调试器步骤。我喜欢将符号执行引擎与调试器一起使用有几个原因。我将在以下段落中突出其中一些原因。</p>
<p>主要原因可能是为了避免自己被误导。有了调试器或具体执行跟踪，我可以跟随一个我可以跟随的真实情况。没有它，当我在设置我们的执行环境时犯错误时，很容易直到后来才意识到。比如不正确地加载库、处理重定位或在Windows上设置_TEB_和_PEB_。通过使用调试器，我们可以通过从实际进程中拉取内存块来设置我们的执行环境。我们还可以按需加载内存，这样我们可以在非常大的进程上节省时间。在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L643">我们的示例中</a>，我们使用Triton的_GET&#x2F;SET_CONCRETE_MEMORY_VALUE_回调懒加载内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tri_init</span>(<span class="params">handle, onlyonsym=<span class="literal">False</span>, memarray=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 进行TritonContext的基本初始化</span></span><br><span class="line"></span><br><span class="line">    ctx = TritonContext(ARCH.X86_64)</span><br><span class="line">    ctx.setMode(MODE.ONLY_ON_SYMBOLIZED, onlyonsym)</span><br><span class="line">    <span class="keyword">if</span> memarray:</span><br><span class="line">        ctx.setMode(MODE.MEMORY_ARRAY, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ctx.setMode(MODE.ALIGNED_MEMORY, <span class="literal">True</span>)</span><br><span class="line">    ctx.setMode(MODE.AST_OPTIMIZATIONS, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置延迟内存加载</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmemcb</span>(<span class="params">ctx, ma</span>):</span><br><span class="line">        addr = ma.getAddress()</span><br><span class="line">        sz = ma.getSize()</span><br><span class="line">        <span class="comment"># 只会加载之前没有加载过的页面</span></span><br><span class="line">        tri_load_dbg_mem(ctx, handle, addr, sz, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setmemcb</span>(<span class="params">ctx, ma, val</span>):</span><br><span class="line">        addr = ma.getAddress()</span><br><span class="line">        sz = ma.getSize()</span><br><span class="line">        <span class="comment"># 只会加载之前没有加载过的页面</span></span><br><span class="line">        tri_load_dbg_mem(ctx, handle, addr, sz, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ctx.addCallback(CALLBACK.GET_CONCRETE_MEMORY_VALUE, getmemcb)</span><br><span class="line">    ctx.addCallback(CALLBACK.SET_CONCRETE_MEMORY_VALUE, setmemcb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py中设置Triton</p>
</blockquote>
<p>调试器还让我们处理我们的象征执行引擎不知道的指令。例如，Triton没有定义’<em>rdrand</em>‘指令。通过与我们的调试器单步执行，我们可以在遇到未知指令时简单地修正任何更改的寄存器。这可能会导致如果我们的符号输入与指令一起做某些事情时，符号信息的丢失，但大多数情况下我们可以忽略这些指令。</p>
<p>最后，使用我们的调试器给我们带来了另一个非常好的好处；我们可以跳过整个无关代码的区域！我们必须非常小心地标记什么为无关，因为做错了可能意味着我们失去了很多符号信息。对于procmon，我将大部分绘图代码标记为无关。当从user32或gdi32中击中这些导入之一时，我们放置一个断点并让调试器跨过这些调用，然后恢复与Triton的单步执行。这节省了大量的时间，因为符号执行比实际执行慢了几个数量级。我们可以跨过的任何无关代码都可以产生巨大的差异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跳过绘图代码</span></span><br><span class="line"><span class="keyword">if</span> skip_imports:</span><br><span class="line">    impfuncs = dbg_get_imports_from(handle, base, [<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;gdi32.dll&quot;</span>, <span class="string">&quot;comdlg32.dll&quot;</span>, <span class="string">&quot;comctl32.dll&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> impfuncs:</span><br><span class="line">        addr = impfuncs[name]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不跳过一些user32的</span></span><br><span class="line">        skip = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> ds <span class="keyword">in</span> [<span class="string">&quot;PostMessage&quot;</span>, <span class="string">&quot;DefWindowProc&quot;</span>, <span class="string">&quot;PostQuitMessage&quot;</span>, <span class="string">&quot;GetMessagePos&quot;</span>, <span class="string">&quot;PeekMessage&quot;</span>, <span class="string">&quot;DispatchMessage&quot;</span>, <span class="string">&quot;GetMessage&quot;</span>, <span class="string">&quot;TranslateMessage&quot;</span>, <span class="string">&quot;SendMessage&quot;</span>, <span class="string">&quot;CallWindowProc&quot;</span>, <span class="string">&quot;CallNextHook&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> ds.lower() <span class="keyword">in</span> name.lower():</span><br><span class="line">                skip = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> skip:</span><br><span class="line">            hooks[addr] = (skipfunc_hook, name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py中跳过不需要的导入</p>
</blockquote>
<p>对于我们的目标，跳过导入还不够。我们仍然在procmon二进制文件中的循环中花费大量时间。快速查看确认这些是静态包含的_memset_和_memcpy_。我们不能只是跳过_memcpy_，因为我们会失去正在复制的符号信息。因此对于这两个，我们编写了一个钩子，会在Python中以符号方式处理操作，而不必模拟每条指令。我们确保复制的字节在源数据中获得了符号表达式的副本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    sa = MemoryAccess(src + i, <span class="number">1</span>)</span><br><span class="line">    da = MemoryAccess(dst + i, <span class="number">1</span>)</span><br><span class="line">    cell = ctx.getMemoryAst(sa)</span><br><span class="line">    expr = ctx.newSymbolicExpression(cell, <span class="string">&quot;memcpy byte&quot;</span>)</span><br><span class="line">    ctx.assignSymbolicExpressionToMemory(expr, da)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在我们的memcpy钩子中传输符号信息</p>
</blockquote>
<p>这些类型的钩子不仅节省了我们的时间，而且是一个检查_memcpy_或_memset_中符号参数的绝佳机会。即使当前跟踪不会在_memcpy_中崩溃，我们也有能力查看这些符号参数并询问“这个_memcpy_能否到达未映射的内存？”或者“大小参数是否不合理地大？”。这可以帮助我们找到其他漏洞，或者我们已经跟踪的问题的其他表达方式。以下是一个小检查，试图看看_memcpy_的目的地的结尾是否可以很远。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">astctx = ctx.getAstContext()</span><br><span class="line">cond = ctx.getPathPredicate()</span><br><span class="line"><span class="comment"># dst + size</span></span><br><span class="line">dstendast = ctx.getRegisterAst(ctx.registers.rcx) + ctx.getRegisterAst(ctx.registers.r8)</span><br><span class="line"><span class="comment"># dst + size的具体值</span></span><br><span class="line">dstendcon = dst + size</span><br><span class="line">testpast = <span class="number">0x414141</span></span><br><span class="line">cond = astctx.land([cond, (dstendcon + testpast) &lt;= dstendast])</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;hook&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Trying to solve for a big memcpy&quot;</span>)</span><br><span class="line">model, status, _ = ctx.getModel(cond, <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">if</span> status == SOLVER_STATE.SAT:</span><br><span class="line">    <span class="comment"># 可以走那么远</span></span><br><span class="line">    <span class="comment"># 这可能不是我们崩溃的原因，所以让我们只是报告它，而不是引发它</span></span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">2</span>, <span class="string">&quot;Symbolic memcpy could go really far!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py的memcpy钩子中的一个简单检查</p>
</blockquote>
<p>这些检查的权衡是经常调用求解器可能会增加我们的运行时间，你可能不希望它们一直启用。</p>
<p>到目前为止，我们已经拥有了运行我们的崩溃案例并开始去重和根本原因分析所需的大部分内容。然而，我们的一些访问违规仍然表示错误的解引用不依赖于我们的输入。这对我来说没有意义，因此我怀疑我们在某个地方丢失了符号信息。有时这可能由于指针的具体化而发生，因此打开Triton的新_MEMORY_ARRAY_模式可以帮助我们恢复该信息（以速度为代价）。</p>
<p>在这种情况下，我让我的工具在跟踪过程中打印出所有被调用的导入函数。我想看看路径上的任何系统调用是否会导致符号信息的丢失。或者是否有一个调用重新引入了输入而没有被符号化。我发现还有一个对_MapViewOfFile_的第二个调用，它将我们的输入文件重新映射到内存中的另一个位置。通过<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L861">添加一个钩子</a>来符号化重新映射的输入，现在所有的崩溃都正确地报告了它们与输入的符号关系！</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/7a06203f-edfd-4b81-816a-99f01c6d8a79/crashast.png" alt="img"></p>
<p><em>我们的工具显示了一个坏解引用的AST</em></p>
<h2 id="使用我们的象征性调试器"><a href="#使用我们的象征性调试器" class="headerlink" title="使用我们的象征性调试器"></a>使用我们的象征性调试器</h2><p>酷！现在我们有了我们崩溃的符号信息。我们用它做什么？</p>
<p>首先，我们可以快速根据它们依赖的输入将我们的崩溃进行分组。这非常有帮助；即使一些问题可能导致多个位置的崩溃，我们仍然可以根据确切的输入缺乏边界检查将它们组合在一起。这可以帮助我们更好地理解一个错误，并看到错误与系统的不同交互方式。</p>
<p>通过分组我们的崩溃，看起来我们的200个左右的崩溃可以归结为四个不同的组：三个被控制的指针被读取和一个调用___fastfail_。</p>
<p>Triton给我们的一个很酷的工具是反向切片！因为Triton在构建它的符号表达式时可以保持与相关指令的引用，我们可以生成一个只包含与我们最终表达式相关的指令的指令跟踪。我使用这个来削减大部分代码作为无关的，并能够只走输入和崩溃之间的相关代码片段。以下是我们收集的有关一个崩溃中被解引用的坏指针的相关指令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backslice_expr</span>(<span class="params">ctx, symbexp, print_expr=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 按refId排序以按时间顺序</span></span><br><span class="line">    <span class="comment"># 从加载访问中获取符号表达式，可以这样做：</span></span><br><span class="line">    <span class="comment"># symbexp = inst.getLoadAccess()[0][0].getLeaAst().getSymbolicExpression()</span></span><br><span class="line">    items = <span class="built_in">sorted</span>(ctx.sliceExpressions(symbexp).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, expr <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> print_expr:</span><br><span class="line">            <span class="built_in">print</span>(expr)</span><br><span class="line">        da = expr.getDisassembly()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(da) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> <span class="keyword">if</span> print_expr <span class="keyword">else</span> <span class="string">&quot;&quot;</span>, da)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>triage.py中的一个反向切片助手</p>
</blockquote>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/8f5fd529-b03a-4a4a-8527-1d29f63cfa2c/backslice_sm.png" alt="img"></p>
<p><em>使用上述代码进行反向切片</em></p>
<p>能够在跟踪的任何点进入IPython REPL并看到程序状态以我的输入为依据在我的RE过程中非常有帮助。</p>
<p>对于调用___fastfail_（有点像Windows的_abort_），我们这里没有坏解引用来进行反向切片，相反我们有我们的引擎收集的路径约束。这些约束是任何时候引擎看到我们可以在交叉路口象征性地走两条路时捕获的。为了保持与我们的具体路径的联系，引擎记录了我们路径所需的条件。例如：如果我们在将INPUT_5字节与0比较后采取了一个_jne_分支，引擎将添加一个路径约束，说“如果你想继续我们走的路径，请确保INPUT_5不是0”，或者用AST的话说“_(not (&#x3D; INPUT_5 (_ bv0 8))_)”。</p>
<p>这些路径约束非常有用。我们可以使用它们来生成其他输入，这些输入会走未探索的路径。有很多不错的符号执行工具使用这个来帮助模糊测试器生成有趣的新输入。（<a href="https://github.com/eurecom-s3/symcc">SymCC</a>、<a href="http://klee.github.io/">KLEE</a>、<a href="https://github.com/shellphish/driller">Driller</a>，举三个例子）</p>
<p>在我们的情况下，我们可以检查它们来找出为什么我们最终到达了___fastfail_。通过仅查看最近的路径约束，我们可以看到由于我们的输入，我们的路径最近在哪里分叉。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/3ce16869-7e3a-4bf6-8aa5-8ed45016f63c/abort_constraint.png" alt="img"></p>
<p><em>导致___fastfail_的最最近的路径约束</em></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/00f6dda5-90e0-4f16-b572-391f25baf398/constraint_path.png" alt="img"></p>
<p><em>最最近的路径约束周围的汇编</em></p>
<p>路径约束告诉我们，上面的汇编中的条件跳转在_0x7FF7A3F43517_是我们的路径由于我们的输入值而最后一次分叉的地方。当我们在分叉后跟踪路径时，我们可以看到它总是直接导致我们的致命条件。为了获取更多关于分叉前的比较失败的信息，我为我们在该连接处进入了一个IPython shell。我们的工具使我们可以轻松地确定我们在分支前解引用的RCX指针的控制。这使这成为另一个由于控制指针读取而导致的崩溃。</p>
<p>显示分支前解引用寄存器的AST</p>
<h2 id="从这里去哪里"><a href="#从这里去哪里" class="headerlink" title="从这里去哪里"></a>从这里去哪里</h2><p>所以从这里我们对_procmon64.exe_中存在的问题有了一个很好的理解。更深入地研究崩溃显示它们可能不适用于制作恶意PML文件。如果我想继续走这条路，我的下一步将包括：</p>
<ul>
<li>根据已知的输入中未检查的区域为我们的模糊测试器生成有趣的测试案例</li>
<li>识别我们利用路径中看起来很有吸引力的函数。有了我们的工具，我们可以收集有关我们在这些函数中拥有的控制的信息。有了这些信息，我们可以开始路径探索或生成遵循我们对看起来有趣的区域的直觉的模糊测试案例。</li>
<li>修补不感兴趣的崩溃位置，并让我们的模糊测试器在不被低挂的果实阻止的情况下找到更好的路径。</li>
<li><a href="https://forum.spacehey.com/topic?id=93101">为了好玩，生成一个非常小的崩溃输入</a>。</li>
</ul>
<p>微软的官方政策是“所有Sysinternals工具都是‘按原样’提供的，没有官方的微软支持。”我们未能找到一个合适的地方来报告这些问题。如果任何与Sysinternals套件有联系的人想要更多信息，请与我们联系。</p>
<h2 id="希望这有所帮助！来参加课程吧！"><a href="#希望这有所帮助！来参加课程吧！" class="headerlink" title="希望这有所帮助！来参加课程吧！"></a>希望这有所帮助！来参加课程吧！</h2><p>我希望这篇文章能帮助你看到创造性的符号执行工具如何帮助他们的工作流程！如果有人有任何问题或想要谈论它，可以通过@jordan9001或<a href="mailto:&#106;&#111;&#114;&#100;&#97;&#x6e;&#x2e;&#119;&#104;&#x69;&#x74;&#x65;&#x68;&#101;&#97;&#100;&#x40;&#x61;&#x74;&#114;&#x65;&#100;&#x69;&#115;&#46;&#99;&#x6f;&#x6d;">&#106;&#111;&#114;&#100;&#97;&#x6e;&#x2e;&#119;&#104;&#x69;&#x74;&#x65;&#x68;&#101;&#97;&#100;&#x40;&#x61;&#x74;&#114;&#x65;&#100;&#x69;&#115;&#46;&#99;&#x6f;&#x6d;</a>给我发消息。</p>
<p>如果你读到了这篇文章的最后，你可能会喜欢我们的课程！</p>
<p>“实用符号执行用于VR和RE”是动手的。制作它我有很多乐趣，我们查看了应用这些概念的各种方式。学生们花时间熟悉一些框架，去混淆二进制文件，检测检查时间-使用时间的漏洞，以及其他有趣的事情。</p>
<p>你可以在下面提供你的信息，我们将在下次提供公开课程时通过电子邮件通知你。（没有垃圾邮件或其他任何东西，我保证。）</p>
<p>如果你有一个团队对接受这种培训感兴趣，也可以与我们联系，我们也可以私下提供这种培训！我希望有一天能在课堂上见到你！</p>
<p>谢谢！</p>
<p>我们尊重你的隐私，不会将你的联系信息用于除Atredis培训新闻之外的任何其他用途。</p>
<p>谢谢！</p>
]]></content>
      <categories>
        <category>符号执行</category>
        <category>翻译文章</category>
      </categories>
      <tags>
        <tag>符号执行</tag>
      </tags>
  </entry>
  <entry>
    <title>next 主题基本设置</title>
    <url>/2023/09/03/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/next%E4%B8%BB%E9%A2%98%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>为博客更换 next 主题，并做基础设置，使其能用。</p>
<span id="more"></span>

<ol>
<li><h2 id="更换next主题"><a href="#更换next主题" class="headerlink" title="更换next主题"></a>更换next主题</h2><ol>
<li><p>从<a href="https://github.com/hexojs/hexo/wiki/Themes#n">hexo主题库</a>中找一款中意的下载到 blog-dir&#x2F;themes 文件夹中</p>
</li>
<li><p>设置 hexo 配置文件 <code>_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Extensions</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next  # 这里的主题名字要和themes文件夹中下载的主题文件夹名字一致</span><br></pre></td></tr></table></figure>

<p>将这里改为你下载的主题，顺便选 next 的原因是维护比较好，界面简约</p>
</li>
<li><p>然后 <code>hexo g</code> <code>hexo d</code> 就完成主题更换。</p>
</li>
</ol>
</li>
<li><h2 id="next-主题优化"><a href="#next-主题优化" class="headerlink" title="next 主题优化"></a>next 主题优化</h2><p>现在有两个关键配置文件，</p>
<ul>
<li>一个是 <code>site-dir\themes\next</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>另一个是<code>site-dir</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>两个文件同名，但是前者是关于 next 主题的配置，后者是关于 hexo 博客的配置。</li>
</ul>
<ol>
<li><h3 id="站点基本配置信息"><a href="#站点基本配置信息" class="headerlink" title="站点基本配置信息"></a>站点基本配置信息</h3><p>更改 hexo 配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Site</span></span><br><span class="line">title: Focus2flow</span><br><span class="line">subtitle: &#x27;less is more&#x27;</span><br><span class="line">description: &#x27;技术，人生，思考，自我&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: sky</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="更改-next-的-scheme"><a href="#更改-next-的-scheme" class="headerlink" title="更改 next 的 scheme"></a>更改 next 的 scheme</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Schemes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Muse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Mist</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>添加标签，分类关于三个页面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在 next 配置文件中打开这三个开关</span></span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 hexo 命令在 <span class="built_in">source</span> 目录下创建三个文件夹</span></span><br><span class="line">hexo n page about</span><br><span class="line">hexo n page tags</span><br><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure>

<p>此时在四个文件夹中自动生成了对应页面的 md 文档，hexo s 运行博客也可以在首页访问到对应页面，问题是这四个功能页面跟普通的post中的内容页面是有区别的，具体来讲：</p>
<ul>
<li>about 页暂不清楚</li>
<li>tags 页要根据 post 中博文在文件头部设置的标签对文章进行分类</li>
<li>categories 页要根据类别进行分类，类似于文件夹</li>
<li>archives 页对本博客所有文章按时间轴列出</li>
</ul>
<p>因此需要对这这些功能文件在文件头部用 type 字段进行说明，next 识别到类型说明才能启动对应的算法从 post 里的博文里统计并呈现对应信息。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903215225417.png" alt="image-20230903215225417"></p>
<p>那么写博文时候怎样设置 tags catagories 呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置标签</span></span><br><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置分类</span></span><br><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种设置方法</span></span><br><span class="line">tags: [&quot;tag1&quot;,&quot;tag2&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h3><p>在你认为合适的地方添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><ol>
<li><p>安装 <a href="https://links.jianshu.com/go?to=https://github.com/flashlab/hexo-generator-search">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开站点配置文件找到 <code>Extensions</code> 在下面添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3、打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
</li>
</ol>
</li>
</ol>
<p>至此就是一个打开可以用起来的博客了，那么梳理一下写新文章的合理步骤：</p>
<ol>
<li><code>hexo n name </code> 在 post 中生成一个带文件头的 md 文档</li>
<li>typora 接管文档，写博客</li>
<li>写完之后 hexo 生成，部署</li>
</ol>
<p><strong>参考文章：</strong></p>
<p><a href="https://hexo.io/">hexo 官方文档</a></p>
<p><a href="https://theme-next.js.org/">next 官方文档</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&mid=2247488750&idx=1&sn=bddb76b8e85d04b303b3d10024b8a56b&chksm=eb47150adc309c1cfe5f847acaf6a3eb7de3efb3c7f2a87e708a686a740aa364c33c80ea3000&token=1693393167&lang=zh_CN#rd">博客的意义</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">基础优化</a></p>
<p><strong>未来优化方向：</strong></p>
<p><a href="https://www.lovebykin.com/4288776826/">鉴于分类页太丑</a></p>
<p><a href="https://blog.juanertu.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一个系列博客有机会再优化</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+typora图片路径设置</title>
    <url>/2023/09/15/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>解决了本地网站不能同时正确显示图片的问题！</p>
<span id="more"></span>

<h4 id="目前的问题："><a href="#目前的问题：" class="headerlink" title="目前的问题："></a>目前的问题：</h4><ol>
<li>用 hexo n 命令新增博文全部在 _post 文件夹下，博文多了之后很乱，需要按主题分文件夹。</li>
<li>之前的云对象存储到期以后想把图片直接放在 github 里面</li>
</ol>
<p>第一个问题在研究了 hexo 的官方文档之后，可以在新建文章时候用 -p 命令指定文件夹，且 -p 默认相对位置就是 _post 文件夹。</p>
<p>第二个问题：</p>
<ul>
<li>首先在网站配置 <code>_config.yml</code> 中，设置<code>post_asset_folder: true</code>，则会在 <code>hexo n</code> 的时候同时在同路径下生成同名文件夹。然后写博客的时候按照<a href="https://hexo.io/zh-cn/docs/asset-folders#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6">官方文档</a>中的描述处理图片引用，问题是写成这种格式确实可以保证在发布到网站上之后图片正确显示，但是<code>&#123;% asset_img "spaced asset.jpg" "spaced title" %&#125;</code> 这样的格式写的过程中会很难受，不能在本地预览。</li>
<li>官方提供的的<a href="https://hexo.io/zh-cn/docs/asset-folders#%E4%BD%BF%E7%94%A8-Markdown-%E5%B5%8C%E5%85%A5%E5%9B%BE%E7%89%87">第二个方法</a>，是把图片引用写成<code>![](image.jpg)</code>的形式，然后使用插件 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 在部署之前翻译成<code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code> ,然而这样的方式仍然是不能在 typora 中预览，除非愿意忍受所有文章的图片摊平放在和文章同级别文件夹里。</li>
<li>所以现在的目标就是在每个文章拥有自己文件夹的前提下，实现既能在 typora 中预览，也可以上传之后正确显示图片。这样的需求社区中早有人在做。<ul>
<li>首先是这里提出一种解决方案：<a href="https://www.cnblogs.com/guide2it/p/11111715.html">https://www.cnblogs.com/guide2it/p/11111715.html</a></li>
<li>然后是有人实现了这个插件：<a href="https://moeci.com/posts/hexo-typora/#%E9%85%8D%E7%BD%AE-typora-%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%BD%86%E6%98%AF%E7%94%B1%E4%BA%8E%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6%E5%B7%B2%E7%BB%8F%E4%B8%8D%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%AE%8C%E6%88%90%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E3%80%82">https://moeci.com/posts/hexo-typora/#%E9%85%8D%E7%BD%AE-typora-%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84，但是由于版本更迭，这个插件已经不能正确完成地址翻译。</a></li>
<li>直到最终看到这篇文章里的代码：<a href="https://blog.csdn.net/yzy_cb/article/details/137514297">https://blog.csdn.net/yzy_cb/article/details/137514297</a></li>
</ul>
</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>本质问题其实是 hexo 并没有完全支持 markdown 翻译，社区中的插件如 hexo-renderer-marked ，hexo-renderer-img 都在做图片的定向翻译，但是由于 hexo 版本原因, 这些插件都已失效，具体怎么翻译要看手上的 hexo 到底怎么安排文章图片资源的位置的。上面的代码就是正确翻译了图片的位置。</li>
</ul>
<p>附带：</p>
<ul>
<li>hexo 文件头：<a href="https://blog.csdn.net/weixin_72330417/article/details/139543033">https://blog.csdn.net/weixin_72330417/article/details/139543033</a></li>
</ul>
]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows  环境下利用 Github page 搭建博客环境</title>
    <url>/2023/09/03/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Github + hexo 搭建个人博客</p>
<span id="more"></span>

<ol>
<li><h2 id="本地环境准备"><a href="#本地环境准备" class="headerlink" title="本地环境准备"></a>本地环境准备</h2><ol>
<li><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><blockquote>
<p>目的是为了利用 git 和 Github 仓库进行交互</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/download/win">下载官方 git</a>，选择合适版本，</li>
<li>将 git 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>git version</code>,检查是否安装并设置成功。</li>
</ul>
</li>
<li><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><blockquote>
<p>目的是使用其包管理软件 npm 安装 hexo ，也可能与 hexo s 命令有关</p>
</blockquote>
<ul>
<li><a href="https://nodejs.org/en/download">下载官方 nodejs</a>，选择合适版本</li>
<li>将 node 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>node -v</code>,检查是否安装并设置成功</li>
</ul>
</li>
<li><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><blockquote>
<p>hexo 是一款优秀的博客管理软件？这样定位不知道是否合适</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install hexo -g</code> 安装</li>
<li>在 git-bash 中使用命令 <code>hexo -v</code> 验证安装</li>
</ul>
</li>
<li><h3 id="安装-hexo-developer-git"><a href="#安装-hexo-developer-git" class="headerlink" title="安装 hexo-developer-git"></a>安装 hexo-developer-git</h3><blockquote>
<p>这个是 <code>hexo d</code> 命令中将本地编译好的博客部署到 github 仓库时，hexo 和 git 交互的软件</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install --save hexo-deployer-git</code> 安装</li>
</ul>
</li>
</ol>
</li>
<li><h2 id="Github-仓库设置"><a href="#Github-仓库设置" class="headerlink" title="Github 仓库设置"></a>Github 仓库设置</h2><ol>
<li><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><blockquote>
<p>默认情况下 github 允许每一个用户建立一个博客仓库</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903131724407.png" alt="image-20230903131724407"></p>
<p>这里似乎并不能看出这个仓库是专用于搭建博客用的，有待将来研究 Github Pages 的说明。</p>
</li>
</ol>
</li>
<li><h2 id="Git-与-Github-交互设置"><a href="#Git-与-Github-交互设置" class="headerlink" title="Git 与 Github 交互设置"></a>Git 与 Github 交互设置</h2><ol>
<li><h3 id="Git-客户端生成-ssh-公钥"><a href="#Git-客户端生成-ssh-公钥" class="headerlink" title="Git 客户端生成 ssh 公钥"></a>Git 客户端生成 ssh 公钥</h3><ol>
<li><p>在 git-bash 中使用 <code>ssh-keygen -t rsa -C &quot;example@email.com&quot;</code>生成密钥对</p>
</li>
<li><p><code>cd ~/.ssh</code> 进入到 ssh 本地秘钥文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README.md  config  id_rsa  id_rsa.pub  known_hosts  known_hosts.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其中的公钥 <code>id_rsa.pub</code> 的内容复制出来</p>
</li>
</ol>
</li>
<li><h3 id="Github-添加-Git-产生的公钥"><a href="#Github-添加-Git-产生的公钥" class="headerlink" title="Github 添加 Git 产生的公钥"></a>Github 添加 Git 产生的公钥</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903134218399.png" alt="image-20230903134218399"></p>
</li>
<li><h3 id="使用-ssh-T-git-github-com-命令测试是否成功"><a href="#使用-ssh-T-git-github-com-命令测试是否成功" class="headerlink" title="使用 ssh -T git@github.com 命令测试是否成功"></a>使用 <code>ssh -T git@github.com</code> 命令测试是否成功</h3></li>
<li><h3 id="设置-Git-用户名和邮箱"><a href="#设置-Git-用户名和邮箱" class="headerlink" title="设置 Git 用户名和邮箱"></a>设置 Git 用户名和邮箱</h3><ul>
<li>设置用户名：<code>git config --global user.name &quot;ColorMao&quot;</code></li>
<li>设置邮箱：<code>git config --global user.email &quot;zhangyumao@petalmail.com&quot;</code></li>
</ul>
</li>
</ol>
</li>
<li><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><ol>
<li><p>在本机合适的位置建立一个存放本地博客文件的文件夹，如我的：<code>E:\Blogs\Focus2flow</code>，git-bash 进入该空文件夹</p>
</li>
<li><p>使用 hexo 本地部署博客</p>
<ol>
<li><code>hexo init</code> 初始化博客文件</li>
<li><code>hexo generate</code> 编译生成可部署的 html 文件</li>
<li><code>hexo server</code> 本地部博客用于预览</li>
</ol>
</li>
<li><p>博客部署到仓库</p>
<ol>
<li><p>在博客文件夹根目录找到 hexo 配置文件 <code>_config.yml</code></p>
</li>
<li><p>更改其中的配置选项为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:captain0X01/captain0X01.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo deploy</code> 部署到 GIthub仓库</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142806727.png" alt="image-20230903142806727"></p>
<p>可以观察到文件确实推上去了，那么远程访问一下博客。</p>
</li>
<li><p>访问博客<a href="https://yimaginer.github.io/">https://yimaginer.github.io/</a></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142952837.png" alt="image-20230903142952837"></p>
<p>访问成功，至此我们在 Github 上搭建了一个幼儿园级的个人博客</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="新增博文"><a href="#新增博文" class="headerlink" title="新增博文"></a>新增博文</h2><ol>
<li><p>将写好的 markdown 文档放进 site-dir&#x2F;source&#x2F;_posts 文件夹中</p>
</li>
<li><p><code>hexo generate</code> 重新生成</p>
</li>
<li><p><code>hexo deploy</code> 部署，如图</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903144752739.png" alt="image-20230903144752739"></p>
</li>
<li><p>这样一个幼儿园博客，就实际使用来看还有下面的差距，如图编号</p>
<ol>
<li>博文是全篇展开放在主页，不科学</li>
<li>这个引用文字的格式转换成了这样，是这个默认主题的原因</li>
<li>新上传的文章没有标题，不行</li>
<li>博客的名称还是默认的，要改</li>
<li>顺便这配色不怎么好看</li>
</ol>
</li>
<li><p>接下里通过换一个主题，并进行设置，打造一个可以实际使用的博客。</p>
</li>
</ol>
</li>
</ol>
<p><strong>参考博客</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/550709268">利用Github DIY自己的个人博客</a></li>
<li><a href="https://www.cnblogs.com/Alight/p/4354294.html">这是一个有用的思考</a></li>
<li><a href="https://docs.github.com/zh/pages/quickstart">Github pages 官方文档</a></li>
</ul>
<p><strong>补充内容：hexo 命令的具象化解释</strong></p>
<p>执行完<code>hexo init</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902175759500.png" alt="image-20230902175759500"></p>
<p><code>hexo generate</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902180712442.png" alt="image-20230902180712442"></p>
<p><code>hexo clean</code>是把生成的东西清掉了</p>
<p><code>hexo d</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902181617668.png" alt="image-20230902181617668"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划一题一析</title>
    <url>/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>动态规划总结</p>
<span id="more"></span>
<p><a href="https://leetcode.cn/contest/biweekly-contest-140/problems/find-the-lexicographically-smallest-valid-sequence/">Q3. 字典序最小的合法序列</a></p>
<p>题目描述：给出两个字符串 str1 str2, 后者的总长度小于等于前者；定义两个字符串若只有一个字符不一样，称二者几乎一样。在 str1 中找到一个子序列和 str2 几乎一样，同时使得这个序列下标数组的字典序尽可能小。</p>
<p>解题思路：</p>
<ul>
<li>双侧贪心，从左往右扫描，用 f[i] 表示匹配 str2 的前 i 个字符至少要用掉 str1 的 前缀字符数。</li>
<li>用 g[j] 表示匹配 str2 的 j 开始的后缀需要的 str1 最短后缀的起始位置。</li>
<li>如此，只要 str2 的任意字符满足了 f[i - 1] + 1 &lt; g[i + 1]， 那么说明至少可以匹配上，我们再从中挑选最小字典序替换方式就可以。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">validSequence</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word<span class="number">1.</span><span class="built_in">size</span>(), m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        word1 = <span class="string">&#x27; &#x27;</span> + word1; word2 = <span class="string">&#x27; &#x27;</span> + word2;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">2</span>)</span>, <span class="title">g</span><span class="params">(m + <span class="number">2</span>)</span></span>; <span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line">		<span class="comment">// 双端贪心</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= n &amp;&amp; word1[j] != word2[i]) j ++;</span><br><span class="line">            f[i] = (j &gt; n ? INF : j);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        g[m + <span class="number">1</span>] = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m, j = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">1</span> &amp;&amp; word1[j] != word2[i]) j --;</span><br><span class="line">            g[i] = (j &lt; <span class="number">1</span> ? -INF : j);</span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt;= m; s ++)</span><br><span class="line">            <span class="keyword">if</span>(f[s - <span class="number">1</span>] + <span class="number">1</span> &lt; g[s + <span class="number">1</span>] &amp;&amp; (f[s - <span class="number">1</span>] + <span class="number">1</span> &lt; f[s] || s == m)) <span class="comment">// 这个条件找第一个替换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">                <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt;= n &amp;&amp; word1[j] != word2[i]) j++;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j - <span class="number">1</span>);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(j - <span class="number">1</span>); j++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = s + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt;= n &amp;&amp; word1[j] != word2[i]) j++;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(j - <span class="number">1</span>);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">validSequence</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        n = word<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_left</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> current_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(current_len == m)</span><br><span class="line">            &#123;</span><br><span class="line">                dp_left[i] = current_len;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[current_len])</span><br><span class="line">                current_len++;</span><br><span class="line">            dp_left[i] = current_len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        current_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(current_len == m)</span><br><span class="line">            &#123;</span><br><span class="line">                dp_right[i] = current_len;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[m<span class="number">-1</span>-current_len])</span><br><span class="line">                current_len++;</span><br><span class="line">            dp_right[i] = current_len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> free_change_i = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 确认可以匹配出子串，并得到首次可以匹配的位置为 free_change_i</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left_len = i == <span class="number">0</span> ? <span class="number">0</span> : dp_left[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> right_len = i == n - <span class="number">1</span> ? <span class="number">0</span> : dp_right[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(left_len + right_len + <span class="number">1</span> &gt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                free_change_i = i; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        current_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i] == word2[current_len])</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                current_len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一次发现失配位置就赶紧替换，以保证字典序最小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(free_change_i &gt;= <span class="number">0</span> &amp;&amp; i &gt;= free_change_i) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                current_len++;</span><br><span class="line">                free_change_i = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(current_len == word<span class="number">2.</span><span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>双端贪心</li>
<li>返回空 vector 的方式：<code>return vector&lt;int&gt;();</code> 和 <code>return &#123;&#125;;</code></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心一题一析</title>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>leetcode 贪心一题一析</p>
<span id="more"></span>

<p><a href="https://leetcode.cn/problems/maximize-the-total-height-of-unique-towers/">3301. 高度互不相同的最大塔高和</a></p>
<p>题目描述：一个数组代表了塔高，每个塔高可以把自己的高度设定为 1- 塔高 中的任意值，如果不存在这样的设定，返回 -1，否则返回可能的塔高之和。</p>
<p>思路：贪心，从最高塔高往下递减</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumTotalSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; maximumHeight)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(maximumHeight.<span class="built_in">begin</span>(),maximumHeight.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> cur = maximumHeight[<span class="number">0</span>]; <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e : maximumHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = <span class="built_in">min</span>(cur,e);</span><br><span class="line">        <span class="keyword">if</span>(cur &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans += cur; cur --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC奖学金体系</title>
    <url>/2023/09/04/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/UESTC%E5%A5%96%E5%AD%A6%E9%87%91%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>学习一下成电的奖学金体系</p>
<span id="more"></span>

<ul>
<li><h1 id="奖学金体系"><a href="#奖学金体系" class="headerlink" title="奖学金体系"></a>奖学金体系</h1><ul>
<li>学业<ul>
<li>金额：10000&#x2F;8000&#x2F;4000</li>
<li>评定时间：9月中上旬</li>
<li>申请制：需要提交佐证材料</li>
</ul>
</li>
<li>国家<ul>
<li>金额：硕2万，博3万</li>
<li>评定时间：9月中下旬，学业奖学金之后</li>
<li>申请制：大约也是按照学业奖学金的那套细则</li>
</ul>
</li>
<li>专项<ul>
<li>小米<ul>
<li>金额：2万，10个名额</li>
<li>时间：1月上旬</li>
<li>可与国奖兼得</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ul>
<li>国奖与专项不可兼得，专项有特殊说明的除外</li>
</ul>
</li>
<li><h1 id="评定办法"><a href="#评定办法" class="headerlink" title="评定办法"></a>评定办法</h1><ul>
<li>研二：综合素质得分&#x3D;学业成绩得分+科研成果得分+素质发展得分+导师评价得分</li>
<li>研三：综合素质得分&#x3D;科研成果得分+素质发展得分+导师评价得分</li>
</ul>
</li>
<li><h1 id="综合素质得分细则"><a href="#综合素质得分细则" class="headerlink" title="综合素质得分细则"></a>综合素质得分细则</h1><ul>
<li><h2 id="科研成果"><a href="#科研成果" class="headerlink" title="科研成果"></a>科研成果</h2><ul>
<li><h3 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904093901825.png" alt="image-20230904093901825"></p>
</li>
<li><h3 id="专利软著"><a href="#专利软著" class="headerlink" title="专利软著"></a>专利软著</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094106297.png" alt="image-20230904094106297"></p>
</li>
<li><h3 id="教材或专著"><a href="#教材或专著" class="headerlink" title="教材或专著"></a>教材或专著</h3><p>学生参与编写教材或专著的（须在作者列表中），提交相关材料，由评审委员会认定加分，上限 8 分。</p>
</li>
<li><h3 id="科技获奖"><a href="#科技获奖" class="headerlink" title="科技获奖"></a>科技获奖</h3><ul>
<li>获得国家科技奖励，省部级科技一等奖，可直接定为学业奖学金一等奖</li>
<li>省部级科技二等奖、三等奖在原有奖学金基础上提升一等级</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="素质发展"><a href="#素质发展" class="headerlink" title="素质发展"></a>素质发展</h2><ul>
<li><h3 id="科技竞赛"><a href="#科技竞赛" class="headerlink" title="科技竞赛"></a>科技竞赛</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094921145.png" alt="image-20230904094921145"></p>
<ul>
<li>A类竞赛包括<ul>
<li>中国“互联网+”大学生创新创业大赛</li>
<li>“挑战杯”全国大学生课外学术科技作品竞赛</li>
<li>“挑战杯”中国大学生创业计划大赛</li>
<li><a href="https://cpipc.acge.org.cn/">中国研究生创新实践系列大赛</a><ul>
<li>中国研究生智慧城市技术与创意设计赛</li>
<li>中国研究生未来飞行器创新赛</li>
<li>中国研究生数学建模竞赛</li>
<li>中国研究生电子设计竞赛</li>
<li>中国研究生创“芯”大赛</li>
<li>中国研究生人工智能创新大赛</li>
<li>中国研究生机器人创新设计大赛</li>
<li>中国能源装备创新设计大赛</li>
<li>中国研究生公共管理案例大赛</li>
<li>中国研究生乡村振兴科技强农+创新大赛</li>
<li>中国研究生网络安全创新大赛</li>
<li>中国研究生“双碳”创新与创意大赛</li>
<li>中国研究生金融科技创新大赛</li>
</ul>
</li>
</ul>
</li>
<li>B类竞赛<ul>
<li>纳入研究生院研究生科技创新支持计划的其他竞赛<ul>
<li>全国大学生FPGA 创新设计竞赛</li>
<li>中兴捧月大赛</li>
<li>IEEEXtreme 极限编程大赛</li>
<li>全国大学生集成电路创新创业大赛</li>
<li>全国大学生嵌入式芯片与系统设计大赛</li>
<li>全国大学生集成电路EDA设计精英挑战赛</li>
<li>BOE 创新挑战赛</li>
<li>华为软件精英挑战赛</li>
<li>中国研究生电子设计竞赛商业计划书专项赛</li>
</ul>
</li>
<li>由我国政府教育行政主管部门、专业教学指导委员会，专业学术组织，主办的学术科技类比赛</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="学生骨干"><a href="#学生骨干" class="headerlink" title="学生骨干"></a>学生骨干</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904095600951.png" alt="image-20230904095600951"></p>
<ul>
<li>研究生会、研究生党建委员会若本年度获得学校表彰，成员可根据所在组织考评结果增加 1 分</li>
<li>党支部若获得本年度校级以上“先进党支部”称号，根据党支部评议结果，排名前 50%的党支部成员（以党支部正式党员、预备党员人数为基数）增加 1 分，院级减半</li>
</ul>
</li>
<li><h3 id="公益事业"><a href="#公益事业" class="headerlink" title="公益事业"></a>公益事业</h3><ul>
<li>参与志愿者等有突出表现，加 1 分，获得奖励的追加0.5分。可累加，上限为2 分</li>
</ul>
</li>
<li><h3 id="社会实践"><a href="#社会实践" class="headerlink" title="社会实践"></a>社会实践</h3><ul>
<li>参加扶贫、支教、国际组织实习、基层挂职锻炼项目等加 2 分，获得奖励的追加 1 分。可累加，上限 6 分。</li>
</ul>
</li>
<li><h3 id="综合素质比赛"><a href="#综合素质比赛" class="headerlink" title="综合素质比赛"></a>综合素质比赛</h3><ul>
<li>参加由我国政府教育行政主管部门、专业教学指导委员会、专业学术组织和学校学院主办的综合素质类比赛并获奖的，国家级加3分，省市级加 2 分，校级院级加 1 分，上限为 3 分。</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="导师评价"><a href="#导师评价" class="headerlink" title="导师评价"></a>导师评价</h2><ul>
<li><p>评分采取“<strong>科研团队（或导师）总分</strong>+<strong>内部分级</strong>”的方式</p>
</li>
<li><p>每个科研团队（或导师）拥有一个总评分，即该团队（或导师）门下具有参评奖学金资格的<strong>学生人数</strong>×<strong>学生人均分 15 分</strong>＝总评分</p>
</li>
<li><p>评分区间为5—20分，最后学生个人得分的加总不能超过团队（或导师）拥有的总评分。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904100133437.png" alt="image-20230904100133437"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>综合分析：</strong></p>
<p>其实比赛啊，支部啊，意义不大。做真科研，才是真正有长远发展的事情。</p>
]]></content>
      <tags>
        <tag>研究生</tag>
      </tags>
  </entry>
  <entry>
    <title>房地产研究</title>
    <url>/2023/09/07/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E6%88%BF%E5%9C%B0%E4%BA%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>房地产行业研究</p>
<span id="more"></span>

<ol>
<li><h1 id="财政危机与飞税制改革"><a href="#财政危机与飞税制改革" class="headerlink" title="财政危机与飞税制改革"></a>财政危机与飞税制改革</h1><ul>
<li>财政包干使得中央财政吃紧，中央财政对国防，教育，医疗投入面临经费匮乏</li>
<li>分税制把税分成三类<ul>
<li>中央税</li>
<li>地方税</li>
<li>共享税</li>
</ul>
</li>
<li>广东谈判<ul>
<li>分税制可以，但要将土地出让收入归地方</li>
</ul>
</li>
<li>分税制使得中央财政中央财政年均增幅超过了10%，1993年958亿，1994年2906亿，2021年9.15万亿。对经济有了足够的调控能力，开始加速对中国经济体制的改革。</li>
</ul>
</li>
<li><h1 id="“98房改”与三驾马车"><a href="#“98房改”与三驾马车" class="headerlink" title="“98房改”与三驾马车"></a>“98房改”与三驾马车</h1><ul>
<li><p>1997东南亚经济危机蔓延，中央消费，投资，出口三驾马车。</p>
</li>
<li><p>怎么构建，谁来拉动没有办法，1997年，京九铁路剪彩，王石做《分税制对企业的影响》，讨论了房地产行业能不能作为经济支柱。</p>
</li>
<li><p>房地产模式</p>
<ul>
<li>士地财政</li>
<li>商品房预售</li>
<li>信贷体系</li>
<li>钱从购房者手中到开发商，再到地方政府。本质是将居民未来几十年的收入提前预支获得天量资金，转换成财政收入，进行基建，招商引资。将地方政府发展过程中的部分债务转移到居民层面。</li>
</ul>
</li>
<li><p>1994年8月30日到9月2日土地使用制度改革工作会议</p>
<ul>
<li>制约我国发展经济和进行现代化建设的最大制约因素是资金不足</li>
<li>土地是我国经济建设和发展的巨大财富成为共识</li>
</ul>
</li>
<li><p>分税制下地方政府对于财政收入的巨大渴望，政府把主地一级市场的所有权逐渐收回。</p>
<ul>
<li>一开始的方式是无偿划拨和土地出让，但一直无法让土地价值最大化</li>
<li>国土资源部规定经营性土地，即用来建设商业、旅游、娱乐金融、服务业、商品房的土地必须执行“招拍挂”</li>
</ul>
</li>
<li><p>土地市场从无偿划拨到土地出让，与之对应的住房制度是福利分房到商品房，1998年国务院《关于进一步深化城镇住房制度政革，加快住房建设的通知》，即著名的<strong>98房改</strong>。<strong>取消福利分房，实现居民住宅货币化、私有化</strong>，住宅商品化拉开序幕。</p>
</li>
<li><p>购房补贴</p>
<ul>
<li>房价收入比&#x3D;本地一套60平经济适用房的平均价格&#x2F;双职工家庭的年平均工资</li>
<li>中央建设部副部长俞正声拍板，房价收入比大于4倍的要建立购房补贴</li>
<li>要想步履蹒跚的中国房地产引领中国经济走出亚洲经济危机，<strong>还缺两个发动机</strong></li>
</ul>
</li>
<li><p>1999年6月16日，原国家计划发展委员会和教育部联合发出紧急通知决定1999年中国高等教育在年初扩招23万人的基础上再扩大招生33.7万，普通高等院校招生总人数达到153万</p>
<ul>
<li>大学扩招成为拉动经济的基操</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212341823.png" alt="image-20230906212341823" style="zoom:67%;"></li>
<li>人回红利和士地红利开始集中释放，中国经济的三驾马车包经完成其二</li>
</ul>
</li>
<li><p>2001年，中国加入WTO,三家马车最后一架来了，人口红利进一步得到释放</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212720067.png" alt="image-20230906212720067" style="zoom:67%;">

<p>评：房地产在那个特定时期发挥了它的经济拉动作用，推动我国的经济实力迅速上升，在房地产刚起步的年代，还是出现了许多在景观、产品细节、建筑风格、设计艺术上追求极致的好楼盘。没有高周转，没有夸张营销。</p>
<blockquote>
<p>美联储降息意味着什么？</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906213751190.png" alt="image-20230906213751190"></p>
</li>
</ul>
</li>
<li><h1 id="“国十条”与第一次狂奔"><a href="#“国十条”与第一次狂奔" class="headerlink" title="“国十条”与第一次狂奔"></a>“国十条”与第一次狂奔</h1><ul>
<li><p>2004-2008年，房价良性增长，政府稳房价出台一系列政策</p>
<ul>
<li><p>2003明确房地产为支柱产业</p>
</li>
<li><p>2004“831大限”，解决协议出让的历史遗留问题</p>
</li>
<li><p>2005年3月，取消房贷优惠，首套房首付比例从20%上调至30%</p>
</li>
<li><p>2005年3月，老“国八条”，稳房价提高到政治高度</p>
</li>
<li><p>2005.10，二手房需缴纳个人所得税</p>
</li>
<li><p>2006年5月，国六条，7月，《关于规范房地产市场外资准入和管理的意见》</p>
</li>
<li><p>2007年，加大炒房客“资金成本”，5次加息。二套房首付比例不低于50%</p>
</li>
<li><p>2007年，王石在万科会议“海螺行动二”中说，中国楼市的拐点即将到来，随后万科率先降价</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906215643008.png" alt="image-20230906215643008"></p>
<p>跟风的房企并不多，但紧接着金融危机到来，消费低靡。房价下调蔓延开来，但是人性都是“买涨不买跌”，越降价越没人买。中国经济有“硬着陆的风险”</p>
</li>
</ul>
</li>
<li><p>2008年11月5日，发布进一步扩大内需，促进经济平稳较快发展的<strong>“国十条</strong>”，具体的方法是：</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906220739549.png" alt="image-20230906220739549"></p>
<p>央行5次降息，连续降息2.16%，大水漫灌。</p>
</li>
<li><p>国十条需要的资金从哪里来？是地方政府通过城投公司用<strong>土地</strong>向银行借贷得来的。所以房价不能降，于是各地开始疯狂救市。</p>
</li>
<li><p>2008救市</p>
<ul>
<li><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223413007.png" alt="image-20230906223413007"></p>
</li>
<li><p>同时地方政府可以灵活指定特殊政策</p>
<ul>
<li>杭州“救市”24条，规定购买100万以士房产的客户可直接落户</li>
</ul>
</li>
<li><p>于是全国住宅均价平均上涨25.1%，全国一二线城市房价都在那两年翻了一番</p>
<ul>
<li><p>2008年郑州全年均价3960，到2010年12月已经张到了6493</p>
</li>
<li><p>陆家嘴</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223922564.png" alt="image-20230906223922564"></p>
</li>
</ul>
</li>
<li><p>大量人员开始<strong>恐慌性置业</strong>。</p>
</li>
</ul>
</li>
<li><p>土地金融</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906224301852.png" alt="image-20230906224301852"></p>
<ul>
<li>这里面关键是土地价格不能降</li>
</ul>
</li>
<li><p>刹车</p>
<ul>
<li><p>楼市火热，GDP重回两位数，2010年1月10日中快发布了国十一条”，限购</p>
</li>
<li><p>2010年4月12日：新国十条发布，调控加码</p>
<ul>
<li>首套房且90以上，贷款首付款比例不得低于30%</li>
<li>二套房，首付比例不得低于50%，贷款利率率不得低于基准利率的1.1倍，按当时，二套房利率达到了6.53%</li>
<li>非本地居民暂停贷款，就是只能全款</li>
</ul>
</li>
<li><p>2010年10月开始，四次加息，首套房利率来到7.05%</p>
<blockquote>
<p>何为资产负债率，广义货币M2是什么？</p>
<p>美元加息为什么会让资本回流美国？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>反思：国十条有效拉动了经济复苏，可惜政策没有成熟的监管体系。钱都流向了房市，推高了房价。</p>
</li>
<li><h1 id="第二次狂奔"><a href="#第二次狂奔" class="headerlink" title="第二次狂奔"></a>第二次狂奔</h1><ul>
<li><p>2014加息导致美元资金回流，同时房地产行业供远大于求，导致了房地产低迷</p>
<ul>
<li>呼和浩特等取消<strong>限购</strong>，释放需求，</li>
<li>2014年9月30，央行，银监会下发《关于进一步做好住房金融服务工作的通知》，提出<strong>房贷结清后再购房可算首套</strong>，<strong>限贷</strong>缓和</li>
<li>同时下调贷款利率</li>
<li>相当于从政策端和货币端给房地产松绑。</li>
<li>然而这次的政策松绑并没有起到预期效果<ul>
<li>房价的持续低迷打破了永远涨的预期，不敢投资房产</li>
<li>库存大多是三四线城市，一二线城市扥松绑并不能对整体库存的消化起到明显作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>既然松绑失败，那就只能直接促进需求端的上涨，<strong>棚改货币化</strong></p>
<ul>
<li><p>棚改分为实物安置和货币安置</p>
</li>
<li><p>2014年6月26日，国家开发银行成立住宅金融事业部，针对棚改工作向地方政府发放贷款。</p>
</li>
<li><p>棚改的运作逻辑</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906233801487.png" alt="image-20230906233801487" style="zoom:50%;">
</li>
<li><p>棚改各阶段分析</p>
<ul>
<li>第一阶段：2007-2012， 大多数居民选择实物安置，因此并没对楼市产生很大影响</li>
<li>第二阶段：2013-2014，住建部选择优先就近实物安置</li>
<li>第三阶段：2015-2018，国务院37号文件，强调提高货币化安置比例，因为要“三去”，货币化安置比例从2014年的9%上升到2016年的48.5%</li>
</ul>
</li>
<li><p>二线拆迁户率先冲入楼市，2016年：合肥、厦门、南京、苏州翻倍涨幅，史称“房价四小龙”</p>
</li>
<li><p>二线楼市上涨促进了三四五线城市拿到接力棒，对楼市发起冲锋。</p>
<ul>
<li>让一直深耕三四线的恒大，碧桂园在2016年完成业绩超车</li>
<li>引起房企下沉</li>
</ul>
</li>
</ul>
</li>
<li><p>2017年<strong>930调控潮</strong>，全国一二线共19个城市发布调控，开始“<strong>五限</strong>”</p>
<ul>
<li>限购</li>
<li>限贷</li>
<li>限售：购房之日起，三年&#x2F;五年&#x2F;十年之内不许上市买卖。直接拉长炒房客资金回收周期</li>
<li>限价：在商品房房价，出地最高拍卖价格两方面设定上限，楼市，土市双限价</li>
<li>限签：房屋备案合同在网上登记备案，叫做“网签”，网签后，这套房的价格信息就会在全国联网的房地产系统中记录在案。国家就可以知道各城市的房价指数，于是各地方政府怕自己房价上涨的太快被中央知道，于是就让高价房源暂缓网签。因此2017年之后的房价指数都是不准确的</li>
<li>结婚离婚如何成为钻制度空子的方法<ul>
<li>以合肥为例<ul>
<li>限购政策为：本市户口住房者至多拥有两套住房，非本市户口购房要满一年社保才能买一套</li>
<li>问题在于本地户口的认定，婚姻持续状态的夫妻按一户只能有两套住房资格，但离了婚就算两户，有四套的购房资格。</li>
<li>合肥楼市新政：离婚不满两年仍按原家庭进行房查</li>
</ul>
</li>
<li>海南<ul>
<li>2017年4月出台：非本省户口只能购买一套，本省户口没限制</li>
<li>于是炒房客与三亚适龄单身女青年假结婚，并将户口迁海南，买够想要的房后离婚。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一二线调控使得一些区位好的三四线成了炒房客的聚集地。如“环沪四县”，昆山、嘉善、启东、太仓</p>
</li>
<li><p>问题所在：</p>
<ul>
<li>健康发展的房地产可以拉动上下游实体经济发展</li>
<li>房价暴涨造成人心理的异化：你有100万准备投资实体，但是你在的城市一年房价翻翻了，那你怎么还会投资实体经济。</li>
<li>原本带动实体经济发展的房地产反倒成了资金吸血鬼，抢走了原本应该投向实体的资金，扩大了房地产的金融化和泡沫化。</li>
<li><strong>最致命</strong>：房地产市场成了不会下跌的股市，不断推高房价，高的房价就是高的生活成本，让年轻人不得不追求高收入的金融互联网，多少人的梦想从小时候的想当科学家艺术价变成想买一套房。实体产业的发展、科技创新、文化创新都成为了楼市发展的代价。</li>
</ul>
</li>
<li><p>2018年全国各地开始收紧货币化安置，失去了货币化安置购买力的房企开始陷入困局</p>
<ul>
<li>2018年9月，万科郁亮开会强调“活下去”</li>
</ul>
</li>
</ul>
<p>总结：棚改是重要的民生工作，房地产去库存是为了防范金融风险。但这个过程中，房价的泡沫让社会思想开始异化：</p>
<ul>
<li>房企为追求利润和扩张开启高周转，高负债，房子质量也十分堪忧</li>
<li>群众被高房价倒逼为了钱累死累活，有房有车作为婚姻门槛越来越遥不可及</li>
</ul>
</li>
<li><h1 id="高周转的血与泪"><a href="#高周转的血与泪" class="headerlink" title="高周转的血与泪"></a>高周转的血与泪</h1><p>- </p>
<ul>
<li><p>现象</p>
<ul>
<li>2020年315晚会首次曝光万科水帘洞问题，房价越来越高，质量越来越差是人民的实感。</li>
<li>2021年起，高负债房企恒大，融创，碧桂园接连爆雷</li>
</ul>
</li>
<li><p>勾地</p>
<ul>
<li><p>早期无偿划拨和协议出让，2002建立土地“招拍挂”制度以后拿地成本很不确定</p>
</li>
<li><p>勾地就是类似于万达，龙湖模式，住宅+商业中心，通常会和政府暗通款曲，量身打造招标条件，同时地价也会比纯住宅低</p>
</li>
<li><p>保证金制度</p>
<ul>
<li>如果想拿地，必须先缴纳一定数额保证金才拥有了报名资格。</li>
<li>拍到了，保证金转成土地款；没拍到，原路退回。</li>
</ul>
</li>
</ul>
</li>
<li><p>工程经济学中的现金流模型</p>
<ul>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912142256305.png" alt="image-20230912142256305"></li>
<li>当土地成本、借款利率、税费建安费都无法下降的时候，将目光转向了时间——<strong>高周转</strong><ul>
<li>拿地后尽快开工，尽快开盘，尽快回款</li>
<li>两件事上放慢<ul>
<li>推迟土地款的支付时间</li>
<li>延期支付施工单位的工程款，延期到开盘之后甚至现金流回正之后，减少了前期融资的需求，降低了资金成本</li>
</ul>
</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912143558648.png" alt="0"></li>
</ul>
</li>
</ul>
</li>
<li><p>现实中高周转如何落地呢？</p>
<ul>
<li>首先是开盘时间的提速，开盘时间越早，曲线上扬越早，偿还贷款，节省资金成本。 </li>
<li>销售速度，销售速度越快，现金流上升的斜率就越陡，</li>
<li>建设速度，这是前两者的必要条件</li>
<li>释放预售监管资金进入公司自有账户</li>
<li>在项目外建立庞大的资金池，和自有资金一起进行投资</li>
</ul>
<blockquote>
<p>容积率：建筑总面积&#x2F;净用地面积</p>
<p>货地比：房产销售额&#x2F;总土地款</p>
<p>预售条件：从拿地到销售，需要满足预售条件，不同地区预售条件不一样</p>
<p>预售资金管理：</p>
</blockquote>
<ul>
<li>万科高周转<ul>
<li>2004年，36岁郁亮（北大经济系）接棒王石，提出“10年时间万科业务翻10倍，销售冲击千亿”</li>
<li>“5986”模式<ul>
<li>拿地后5个月开工，9个月开盘</li>
<li>普通住宅占开盘房源8成，开盘后当月销量达6成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高周转恶性循环</p>
<ul>
<li>规模越大的房企越容易获得额度更大，利息更低的贷款；小规模获得贷款利息更高，甚至申请不下来。</li>
<li>越大的规模意味着更便宜的融资，以为着更低的资金成本，也以为着更能发展更大规模和利润。</li>
<li>房地产沦为了资金游戏，顺便盖个房子</li>
</ul>
</li>
<li><p>美元债</p>
<ul>
<li><p>2016年19城调控前，房企通过上市、信托等渠道筹集资金</p>
</li>
<li><p>2016-2017调控潮之后，房企在国内的融资收紧，于是开始转向美元债</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912153414464.png" alt="image-20230912153414464"></p>
</li>
<li><p>美元债与信用评级挂钩，于是房企在美元债“躺平”就是房企爆雷的标志。</p>
</li>
</ul>
</li>
<li><p>净资产收益率ROE</p>
<ul>
<li><p>调控措施让房企的利润下降，使得ROE这个指标对于房企来说更重要，</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912163753937.png" alt="image-20230912163753937"></p>
</li>
<li><p>从重视净利率到重视ROE反映的是行业玩法的改变，就是将自己手上的每一分钱的赚钱能力发挥到极致。因为做个约分就发现：ROE &#x3D; 净利润&#x2F;总权益资本</p>
</li>
<li><p>导致的结果就是，<strong>加杠杆</strong>，于是奇怪现象：</p>
<ul>
<li><p>想做房企的施工单位，可以，请给一个亿的无息借款</p>
</li>
<li><p>并且我给你的工程支付会一直延后，让我的现金流尽快回正。</p>
<blockquote>
<p>我不成跪着要饭的了？要真这么说，给高周转房企当总包还真就是跪着要饭的，就这，多少人想跪还没这门子呢！</p>
</blockquote>
</li>
<li><p>向员工融资：跟投项目+理财产品</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高负债率</p>
<ul>
<li>在高周转模式下，只要现金流不断，这个模式就可以一直玩下去。</li>
<li>房企高负债逐渐成为中国经济的恶性肿瘤</li>
<li>2017年，十九大报告提出的“三大攻坚战”之首就是防范化解重大风险</li>
<li>2018年开始中央出台一系列政策加大房企融资限制，准备对房企釜底抽薪。</li>
<li>2019年底，2020年初新冠黑天鹅，使得不得不量化宽松扶持微小企业发展，这些钱却被用来炒房，引发<strong>第三次狂奔</strong></li>
</ul>
</li>
</ul>
</li>
<li><h1 id="第三次狂奔与三道红线"><a href="#第三次狂奔与三道红线" class="headerlink" title="第三次狂奔与三道红线"></a>第三次狂奔与三道红线</h1><ul>
<li><p>经营贷炒房</p>
</li>
<li><p>三道红线</p>
<ul>
<li><strong>剔除预收账款的资金负债率</strong>不得大于70%</li>
<li><strong>净负债率</strong>不得大于100%</li>
<li><strong>现金短债比</strong>不得小于1倍</li>
</ul>
</li>
<li><p>剔除预收账款的资产负债率</p>
<ul>
<li>预收款&#x3D;首付+房贷回款</li>
<li>交房前预收款被算作负债，交房后倍算作收入</li>
<li>剔除预收账款的资产负债率&#x3D;（总负债-预收款）&#x2F;（总资产-预收款）</li>
</ul>
</li>
<li><p>净负债</p>
<ul>
<li>净负债 &#x3D; （有息负债-货币资金）&#x2F; 合并权益</li>
</ul>
</li>
<li><p>现金短债</p>
<ul>
<li>现金短债比 &#x3D; 货币资金 &#x2F; 短期有息负债</li>
</ul>
</li>
<li><p><strong>三道红线</strong>和<strong>限跌令</strong>下的房企</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912203923915.png" alt="image-20230912203923915"></p>
</li>
</ul>
</li>
<li><h1 id="备用"><a href="#备用" class="headerlink" title="备用"></a>备用</h1><ul>
<li></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>房地产</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>雷军年度演讲</title>
    <url>/2024/09/05/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9B%B7%E5%86%9B%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/</url>
    <content><![CDATA[<p>雷军年度演讲</p>
<span id="more"></span>
<p>34c: BBA系列入门款</p>
<p>人生值得被奖励，这就是dream car 的意义</p>
<p>订货目标：76000</p>
<p>定价：对标moudle3 21.59</p>
<p>保底10万，立争12万</p>
]]></content>
      <categories>
        <category>企业家</category>
      </categories>
      <tags>
        <tag>雷军</tag>
      </tags>
  </entry>
  <entry>
    <title>银行科技岗</title>
    <url>/2024/09/18/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%93%B6%E8%A1%8C%E7%A7%91%E6%8A%80%E5%B2%97/</url>
    <content><![CDATA[<p>银行科技岗调研</p>
<span id="more"></span>
<p>B站up-<a href="https://www.bilibili.com/video/BV1P9HeeHEf3/?spm_id_from=333.999.0.0&vd_source=c6f3d03fea55d86e5f601be0590f20b5">草帽信息差</a></p>
<h2 id="银行现状："><a href="#银行现状：" class="headerlink" title="银行现状："></a>银行现状：</h2><blockquote>
<p>金融业降薪，但总体上银行还是不错的选择。此外三桶油，国网，烟草也是不错的！</p>
</blockquote>
<img src="/2024/09/18/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%93%B6%E8%A1%8C%E7%A7%91%E6%8A%80%E5%B2%97/image-20240918095257716.png" alt="image-20240918095257716" style="zoom:33%;">

<ul>
<li><strong>总行</strong>：核心岗位最多，<strong>科技岗核心研发</strong>都是在总行或者总行直属的研发中心（软开中心、大数据中心等)，有些银行可能会有加班的情况存在，薪资较高但是年终奖占比大、成长机会较多。</li>
<li><strong>省分行</strong>：有一定数量的科技岗，大部分银行省分科技岗较为轻松稳定，薪资一般都低于总行，且成长较为受限。</li>
<li><strong>省分以下</strong>：省分以下的分行一般来说科技岗较少甚至没有，大部分都是柜员、销售等。薪资和发展较为有限，且一线业务岗可能会面临绩效压力。</li>
</ul>
<p>第一梯队稳定性最高，薪资最低。第二梯队高一些，中信直属研发中心转正后一线可达 30W，成都可到 25W</p>
<h4 id="科技岗门槛"><a href="#科技岗门槛" class="headerlink" title="科技岗门槛"></a>科技岗门槛</h4><p><strong>总行</strong>：总行信息部+直属研发中心，科技岗位多，但是竞争激烈。四大银行&#x2F;招商银行总行信息部一般学历最好本硕985&#x2F;QS前50以上且有相关实习。直属研发中心其他银行总行对院校要求可能会稍低。<br><strong>省分行</strong>：科技岗一般来说要求本硕有一个是211&#x2F;双一流，本硕双非+多段优质实习也有机会。管培生岗位对院校要求会稍微高一些。<br><strong>省分以下</strong>：一般本科以上，对院校没有的特别死，但是近几年稍微卷一些，硕士应聘人数在增加。</p>
<h2 id="个例研究："><a href="#个例研究：" class="headerlink" title="个例研究："></a>个例研究：</h2><h4 id="民生银行"><a href="#民生银行" class="headerlink" title="民生银行"></a>民生银行</h4><p>招聘公告：<a href="http://career.cmbc.com.cn:8080/#/app/notice/65ac2d26-ce86-4362-a18b-0b83ff4e2aaa">http://career.cmbc.com.cn:8080/#/app/notice/65ac2d26-ce86-4362-a18b-0b83ff4e2aaa</a></p>
<p>招聘方向：管培生，金融科技，专业人才</p>
<p>截止时间：10月9号</p>
<p>国企银行求职讲座：</p>
<p>国企银行求职经历分享<br><img src="/2024/09/18/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%93%B6%E8%A1%8C%E7%A7%91%E6%8A%80%E5%B2%97/image-20240918120349072.png" alt="image-20240918120349072"></p>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>二叉树</p>
<span id="more"></span>
<h4 id="acwing-39-对称二叉树"><a href="#acwing-39-对称二叉树" class="headerlink" title="acwing 39 对称二叉树"></a>acwing 39 对称二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !root || <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode*p, TreeNode*q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>dfs 返回 p q 两棵子树是否对称</li>
<li><a href="https://www.acwing.com/solution/content/747/">https://www.acwing.com/solution/content/747/</a></li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/11/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>位运算技巧</p>
<span id="more"></span>

<h2 id="快速幂操作"><a href="#快速幂操作" class="headerlink" title="快速幂操作"></a>快速幂操作</h2><p><a href="https://leetcode.cn/problems/recursive-mulitply-lcci/">面试题 08.05. 递归乘法</a></p>
<p><strong>题目描述</strong>：不用 * 只用  &gt;&gt; 和 + 实现乘法</p>
<p><strong>思维过程</strong>：</p>
<ul>
<li>模拟竖式计算的二进制版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++)</span><br><span class="line">    <span class="keyword">if</span>(B &gt;&gt; i &amp; <span class="number">1</span>) sum += A &lt;&lt; i;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; B; B &gt;&gt;= <span class="number">1</span>,cnt ++) </span><br><span class="line">    <span class="keyword">if</span>(B &amp; <span class="number">1</span>) sum += A &lt;&lt; cnt;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 cnt 和 下面的 x*&#x3D;x 一样作为算子，每一轮都要更新</li>
</ul>
<p><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></p>
<p><strong>题目描述</strong>：求 x ^ n 快于 O(n) 的方式</p>
<p><strong>思维过程</strong>：</p>
<ul>
<li>把 n 按二进制位拆解，利用 x^(a+b) &#x3D; x^a * x^b</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">bool</span> is_minus = n &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="built_in">abs</span>(n); k; K &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_minus) res = <span class="number">1</span> / res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合论与位运算"><a href="#集合论与位运算" class="headerlink" title="集合论与位运算"></a>集合论与位运算</h2><p><a href="https://leetcode.cn/circle/discuss/CaOJ45/">从集合论到位运算，常见位运算技巧分类总结！</a></p>
<p><a href="https://leetcode.cn/problems/minimize-xor/">2429. 最小异或</a></p>
<p><strong>题目描述</strong>：求一个 x ,使得 x 和 num2 的置位数相同，同时，使得 x xor num1 尽可能小</p>
<p><strong>思维过程</strong>：</p>
<ul>
<li>先算出二者数位中 1 的个数，然后再 num1 的基础上增删。增删的位置是在末尾进行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimizeXor</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c1 = __builtin_popcount(num1);</span><br><span class="line">    <span class="type">int</span> c2 = __builtin_popcount(num2);</span><br><span class="line">    <span class="keyword">for</span> (; c2 &lt; c1; ++c2) num1 &amp;= num1 - <span class="number">1</span>; <span class="comment">// 最低的 1 变成 0</span></span><br><span class="line">    <span class="keyword">for</span> (; c2 &gt; c1; --c2) num1 |= num1 + <span class="number">1</span>; <span class="comment">// 最低的 0 变成 1</span></span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股一文终结</title>
    <url>/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/</url>
    <content><![CDATA[<p>系统整理面试八股</p>
<span id="more"></span>

<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://xiaozhuanlan.com/topic/2167809435">https://xiaozhuanlan.com/topic/2167809435</a> </p>
<p><a href="https://blog.csdn.net/wulitaotao96/article/details/95389864">https://blog.csdn.net/wulitaotao96/article/details/95389864</a></p>
<p><a href="https://blog.csdn.net/wulitaotao96/article/details/96168484">https://blog.csdn.net/wulitaotao96/article/details/96168484</a></p>
<p><a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a> 太浅</p>
<p><a href="https://cyc2018.xyz/">https://cyc2018.xyz/</a></p>
<p><a href="https://www.nowcoder.com/">https://www.nowcoder.com/</a></p>
<p><a href="https://github.com/cmyyy/Homemade-Java-interview-questions-2021">https://github.com/cmyyy/Homemade-Java-interview-questions-2021</a></p>
<p><a href="https://www.nowcoder.com/discuss/353146924222062592">cyc整理 1</a></p>
<p><a href="https://blog.csdn.net/wulitaotao96/article/details/95773762">cyc整理2</a></p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><ul>
<li><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><ul>
<li>应用层：规定了具体应用的处理协议。如 HTTP，FTP，DNS</li>
<li>传输层：为应用层提供连接支持，如 TCP，UDP</li>
<li>网络层：实现点对点的通信，为数据规划合理路径。IP</li>
<li>链路层：用来处理连接网络的硬件部分。主要是网卡驱动完成</li>
</ul>
</li>
<li><h5 id="协议簇"><a href="#协议簇" class="headerlink" title="协议簇"></a>协议簇</h5><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20240923103948887.png" alt="image-20240923103948887"></p>
</li>
<li><h5 id="TCP-UDP-对比"><a href="#TCP-UDP-对比" class="headerlink" title="TCP UDP 对比"></a>TCP UDP 对比</h5><ul>
<li><strong>有无连接</strong>：TCP 先通过三次握手，建立连接，传输过程中进行流量控制和拥塞控制，保证数据的顺序性和及时性，传输结束之后四次挥手结束连接。而 UDP 是一种无连接协议，直接发送报文，不进行三次握手四次挥手，UDP 速度快，但是不提供数据的可靠性和完整性保证，数据报文可能会丢失或乱序。</li>
<li><strong>可靠性</strong>：TCP 在传输过程中会对应用层报文进行分段，重传，确认，可以保证数据的完整性和可靠性(校验机制）。</li>
<li><strong>适用场景</strong>：TCP 由于提供可靠传输，适用于大多数场景，文件传输，网页浏览，电子邮件。UDP 适用于速度要求高，但是可靠性要求不那么高的情景：游戏，音视频，实时通信</li>
<li><strong>头部结构</strong>：TCP 负责的头部，UDP 只有 8 字节头部</li>
</ul>
</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>状态码<ul>
<li><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li>
<li><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li>
<li><code>3xx</code> 类状态码表示所请求资源发生变动，需要用新的 URL 进行请求，也就是重定向</li>
<li><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li>
<li><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li>
</ul>
</li>
<li>GET 和 POST<ul>
<li>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</li>
<li>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</li>
</ul>
</li>
<li>从URL 到显示页面的过程<ul>
<li>DNS 将URL转IP</li>
<li>有了服务端IP,发送HTTP连接请求，TCP 开始建立连接</li>
<li>服务器将 html 传回主机，主机交给浏览器进行解析渲染</li>
</ul>
</li>
<li>长连接和短连接<ul>
<li>短：客户端与服务器之间建立的连接在完成一次请求后就会关闭。适用于请求频率不高的场景，例如HTTP&#x2F;1.0默认的连接方式。</li>
<li>长：完成一次请求后不会立即关闭，而是保持一段时间，以便后续的请求可以复用这个连接。适用于请求频率较高的场景，例如HTTP&#x2F;1.1默认的连接方式。</li>
<li>所以二者区分的核心是一次连接里可以发起请求的数量。</li>
</ul>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>http是HTTP协议运行在<strong>TCP</strong>之上。所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的<strong>身份</strong>。</li>
<li>https是HTTP运行在<strong>SSL&#x2F;TLS</strong>之上，SSL&#x2F;TLS运行在TCP之上。所有传输的内容都经过<strong>加密</strong>，加密采用对称加密，但对称加密的密钥用服务器方的<strong>证书</strong>进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</li>
<li>总结 HTTPS 改进：<strong>通信加密，证书认证，完整性保护</strong>。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><ul>
<li>持久性连接</li>
<li>管道机制：请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，<strong>弊端</strong> 是 FIFO 造成的饥饿</li>
<li>分块传输：服务器产生部分数据，那么就发送部分数据。</li>
</ul>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><ul>
<li><strong>基于二进制</strong>：HTTP1.x 是基于文本，HTTP2 是基于二进制</li>
<li><strong>多路复用</strong>：连接之间是共享的。一个request对应一个id，这样一个连接上可以有多个request。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote>
<p>有连接，可靠，基于字节流</p>
</blockquote>
<ul>
<li><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><ul>
<li>过程<ul>
<li>发送端首先发送一个带 SYN 标志的数据包给对方。</li>
<li>接收端收到后，回传一个带有 SYN&#x2F;ACK 标志的数据包以示传达确认信息。</li>
<li>最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/Jiaodaqiaobiluo/article/details/130058180">为什么要三次握手，两次不行</a>？<ul>
<li>主要是为了在防止在网络拥塞情况下，服务端资源浪费。</li>
<li>具体来说，假如是两次握手，意味着服务端分配资源建立连接的时机应该是收到客户端的第一次握手立即建立。然而假如网络拥塞导致客户端发送了两个连接请求，就意味着服务端要建立两个连接。</li>
<li>采用三次握手就可以在客户端第二次确认连接的时候，服务端才分配资源建立连接。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><ul>
<li>过程<ul>
<li>客户端发送 FIN</li>
<li>服务端收到后进入 close-wait 状态，回送客户端 ACK,此时连接进入半关闭，服务端 将未尽事宜处理完，发送给客户端一个 FIN, 自己进入 last-ack 状态。</li>
<li>客户端收到最后的 FIN,回复 ACK ,并设置 2MSL 的等待时间。之后关闭连接</li>
<li>服务端收到客户端的 ACK 关闭连接</li>
</ul>
</li>
<li>为什么客户端要 2MSL<ul>
<li>防止客户端发出去的 ACK 没收到，服务端又发起关闭连接请求。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><ul>
<li>通过超时重传机制实现，超时标准为加权平均往返时间 RTTs，RTTs 的更新机制是新老往返时间按比例加权</li>
</ul>
</li>
<li><h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><ul>
<li>发送方，接收方都维护一个窗口，当窗口左边确认处理完之后，就可以向右移动到第一个没有确认处理的位置。</li>
</ul>
</li>
<li><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><ul>
<li>接收方用于控制发送方的发送速率，通过确认报文中的窗口字段完成，为 0 表示不让发送</li>
</ul>
</li>
<li><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20240925135031504.png" alt="image-20240925135031504"></p>
<ul>
<li>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</li>
<li>主要通过 慢开始、拥塞避免、快重传、快恢复 机制实现</li>
<li>要明白上面四个机制，首先明白 控制窗口 cwnd 和门限 ssthresh 的概念，前者是动态变化，后者是阶段性设置</li>
<li>慢开始：从 1 开始， 指数增长</li>
<li>拥塞避免：达到门限后线性增长</li>
<li>快重传和快恢复：遇到三次连续 ack 时执行，门限和控制窗口同时减半然后线性增长。此时认为并不是网络拥塞，而是个别丢包。</li>
<li>超时被认为是网络拥塞，采用慢开始策略。</li>
</ul>
</li>
<li><p>粘包</p>
<ul>
<li>由于TCP 是面向字节流的，会对上层数据进行拆分。自然的就会发生将上层不同消息的数据放到一个TCP报文的情况，这就叫刚发生了粘包</li>
<li>解决方法：靠应用层规定好消息的边界。具体的可以规定数据结构，可以用字段专门制定数据大小。</li>
</ul>
</li>
</ul>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><ul>
<li><h5 id="IP-分类地址"><a href="#IP-分类地址" class="headerlink" title="IP 分类地址"></a>IP 分类地址</h5><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20240923111657874.png" alt="image-20240923111657874"></p>
<ul>
<li>A 类、B 类、C 类、D 类、E 类。黄色为类号</li>
<li>ABC类中最大主机数为 2^n - 2, n 为主机号位数。减去的两个为主机号全零用于指代网络号，全一用于广播。</li>
<li>广播：分本网络内广播(路由器不转发，本网络内所有主机由于通过以太网直接连接，一定会接受到广播报文)，跨网络广播(一般情况下，出于安全考虑，路由器不转发这类报文。)</li>
<li>组播：将包发送给特定组内(通过组播号区分)的所有主机。组播 &#x3D; 多播；</li>
<li>单播，广播，组播 并列概念</li>
</ul>
</li>
<li><h5 id="IP-分类地址的缺点"><a href="#IP-分类地址的缺点" class="headerlink" title="IP 分类地址的缺点"></a>IP 分类地址的缺点</h5><ul>
<li><strong>类下面没有层次</strong>，如果一个公司用了 B 类地址，无法根据部门关系分配 IP</li>
<li><strong>网络大小是给死的，不灵活</strong>：C 类 254 个 IP, B 类 6万多个，大部分公司被迫申请 B 却用不完，造成浪费。</li>
</ul>
</li>
<li><h5 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h5><ul>
<li>没有ABC类的概念，采用前缀长度标记网络号的位数。</li>
</ul>
</li>
<li><h5 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h5><ul>
<li><h6 id="DNS-协议解析过程"><a href="#DNS-协议解析过程" class="headerlink" title="DNS 协议解析过程"></a>DNS 协议解析过程</h6></li>
</ul>
<p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20240923143835900.png" alt="image-20240923143835900"></p>
<ul>
<li><h6 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h6><ul>
<li>ip 地址指示了目的地是哪一个，但是每一步应该给局域网中哪个节点就需要 mac 地址，如果当前的节点不知道目的 ip 对应的 mac 地址，就需要用 arp 协议解析。</li>
</ul>
</li>
<li><h5 id="ICMP-上层协议。包括差错报告和询问。"><a href="#ICMP-上层协议。包括差错报告和询问。" class="headerlink" title="ICMP 上层协议。包括差错报告和询问。"></a>ICMP 上层协议。包括差错报告和询问。</h5><ul>
<li>ping 实质是发送一个 icmp 询问报文，对方回答之后，计算往返时间。</li>
<li>Traceroute 通过发送一系列具有不同 ttl 值的 UDP 报文，使得沿途每一个路由节点回送超时的抄错报告报文，从而获得每个路由节点。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟专用网 VPN</p>
<ul>
<li>通过互联网搭建虚拟的内部局域网。<strong>发送端</strong>通过vpn软件在加密报文，然后通过公网ip上隧道进行传输。<strong>接收端</strong>接收后解密，然后更改目的 ip。</li>
</ul>
</li>
<li><p>网络地址转换 NAT 技术</p>
<ul>
<li>内部局域网之间用私有地址，访问外部才转换为公网地址。</li>
</ul>
</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><a href="https://blog.csdn.net/wulitaotao96/article/details/95773762">https://blog.csdn.net/wulitaotao96/article/details/95773762</a></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="静态-动态链接库"><a href="#静态-动态链接库" class="headerlink" title="静态&#x2F;动态链接库"></a>静态&#x2F;动态链接库</h4><ul>
<li>定义：静态通常为 .lib .a ，动态通常 .dll .so</li>
<li>编译：静态被直接复制到可执行文件中，动态不复制而是到程序运行时才加载到内存</li>
<li>内存：动态可共享，静态不可共享</li>
<li>更新分发：静态库需要重新编译所有依赖改库的程序，动态只用更新库本身</li>
<li>优缺点：静态加载快，因为不需要解析外部函数，但是可执行文件大，占内存，更新麻烦。动态反之</li>
<li>总结：<strong>静态链接</strong>适合于那些不需要频繁更新，或者对执行速度有较高要求的程序。<strong>动态链接</strong>适合于那些需要频繁更新，或者希望减少可执行文件体积的程序。</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序是指令的集合，是一个静态文件。进程是程序的一次动态执行，是系统进行<strong>资源分配和调度的一个独立单位</strong>。。</li>
<li>然而进程有不足，那就是进程在执行的过程中如果<strong>阻塞</strong>，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
<li>为此我们开始进行多道程序并行执行，并引入了进程调度机制（FIFO,LRU）。</li>
</ul>
<h4 id="进程五状态模型"><a href="#进程五状态模型" class="headerlink" title="进程五状态模型"></a><a href="https://blog.csdn.net/weixin_43340372/article/details/132533846">进程五状态模型</a></h4><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241008103946293.png" alt="image-20241008103946293"></p>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241008111503665.png" alt="image-20241008111503665"></p>
<h4 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h4><h5 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h5><p>问题描述：一组生产者和一组消费者共享一块初始为空，大小确定的缓冲区，保证生产者不会在缓冲区满时加入数据，消费者不会在空时取数据。通常采用进程间通信解决该问题。</p>
<p>问题分析：所有生产者和消费者进程之间是互斥关系，生产者和消费者之间是同步关系。因而对于缓冲区的访问设置一个互斥量，再设置两个信号量一个记录空闲缓冲区单元，一个记录满缓冲区单元来实现生产者与消费者的同步。</p>
<h5 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a><a href="https://www.cnblogs.com/1314xhuan/p/16873831.html">读者写者问题</a></h5><p>问题描述：有读者与写者两个并发进程共享一个数据，两个或以上的读进程可以访问数据，但是一个写者进程访问数据与其他进程都互斥。</p>
<p>问题分析：读者与写者是互斥关系，写者与写者是互斥关系，读者与读者是同步关系。因而需要一个互斥量实现读与写和写与写互斥，一个读者的访问计数和实现对计数的互斥。</p>
<h5 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h5><p>问题描述：一张圆桌上坐着五名哲学家，每两名哲学家之间的桌子摆一根筷子，哲学家只有同时拿起左右两根筷子时才可以用餐，用餐完了筷子放回原处。</p>
<p>问题分析：这里五名哲学家就是五个进程，五根筷子是需要获取的资源。可以定义互斥数组用于表示五根筷子的互斥访问，为了防止哲学家个取一根筷子出现死锁，需要添加一定的限制条件。一种方法是限制仅当哲学家左右筷子均可以用时，才拿起筷子，这里需要一个互斥量来限制获取筷子不会出现竞争。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><ul>
<li>半双工；只用于父子或兄弟进程间；类似文件用 read write 接口读写，但只存在于内存；</li>
</ul>
<p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241008114356046.png" alt="image-20241008114356046"></p>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><a href="https://blog.csdn.net/weixin_57023347/article/details/127196944">消息队列</a></h5><ul>
<li><p>linux 下的消息队列：<a href="https://blog.csdn.net/weixin_57023347/article/details/127196944">https://blog.csdn.net/weixin_57023347/article/details/127196944</a></p>
</li>
<li><p>是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
</li>
</ul>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><ul>
<li>是一个计数器。信号量仅用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li>
</ul>
<h5 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h5><ul>
<li>指两个或多个进程共享一个给定的存储区。</li>
</ul>
<h5 id="Socket、Streams"><a href="#Socket、Streams" class="headerlink" title="Socket、Streams"></a>Socket、Streams</h5><ul>
<li>不同主机间通信</li>
</ul>
<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><p>多个程序并发过程中因为抢夺资源造成的一种僵局。</p>
<h5 id="死锁必要条件"><a href="#死锁必要条件" class="headerlink" title="死锁必要条件"></a>死锁必要条件</h5><ul>
<li>互斥，不可剥夺，请求保持，循环等待</li>
</ul>
<h5 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h5><ul>
<li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。</li>
<li>避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态。有序资源分配法，<strong>银行家算法</strong></li>
<li>检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li>
<li>解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><p>为什么引入线程？因为对于进程来说，一旦某一部分发生阻塞，整个进程需要被迫挂起，操作系统需要进程调度。而进程调度的时间成本是很大的，要分配独立的地址空间，建立各种数据结构来记录代码段，数据段，堆栈。</p>
</li>
<li><p>而线程就可以规避这个开销</p>
<ul>
<li>首先，运行于一个进程里面的多个线程其实是共享进程的地址空间的，线程的切换开销非常小。</li>
<li>其次，同一进程的线程共享数据，很方便进行通信。而进程间的通信则依赖于已操作系统提供的进程间通信方式。</li>
<li>再者，线程可以充分利用CPU的多核优势，将不同线程加载到不同的CPU。</li>
</ul>
</li>
<li><p>线程是进程的一个实体, 是<strong>CPU调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如<strong>程序计数器,一组寄存器和栈</strong>),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul>
<li>是操作系统的一种内存管理技术，使得程序逻辑上拥有连续内存空间，但其实被映射到了不同的物理内存地址。</li>
<li>分为请求分页，请求分段，请求段页三种存储管理方法</li>
</ul>
<h4 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h4><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过<strong>调页功能</strong>将其调入，同时还可以通过置换功能将暂时不用的页面<strong>换出到外存</strong>上，以便腾出内存空间。</p>
<p>支持机构：<strong>页表，缺页中断机构，页表映射机构。</strong></p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul>
<li>OPT，移出不需要再用的页面，最优算法，理想算法现实不能实现。</li>
<li>FIFO，实现最简单，适合线性顺序访问地址空间。</li>
<li>LRU，基于局部性原理，根据访问历史推测接下来访问规律，剔除最近时间内最久不用的页面。</li>
</ul>
<h4 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h4><ul>
<li>分页是为了内存离散化管理，减小零头消耗，提高内存使用率。页是物理单位。</li>
<li>分段是为了方便用户根据语义对程序进行分块。段是逻辑单位。</li>
<li>分页大小事固定的，分段是程序员指定的。</li>
<li>分页的作业地址空间是一维的，即单一的线性地址空间。 分段的作业地址空间是<strong>二维</strong>的 在标识一个地址时，即需给出段名，又需给出段内地址</li>
</ul>
<h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>linux 平台主要的文件系统有 ext2&#x2F;ext3&#x2F;ext4，总的层次结构如下：</p>
<p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241009135458721.png" alt="image-20241009135458721"></p>
<p>这里要理解文件系统，只要理解最后两行即可，上面两行更多涉及的是硬件层面。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul>
<li><strong>block</strong>：首先硬盘天然的物理单位是扇区(512字节)，但是如果以扇区为单位进行读写，会频繁进行IO,效率低，于是提出了 block 逻辑分块，文件以 block 为单位进行存储，一个文件可以占用一个或多个 block. 一个 block 通常为 1k , 4k.</li>
<li><strong>inode</strong>：确定了硬盘以 block 为单位进行使用，相当于把硬盘划分成了一个个容器。然而对于文件来说，如果直接将文件分散到 block 中去，我们很难去定位。于是我们需要一种识别定位文件的元数据结构，就提出用inode 数据结构记录文件元信息。由于 inode 和 block 不能一一对应，我们不知道确切的 inode 表项的需求数量，所以 inode 表项数量是一个可以设置的变量。inode 通常包含：<ul>
<li>该文件的存取模式(read&#x2F;write&#x2F;excute)；</li>
<li>该文件的拥有者与群组(owner&#x2F;group)；</li>
<li>该文件的容量；</li>
<li>该文件创建或状态改变的时间(ctime)；</li>
<li>最近一次的读取时间(atime)；</li>
<li>最近修改的时间(mtime)；</li>
<li>定义文件特性的旗标(flag)，如 SetUID…；</li>
<li>该文件真正内容所在的 block (pointer)；</li>
</ul>
</li>
<li><strong>bmap</strong>：那么多的 block，增删过程中我们如何维护 block 已使用或未使用信息呢？就是用 block 的位图 </li>
<li><strong>imap</strong>：imap 同理是 inode 表项的位图，可以用于查找未用的 inode 号</li>
<li><strong>block group</strong>：上面的 bmap imap inode_table 我们都可以当做元信息处理。有一个问题是如果把整个文件系统做成一个块组，那么这些元信息将非常长，不利于检索。于是我们将一个文件系统划分成多个块组。每个块组有自己的元信息。</li>
</ul>
<h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个 filesystem 了。他记录的信息主要有：</p>
<ul>
<li>block 与 inode 的总量；</li>
<li>未使用与已使用的 inode &#x2F; block 数量；</li>
<li>block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；</li>
<li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；</li>
<li>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。</li>
</ul>
<h4 id="块组描述表GDT"><a href="#块组描述表GDT" class="headerlink" title="块组描述表GDT"></a>块组描述表GDT</h4><p>既然 fs 被分成了多个块组，作为全局数据管理，就需要有一个表记录各个块组的元信息。每个表项大小 32 字节。</p>
<h4 id="保留GDT"><a href="#保留GDT" class="headerlink" title="保留GDT"></a>保留GDT</h4><p>防止 fs 扩容导致块组增加以至于 GDT 表项需要新的 block 来存储。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><p>linux 一切皆文件， 目录也是文件，所以目录文件是一个个目录项。</p>
</li>
<li><p>目录项的内容可以是目录也可以是文件。</p>
</li>
<li><p>我们之所以可以通过目录项访问到文件，是因为目录项里面提供了文件的 inode 号。</p>
</li>
<li><p>一个目录文件的内容可能如下</p>
<p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241009180313198.png" alt="image-20241009180313198"></p>
</li>
</ul>
<h4 id="inode-索引结构"><a href="#inode-索引结构" class="headerlink" title="inode 索引结构"></a>inode 索引结构</h4><p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241009180535136.png" alt="image-20241009180535136"></p>
<h4 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h4><p>硬链接：两个文件背后只有一个 inode, 相当于文件别名。</p>
<p>软链接：实实在在两个文件，只不过一个文件存储的内容是另一个文件的路径。且在路径不够长的情况下，不会分配 inode</p>
<p><img src="/2024/09/21/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B8%80%E6%96%87%E7%BB%88%E7%BB%93/image-20241009180926673.png" alt="image-20241009180926673"></p>
<p>参考文献：</p>
<p><a href="https://blog.csdn.net/xiaofeng_yang/article/details/138659090">轻松学Linux文件系统（Ext2&#x2F;Ext3&#x2F;Ext4）</a></p>
<p><a href="https://akaha.blog.csdn.net/article/details/125095984">十分钟理解硬链接和软链接</a></p>
<h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><p>由于 linux 的机制是父进程产生子进程后，不能知道子进程何时结束。</p>
<p><strong>僵尸进程</strong>：子进程结束但是父进程还没调用 wait()  或 waitpid 进行最后的资源清理(释放pid);</p>
<p><strong>孤儿进程</strong>：父进程结束，子进程继续运行，此时子进程成为孤儿进程。</p>
<p><strong>守护进程</strong>：进程创建时有意把父进程结束，然后被1号进程init收养。</p>
<p><strong>僵尸进程的问题和解决方式</strong>：</p>
<ul>
<li><p>问题：占用 pid 和一部分系统资源</p>
</li>
<li><p>僵尸进程产生原因：在子进程终止后到父进程调用wait()前的时间里，子进程被称为zombie；具体：</p>
<ul>
<li>子进程结束后向父进程发出SIGCHLD信号，父进程<strong>默认忽略</strong>了它</li>
<li>父进程<strong>没有调用wait()或waitpid()函数</strong>来等待子进程的结束</li>
<li><strong>网络原因</strong>有时会引起僵尸进程；</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>杀死父进程，让子进程归于 init 进程</li>
<li>调用 for() 两次，二子进程是短进程，孙子进程将来会归于 init 函数</li>
<li>父进程中捕捉SIGCHLD信号，并在信号处理函数中调用wait函数；</li>
</ul>
</li>
<li><p>参考</p>
</li>
<li><p><a href="https://blog.csdn.net/zjwson/article/details/53321431">https://blog.csdn.net/zjwson/article/details/53321431</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>二分思想</title>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>二分思想</p>
<span id="more"></span>

<p>二分：<a href="https://www.acwing.com/blog/content/19616/">https://www.acwing.com/blog/content/19616/</a></p>
<p><a href="https://www.acwing.com/blog/content/31/">https://www.acwing.com/blog/content/31/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, k = n - <span class="number">1</span>; j &lt; k; j ++, k --)</span><br><span class="line">            <span class="built_in">swap</span>(matrix[i][j], matrix[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 48 class Solution &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">string <span class="title">nstr</span><span class="params">(str)</span></span>;</span><br><span class="line">            <span class="built_in">sort</span>(nstr.<span class="built_in">begin</span>(),nstr.<span class="built_in">end</span>());</span><br><span class="line">            hash[nstr].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : hash)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(e.second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 49 快速幂</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">    <span class="type">bool</span> is_minus = n &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL k = <span class="built_in">abs</span>(n); k; k &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">        x *= x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is_minus) res = <span class="number">1</span> / res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 53 数组最大和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 67 数组求和</span></span><br><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    string c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>() || t; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.<span class="built_in">size</span>()) t += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.<span class="built_in">size</span>()) t += b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c += <span class="built_in">to_string</span>( t % <span class="number">2</span>);</span><br><span class="line">        t /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//73 编辑距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word<span class="number">1.</span><span class="built_in">size</span>(), m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    word1 = <span class="string">&#x27; &#x27;</span> + word1; word2 = <span class="string">&#x27; &#x27;</span> + word2;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) f[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> t = word1[i] != word2[j]; </span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + t); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br></pre></td></tr></table></figure>

<p>常用代码模板：</p>
<p><a href="https://www.acwing.com/blog/content/277/">https://www.acwing.com/blog/content/277/</a></p>
<p><a href="https://www.acwing.com/blog/content/404/">https://www.acwing.com/blog/content/404/</a></p>
<p><a href="https://www.acwing.com/blog/content/405/">https://www.acwing.com/blog/content/405/</a></p>
<p><a href="https://www.acwing.com/blog/content/406/">https://www.acwing.com/blog/content/406/</a></p>
<p><a href="https://www.acwing.com/blog/content/32065/">https://www.acwing.com/blog/content/32065/</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 按序刷题</title>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/leecode%E6%8C%89%E5%BA%8F%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>leetcode 按序刷题</p>
<span id="more"></span>
<h4 id="73-编辑距离"><a href="#73-编辑距离" class="headerlink" title="73 编辑距离"></a>73 编辑距离</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = word<span class="number">1.</span><span class="built_in">size</span>(), m = word<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">    word1 = <span class="string">&#x27; &#x27;</span> + word1; word2 = <span class="string">&#x27; &#x27;</span> + word2;	<span class="comment">// 单词从 1 开始是为了处理起来更加直观</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) f[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> t = word1[i] != word2[j]; </span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + t); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br></pre></td></tr></table></figure>

<ul>
<li>这种两个字符串求某种属性，大多数时候可以用这样的二维数组做动态规划</li>
<li>动态规划之所以快本质上是也因为：1）将前面的处理结果记录下来，2）由此可以每次处理一种集合的情况，而非每种情况单独处理</li>
</ul>
<h4 id="112-二叉树路径总和"><a href="#112-二叉树路径总和" class="headerlink" title="112 二叉树路径总和"></a>112 二叉树路径总和</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按节点类型枚举</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) </span><br><span class="line">        <span class="keyword">if</span>(targetSum == root-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val); </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line"><span class="comment">// 也是按节点类型，不过相当于合并了情况</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> !sum;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;left &amp;&amp; <span class="built_in">hasPathSum</span>(root-&gt;left,sum) || root-&gt;right &amp;&amp; <span class="built_in">hasPathSum</span>(root-&gt;right,sum);</span><br></pre></td></tr></table></figure>

<ul>
<li>二叉树问题的方法论：<ul>
<li>思考要统计什么数据</li>
<li>根据你要统计数据的定义，考虑怎么从左右子树和根节点三方得出这个数据</li>
<li>分别递归处理左右子树</li>
</ul>
</li>
</ul>
<h4 id="113-路径总和，记录路径"><a href="#113-路径总和，记录路径" class="headerlink" title="113 路径总和，记录路径"></a>113 路径总和，记录路径</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) </span><br><span class="line">            <span class="keyword">if</span>(!targetSum) &#123; ans.<span class="built_in">push_back</span>(path); path.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">            <span class="keyword">else</span> path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;h&#x27;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这份代码虽然可以过，但思路确实按各种节点分别枚举其行为。并没有采用标准的逐个节点处理逻辑进行递归。</li>
<li>此外和上一题的区别在于，上一题只要求找到一个符合的路径即可返回，而这道题要遍历所有路径，挑选出可行的</li>
<li>其实是回溯问题。采用回溯的解法如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) <span class="built_in">dfs</span>(root,targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root, <span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !targetSum)	<span class="comment">// 收集结果 </span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(path); </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">pathSum</span>(root-&gt;left,targetSum);	<span class="comment">// 分支向下递归</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();	<span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展平"><a href="#114-二叉树展平" class="headerlink" title="114 二叉树展平"></a>114 二叉树展平</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归方法，每次把左枝放进来</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;right) p = p-&gt;right;</span><br><span class="line">            p-&gt;right = root-&gt;right;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归方法, 先序便利处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TreeNode *root, TreeNode ** pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)  <span class="keyword">return</span>;</span><br><span class="line">    TreeNode * bleft = root-&gt;left;</span><br><span class="line">    TreeNode * bright = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pre != <span class="number">0</span>)</span><br><span class="line">        (*pre)-&gt;right = root;</span><br><span class="line">    *pre = root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">visit</span>(bleft,pre);</span><br><span class="line">    <span class="built_in">visit</span>(bright,pre);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    TreeNode * tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">visit</span>(root,&amp;tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="115-不同子序列"><a href="#115-不同子序列" class="headerlink" title="115 不同子序列"></a>115 不同子序列</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s; t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[j]) f[i][j] += f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            f[i][j] %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和以往不同之处在于并不是求 min max 而是 count, 状态划分是一样的，但是状态转移方法有变化</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串 hash</title>
    <url>/2023/10/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p>字符串 hash 研究</p>
<span id="more"></span>

<p>介绍：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/1440030/">https://www.acwing.com/file_system/file/content/whole/index/content/1440030/</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样写递归</title>
    <url>/2024/09/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%80%8E%E6%A0%B7%E5%86%99%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>递归研究</p>
<span id="more"></span>
<h4 id="问题1：需要统计的总问题是什么-和-为此需要子问题解决什么"><a href="#问题1：需要统计的总问题是什么-和-为此需要子问题解决什么" class="headerlink" title="问题1：需要统计的总问题是什么 和 为此需要子问题解决什么"></a>问题1：需要统计的总问题是什么 和 为此需要子问题解决什么</h4><p><a href="https://leetcode.cn/problems/jC7MId/">LCR 051. 二叉树中的最大路径和</a></p>
<p><strong>题目描述：</strong>在树中找到一个路径，使得路径之和最大，路径不是必须包含根节点</p>
<p><strong>思维过程：</strong></p>
<ul>
<li><p>由于路径不必包含根节点，所以有必要看看<strong>以所有节点为根的子树</strong>里面的路径和最大值，取其中的最大值就是答案。</p>
</li>
<li><p>要想得到一个子树的路径和的最大值，需要考虑 1）以左孩子为端点的路径最大值  2）以右孩子为端点的路径最大值 3）子树根节点本身的值。这三段由于都可能为负数，我们的子树路径和最大值应该为 ：1）+ 3），2) + 3)，1）+ 2）+ 3）， 3）四种情况取最大值。</p>
<blockquote>
<p>可以看到，上面考虑的四种情况都包含了 3），原因是：</p>
<p>理论上讲，求子树中路径最大值，假如子树根节点和子树的右子树路径都为负数，可以从子树的左子树中取最大路径和作为子树的最大路径和。但是这里实际上是拿子树的左子树的最大路径和作为了子树的路径和最大值，越俎代庖了，而子树左子树的最大路径和我们会在将子树的左孩子作为根节点的时候统计。</p>
<p>所以我们在统计每个子树的路径最大值的时候，<strong>必须包含根节点</strong>，这才是独属于这颗子树的最大值，将所有“独属于”枚举完后，我们一定可以得到全局最大值</p>
</blockquote>
</li>
<li><p>说回递归，对于用递归解决问题来说，其实是一开始就要想两个重要的问题</p>
<ul>
<li>用于解决总问题的统计处理逻辑是什么？</li>
<li>用于辅助解决总问题的子问题是什么？也就是要求递归函数的返回值是什么？</li>
</ul>
</li>
</ul>
<p><strong>解答：</strong></p>
<p>对于本题：</p>
<ul>
<li>需要统计的数据：每个结点为根的子树的路径最大和</li>
<li>辅助子问题的解：孩子为端点的路径的最大值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> root_val = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> single = root_val;</span><br><span class="line">        single = <span class="built_in">max</span>(single, root_val + l);</span><br><span class="line">        single = <span class="built_in">max</span>(single, root_val + r);</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(single,root_val + l + r));</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>dfs 的返回值 single 需要的是上述 1）+ 3），2) + 3)， 3）三种情况的最大值，maxPathSum 返回的是统计所得  1）+ 3），2) + 3)，1）+ 2）+ 3）， 3）四种情况的最大值。</li>
<li>由于 maxPathSum  所要的返回值和子问题的返回值意义不同，所以不能在 maxPathSum  中直接递归，这种情况下需要的是写一个递归函数，在递归函数中作统计，统计完作为 maxPathSum  函数的返回值。</li>
<li>ans 的详细理解： <ul>
<li><strong>生命周期问题</strong>：首先，ans 的作用是统计所有子树中的路径最大值，所以整个递归期间，ans 必须能够被所有递归函数看见且全局唯一。这样的要求两种方式可以满足：<ul>
<li>全局变量</li>
<li>传引用，哪怕是局部变量。这样需要把 ans 作为一个参数带到每个递归过程里</li>
</ul>
</li>
<li><strong>初值问题</strong>：ans 的作用是统计所有子树中的路径最大值，这样有两种方式可以满足<ul>
<li>ans 设为任意一个可以作为子树最大值的值</li>
<li>ans 设为一个所有可能数据之外的最小的值，确保一进入递归 ans 就可以被 max 函数更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面是把 ans 传引用的一种做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> &amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> root_val = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left, ans);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right, ans);</span><br><span class="line">        <span class="type">int</span> single = root_val;</span><br><span class="line">        single = <span class="built_in">max</span>(single, root_val + l);</span><br><span class="line">        single = <span class="built_in">max</span>(single, root_val + r);</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(single,root_val + l + r));</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>用递归解决问题，首先需要想明白你要在递归中统计的总问题是什么？为此需要递归子问题的返回值是什么？</li>
<li>假如总问题和子问题是一致的，可以在原函数中直接写递归。否则，要单写递归函数，把要统计的数据作为全局变量，递归过程中更新统计数据，递归结束之后统计数据自然更新为了问题的解，此时返回给原函数即可。</li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>动态规划总结</p>
<span id="more"></span>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>问题描述： n 个物体，每个物体重量价值分别为 w v , 在此基础上用承重为 W 的包去装物体，以使所装物体价值最大化。</p>
<ul>
<li>0-1 背包 ：每件物品最多用一次</li>
<li>完全背包：每件物品有无限个</li>
<li>多重背包：每个物品设置一个上限 s</li>
<li>分组背包：物品之间分成组，组内物品互斥选择</li>
<li>分析方法：  <ul>
<li><strong>状态表示</strong>：什么集合的什么属性</li>
<li><strong>状态计算</strong>：当前状态怎么由前置状态转移过来</li>
</ul>
</li>
</ul>
<h4 id="0-1-背包："><a href="#0-1-背包：" class="headerlink" title="0-1 背包："></a>0-1 背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 朴素方法</span></span><br><span class="line"><span class="type">int</span> v[N];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[M];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[N][M];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i])  </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line"><span class="comment">// 一维</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)  </span><br><span class="line">    	f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);	<span class="comment">// 选和不选，从上层转移过来，所以逆序</span></span><br><span class="line"><span class="comment">// 边输入边处理</span></span><br><span class="line">cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br></pre></td></tr></table></figure>

<p>解：<a href="https://www.acwing.com/solution/content/1374/">https://www.acwing.com/solution/content/1374/</a></p>
<p>分析方法：<a href="https://www.acwing.com/problem/content/discussion/content/2807/">https://www.acwing.com/problem/content/discussion/content/2807/</a></p>
<h4 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 朴素版本：o(nm*m)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">    <span class="comment">//  为何括号中第一个是 f[i][j] 而不是 f[i-1][j]</span></span><br><span class="line">    <span class="comment">//  由于 k=0 必执行，这次执行确定性把 f[i][j] 赋值为 f[i-1][j]</span></span><br><span class="line"><span class="comment">// 观察现象：</span></span><br><span class="line">    <span class="comment">//  f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,)</span></span><br><span class="line">    <span class="comment">//  f[i][j-v] = max(       ,f[i-1][j-v],  f[i-1][j-2v]+w ,f[i-1][j-3v]+2v,)</span></span><br><span class="line">    <span class="comment">//  f[i][j] = max(f[i-1][j],f[i][j-v]+w)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 由此，改进版本 O(nm)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][j];<span class="comment">//v[i] 之前，第 i 个物品放不进去，直接搬下来就行</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;=v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        <span class="comment">// 这次优化可以从上面的max计算的规律去想，也可以从f[i][j]依赖f[i][j-v[i]]去理解</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 至此，对比 0-1 背包和完全背包的转移方程</span></span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-v[i]] + w[i])  <span class="comment">// 都是从上一行转移过来</span></span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-v[i]] + w[i])	<span class="comment">// 从上一行和同行的前置位过来，这里依赖同行的前置位，故不能倒序</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 3. 改进成一维 O(nm)</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);     <span class="comment">// f[j-v[i]] 和 f[j] 有绝对的 w[i] 差值</span></span><br></pre></td></tr></table></figure>

<h4 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 朴素解法 O(nmm)</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 1 开始，将数据录入和物品编号实际对应，虽然浪费一个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k * w[i]); </span><br><span class="line"><span class="comment">// 2. 一维解法 O(nmm)</span></span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v]+w,f[i<span class="number">-1</span>][j<span class="number">-2</span>v]<span class="number">+2</span>w,f[i<span class="number">-1</span>][j<span class="number">-3</span>v]<span class="number">+3</span>w,...,f[i<span class="number">-1</span>][j-sv]+sw)</span><br><span class="line">f[i][j-v]=<span class="built_in">max</span>(          f[i<span class="number">-1</span>][j-v],  f[i<span class="number">-1</span>][j<span class="number">-2</span>v]+w, f[i<span class="number">-1</span>][j<span class="number">-3</span>v]<span class="number">+2</span>w,...,f[i<span class="number">-1</span>][j-sv]+(s<span class="number">-1</span>)w,f[i<span class="number">-1</span>][j-(s<span class="number">+1</span>)v]+sw)</span><br><span class="line"><span class="comment">// 遗憾的是得知后面的最大值 f[i][j-v] ，并不能推知其子集f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,...,f[i-1][j-sv]+sw 的最大值，因此不能像完全背包一样依赖前置位。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)</span><br><span class="line">            <span class="keyword">if</span>(k*v[i]&lt;=j) f[j]=<span class="built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);</span><br><span class="line"><span class="comment">// 3. 二进制拆分优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>, M = <span class="number">2010</span>;</span><br><span class="line"><span class="comment">//  25000来历：n,s取值都在2000之内，那么s个同类物品最多被分为log(s)组，也即最多11组，2000种物品算起来最多的组为2000*11</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//逐一枚举最大是N*logS</span></span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// 体积&lt;M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s) <span class="comment">// 按2的阶乘分组</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ; </span><br><span class="line">            v[cnt] = a * k ;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k; </span><br><span class="line">            k *= <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a*s; </span><br><span class="line">            w[cnt] = b*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt ; </span><br><span class="line">    <span class="comment">//01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m ;j &gt;= v[i];j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分组背包："><a href="#分组背包：" class="headerlink" title="分组背包："></a>分组背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N];</span><br><span class="line"><span class="type">int</span> f[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用一维时：数据依赖上一行，则倒序；依赖同一行前置位则正序。</span></span><br></pre></td></tr></table></figure>

<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h4 id="数字三角形-acwing-898"><a href="#数字三角形-acwing-898" class="headerlink" title="数字三角形 acwing 898"></a>数字三角形 <a href="https://www.acwing.com/problem/content/description/900/">acwing 898</a></h4><ul>
<li>思路：<ul>
<li>状态表示（集合，属性）：到达任意坐标（i, j) 的路径和的最大值为 f[i][j]</li>
<li>状态转移 ： 这个最大值要么从左边转移过来，要么从右边转移过来，故 f[i][j] &#x3D; max(f[i -  1][j - 1] , f[i -  1][j]) +  a[i][j]</li>
</ul>
</li>
<li>其他注意事项：<ul>
<li>要想让三角形边界选到三角形内的数据，就要把 f 数组中三角形边界设置为负无穷</li>
<li>题目要求是到最底层，结果要在 f 数组的最后一行中找，极端情况下，所有元素都是最小值，累积出来的路径和会很小，因此，用于遍历最后一行的值也要设无穷小。</li>
<li>左右的坐标相对位置要找对</li>
</ul>
</li>
<li>其他解法：倒序遍历，相当于从底部走到顶部<a href="https://www.acwing.com/solution/content/128359/">https://www.acwing.com/solution/content/128359/</a></li>
</ul>
<h4 id="最长上升子序列-acwing-895"><a href="#最长上升子序列-acwing-895" class="headerlink" title="最长上升子序列 acwing 895"></a>最长上升子序列 <a href="https://www.acwing.com/activity/content/problem/content/1003/">acwing 895</a></h4><ul>
<li><p>思路1: 递推</p>
<ul>
<li>状态表示（集合，属性）：以 num[i] 结尾的最长单调子序列长度为 f[i]</li>
<li>状态转移：遍历前面 i - 1个 f 数组元素，遇到 w[i] &gt; w[j] 则，f[i] &#x3D; max(f[i], f[j] +  1), 没遇到则 f[i] &#x3D;  1</li>
<li>时间复杂度：状态数(n) * 转移数(n)，O(n^2),</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ranges::<span class="built_in">max</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路2: 二分</p>
<ul>
<li>维护数组 dp，dp[i] 表示长度为 i 的递增序列第 i 个元素可能的最小值</li>
<li>复杂度分析：O(nlogn) ，状态数(n) * 转移数(logn)</li>
<li>利用二分的解法： <a href="https://www.acwing.com/solution/content/4807/">https://www.acwing.com/solution/content/4807/</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),m[i]);</span><br><span class="line">    <span class="keyword">if</span>(pos == dp.<span class="built_in">end</span>()) dp.<span class="built_in">push_back</span>(m[i]);</span><br><span class="line">    <span class="keyword">else</span> *pos = m[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结：</p>
<ul>
<li>第一种递推方法可以获得任意位置递增子序列的长度，第二种方法可以很方便获得全局最长子序列。</li>
</ul>
<h4 id="最长公共子序列-acwing-897"><a href="#最长公共子序列-acwing-897" class="headerlink" title="最长公共子序列 acwing 897"></a>最长公共子序列 <a href="https://www.acwing.com/activity/content/problem/content/1005/">acwing 897</a></h4><ul>
<li><p>思路</p>
<ul>
<li>状态表示：f[i][j] A 的前 i 个字符， B 的前 j 个字符的公共子序列 的最长公共子序列</li>
<li>状态转移：f[i][j] 可以由以下四个状态变换过来：<ul>
<li>a[i],b[j] 均存在于 最长公共子序列中 (前提a[i]&#x3D;&#x3D;b[j])</li>
<li>a[i] 在，b[j] 不在   （无前提），不完全等同于  f[i][j - 1] </li>
<li>a[i],b[j] 均不在     （无前提）</li>
<li>a[i]不在，b[j]在     （无前提）</li>
</ul>
</li>
<li>更详细的分析：<a href="https://www.acwing.com/solution/content/48820/">https://www.acwing.com/solution/content/48820/</a></li>
<li>代码示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">     f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">     <span class="keyword">if</span>(a[i]==b[j]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><ul>
<li>思路<ul>
<li>状态表示</li>
<li>状态转移</li>
</ul>
</li>
</ul>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>灵神题单2-单调栈</title>
    <url>/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%952-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>单调栈</p>
<span id="more"></span>

<p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></p>
<p><strong>题目描述：</strong>给出一个表示每日温度的 vector, 返回一个数组，数组中对应放置对应该天多少天后出现温度比该天高的情况。</p>
<p><strong>解题思路1</strong>：</p>
<ul>
<li>从左往右，栈中记录还没算出「下一个更大元素」的那些数（的下标）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;  st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || temperatures[i] &lt;= temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是两份逻辑完全一致的代码，但是前一份代码会越界错误。问题出在 <code>while(temperatures[i] &gt; temperatures[st.top()])</code>,这 里 while 由于没有约束会像脱缰野马一样当 st 为空还要进行 temperatures[i] &gt; temperatures[st.top()] 比较操作，自然会越界。所以，写 while 一定要加上<strong>缰绳</strong>。这里改为 <code>while(!st.empty() &amp;&amp; temperatures[i] &gt; temperatures[st.top()])</code> 就可以通过。</li>
</ul>
<p><strong>解题思路2</strong>：</p>
<ul>
<li>从右往左，栈中记录下一个更大元素的「候选项」。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;	<span class="comment">// 这里可以设置找不到情况的默认值</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;  st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = temperatures[i];</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; t &gt;= temperatures[st.<span class="built_in">top</span>()]) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) ans[i] = st.<span class="built_in">top</span>() - i;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点</a></p>
<p><strong>题目描述</strong>：一样的题目，不过是换成了链表</p>
<p><strong>解题思路</strong>：对于链表来说，我们可以从头节点开始递归，在「归」的过程中，就相当于是从右到左遍历链表了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 单调栈（节点值）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ListNode * node, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;ans.<span class="built_in">resize</span>(i); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="built_in">f</span>(node-&gt;next, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; node-&gt;val &gt;= st.<span class="built_in">top</span>())</span><br><span class="line">            st.<span class="built_in">pop</span>(); <span class="comment">// 弹出无用数据</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">            ans[i] = st.<span class="built_in">top</span>(); <span class="comment">// 栈顶就是第 i 个节点的下一个更大元素</span></span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">f</span>(head, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的启发主要在于递归写法，就是一致递下去，归的过程中处理，就形成了倒序处理</li>
</ul>
<p><strong>解题思路2</strong>：非递归版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 206. 反转链表</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            ListNode *nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        head = <span class="built_in">reverseList</span>(head);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 单调栈（节点值）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cur = head; cur; cur = cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &lt;= cur-&gt;val)</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 弹出无用数据</span></span><br><span class="line">            <span class="comment">// 栈顶就是第 i 个节点的下一个更大元素</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(st.<span class="built_in">empty</span>() ? <span class="number">0</span> : st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于是倒着记录答案的，返回前要把答案反转</span></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>翻转链表的“码形结合”</li>
</ul>
<p>解题思路3：从左往右，栈中记录还没有处理的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st; <span class="comment">// 单调栈（节点值，节点下标）</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> cur = head; cur; cur = cur-&gt;next, i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt; cur-&gt;val) &#123;</span><br><span class="line">                ans[st.<span class="built_in">top</span>().second] = cur-&gt;val; <span class="comment">// 用当前节点值更新答案</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前 ans 的长度就是当前节点的下标</span></span><br><span class="line">            st.<span class="built_in">emplace</span>(cur-&gt;val, i);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 占位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于是链表，又没有事先遍历一遍拿到长度，所以需要占位 0 ，为将来填写 ans 预留空间</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯问题</title>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>回溯思想</p>
<span id="more"></span>

<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><blockquote>
<p>回溯算法是纯暴力搜索，枚举所有情况，拿到满足的叶子结点 </p>
</blockquote>
<p>组合问题：</p>
<p>切割问题：</p>
<p>子集问题：</p>
<p>排列问题：</p>
<p>棋盘问题：</p>
<p>可以抽象为树形结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件) &#123;收集结果，<span class="keyword">return</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(集合元素)</span><br><span class="line">    &#123;</span><br><span class="line">        处理节点；</span><br><span class="line">        递归；</span><br><span class="line">        回溯；           </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个没出现的正整数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : nums)</span><br><span class="line">            hash.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(hash.<span class="built_in">count</span>(res)) res ++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">        <span class="type">int</span> n = num<span class="number">1.</span><span class="built_in">size</span>(); <span class="type">int</span> m = num<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(num1[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(n+m)</span></span>;	<span class="comment">// 开辟长度是精髓，一定够用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">                C[i + j] += A[i] * B[j]; <span class="comment">// += 是精髓</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>(); i ++) <span class="comment">// 这里直到销声匿迹</span></span><br><span class="line">        &#123;</span><br><span class="line">            t += C[i];</span><br><span class="line">            C[i] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> k = C.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; ! C[k]) k --;	<span class="comment">// 过滤</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) res += C[k --] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通配符匹配 44</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s; p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || i &amp;&amp; f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                [i][j] =  (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; i &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 45 跳跃步数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j + nums[j] &lt; i) j ++; <span class="comment">// 消极前进</span></span><br><span class="line">            f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心 acwing</title>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B4%AA%E5%BF%83acwing/</url>
    <content><![CDATA[<p>acwing 贪心算法</p>
<span id="more"></span>

<ul>
<li><p>区间问题基础语法问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何存储区间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;<span class="type">int</span> l,r; <span class="type">bool</span> <span class="keyword">operator</span>&lt;()&#123;&#125;&#125;range[N]	<span class="comment">// 结构体数组</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;   vector&lt;PII&gt; <span class="comment">// vector 存 PII</span></span><br><span class="line"><span class="comment">// 如何排序</span></span><br><span class="line"><span class="keyword">operator</span>&lt;	<span class="comment">// 操作符重载</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">()</span>	<span class="comment">// 定义比较器</span></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(a.begin(), a.begin() + n, [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;)</span></span>; <span class="comment">// lambda 函数</span></span><br><span class="line"><span class="comment">// 如何输入一个区间</span></span><br><span class="line">range[i] = &#123;l,r&#125;; </span><br><span class="line">cin &gt;&gt; range[i].l &gt;&gt; range[i].r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">vc.<span class="built_in">push_back</span>(&#123;l,r&#125;);	<span class="comment">// pair 也算聚合体 可以用花括号作临时 pair 对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort 函数默认对 vector<PII> 进行双关键字排序</PII></p>
</blockquote>
</li>
<li><p>区间选点: 选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> r &lt; W.r; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; range[i].l)</span><br><span class="line">        &#123; res ++ ;ed = range[i].r; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按右端点排序</li>
<li>依次遍历区间，<ol>
<li>和当前 end 有交集，则跳过</li>
<li>无交集，更新 end</li>
</ol>
</li>
</ol>
<p>为什么按右端点排序？</p>
<p>因为要尽可能少的点，点从左往右选，希望步子尽可能大，但是前提是点穿过所有区间，所以步子限制在无交集区间中最靠左的右端点</p>
<p>为何和最大无交集区间数是一个问题？</p>
<p>最大不相交区间和最多会议安排，都是找尽早结束时间点的区间纳入选择集中，这和区间选点策略是一样的。</p>
</blockquote>
</li>
<li><p>区间分组: 将区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> l &lt; W.l; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= range[i].l)</span><br><span class="line">            heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">        <span class="keyword">else</span> &#123; heap.<span class="built_in">pop</span>(); heap.<span class="built_in">push</span>(range[i].r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按左端点排序</li>
<li>遍历区间<ol>
<li>当前区间可以放在某组，放入并更新结束时间</li>
<li>无法放入，开新组</li>
</ol>
</li>
</ol>
<p>为什么这里又变成了左端点排序？</p>
<ol>
<li>其实是按开始时间依次放入，倘若变成按结束时间依次放入</li>
</ol>
<p>另一种新奇的思路：<a href="https://www.acwing.com/solution/content/8902/">https://www.acwing.com/solution/content/8902/</a></p>
</blockquote>
</li>
<li><p>区间覆盖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st,ed;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i]=&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range,range+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123; r = <span class="built_in">max</span>(r, range[j].r); j ++; &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; st)&#123; cout &lt;&lt; <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)&#123; cout &lt;&lt; res; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        st = r; i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>区间按左端点排序</li>
<li>遍历区间<ol>
<li>从可以覆盖 st 的区间中找一个右端点最靠右的，最大化覆盖 st ed 区间</li>
<li>更新 st 为这个区间最靠右的值。回到 2-1 循环</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>区间问题总结：</p>
<ul>
<li><p>区间尽管可以将其看做元素，根据需要按左端点或右端点进行排序</p>
</li>
<li><p>哈夫曼树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n ==  <span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123; <span class="type">int</span> t; cin &gt;&gt; t; q.<span class="built_in">push</span>(t); &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s1 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> s2 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        res += s1 + s2;</span><br><span class="line">        q.<span class="built_in">push</span>(s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排队打水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="built_in">sort</span>(m,m + n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> wait = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123; res += wait; wait += m[i]; &#125;</span><br><span class="line"><span class="comment">// 方法2 太优美了！</span></span><br><span class="line"><span class="built_in">sort</span>(t, t + n);</span><br><span class="line"><span class="built_in">reverse</span>(t, t + n);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += t[i] * i;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>灵神题单1-滑动窗口与双指针</title>
    <url>/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%951-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>滑动窗口</p>
<span id="more"></span>

<h2 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h2><p>来源：<a href="https://leetcode.cn/circle/discuss/0viNMK/">https://leetcode.cn/circle/discuss/0viNMK/</a></p>
<h4 id="1154-定长字符串中元音字母最大个数"><a href="#1154-定长字符串中元音字母最大个数" class="headerlink" title="1154 定长字符串中元音字母最大个数"></a>1154 定长字符串中元音字母最大个数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;a&#x27;</span> || s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;i&#x27;</span> || s[i] == <span class="string">&#x27;o&#x27;</span> || s[i] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">            w++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,w);</span><br><span class="line">        <span class="type">char</span> t = s[i - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&#x27;a&#x27;</span> || t == <span class="string">&#x27;e&#x27;</span> || t == <span class="string">&#x27;i&#x27;</span> || t == <span class="string">&#x27;o&#x27;</span> || t == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">            w--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>滑动窗口问题的处理逻辑：1）进入窗口 2）更新统计数据 3）出窗口</li>
</ul>
<h4 id="643-子数组最大平均数"><a href="#643-子数组最大平均数" class="headerlink" title="643 子数组最大平均数"></a>643 子数组最大平均数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">-1e5</span>, avg = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        avg = sum / k;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, avg);</span><br><span class="line">        sum -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1343-大小为-k-且均值大于等于门限值"><a href="#1343-大小为-k-且均值大于等于门限值" class="headerlink" title="1343 大小为 k 且均值大于等于门限值"></a>1343 大小为 k 且均值大于等于门限值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>, w = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(sum / k &gt;= t) c++;</span><br><span class="line">        sum -= arr[i - k + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2090-半径为-k-的子数组的平均数"><a href="#2090-半径为-k-的子数组的平均数" class="headerlink" title="2090 半径为 k 的子数组的平均数"></a>2090 半径为 k 的子数组的平均数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">2</span> * k)	<span class="comment">// 这里和 if(i &lt; 2 * k) continue; 的逻辑其实是一样的</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[i - k] = sum / (k * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[i - <span class="number">2</span> * k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for 循环中一部分逻辑全程需要执行，一部分只在后半部分执行，这样可以利用一个<strong>条件判断</strong>将两部分分隔开</li>
</ul>
<h4 id="2379-k-个黑块的最小涂色次数"><a href="#2379-k-个黑块的最小涂色次数" class="headerlink" title="2379 k 个黑块的最小涂色次数"></a>2379 k 个黑块的最小涂色次数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">100</span> , w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; blocks.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(blocks[i] == <span class="string">&#x27;W&#x27;</span>) w ++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, w);</span><br><span class="line">            <span class="keyword">if</span>(blocks[i - k + <span class="number">1</span>] == <span class="string">&#x27;W&#x27;</span>) w --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1652-拆炸弹"><a href="#1652-拆炸弹" class="headerlink" title="1652 拆炸弹"></a>1652 拆炸弹</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 灵山版本</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">decrypt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; code, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = code.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> r = k &gt; <span class="number">0</span> ? k + <span class="number">1</span> : n;	<span class="comment">// 统一找到起始窗口的</span></span><br><span class="line">    k = <span class="built_in">abs</span>(k);</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">reduce</span>(code.<span class="built_in">begin</span>() + r - k, code.<span class="built_in">begin</span>() + r); <span class="comment">// ans[0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans[i] = s;</span><br><span class="line">        s += code[r % n] - code[(r - k) % n];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 朴素模拟版本</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">decrypt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; code, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(code.size())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; code.<span class="built_in">size</span>() + k; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += code[i % code.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                ans[(i - k + code.<span class="built_in">size</span>()) % code.<span class="built_in">size</span>()] = sum;</span><br><span class="line">                sum -= code[(i - k + <span class="number">1</span>) % code.<span class="built_in">size</span>()]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k = -k;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; code.<span class="built_in">size</span>() + k; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += code[i % code.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[(i + <span class="number">1</span>) % code.<span class="built_in">size</span>()] = sum;</span><br><span class="line">                sum -= code[(i - k + <span class="number">1</span>) % code.<span class="built_in">size</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 r 引入是最为精妙的，作为左闭右开区间，立马可以定位左端点为 r-k</li>
<li>reduce 算法接口用于计算一段容器元素的和，C++ 20 的接口</li>
<li>勤思考才能免于战术勤奋</li>
</ul>
<h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052 爱生气的书店老板"></a>1052 爱生气的书店老板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; c, vector&lt;<span class="type">int</span>&gt;&amp; g, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ex = <span class="number">0</span> , w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i]) w += c[i];</span><br><span class="line">        <span class="keyword">else</span> base += c[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ex = <span class="built_in">max</span>(ex,w);</span><br><span class="line">        <span class="keyword">if</span>(g[i - k + <span class="number">1</span>]) w -= c[i - k + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base + ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2841-几乎唯一子数组最大和"><a href="#2841-几乎唯一子数组最大和" class="headerlink" title="2841 几乎唯一子数组最大和"></a>2841 几乎唯一子数组最大和</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="built_in">find</span>(nums[i]) == hash.<span class="built_in">end</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(&#123;nums[i],<span class="number">1</span>&#125;);</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hash[nums[i]] ++;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= m) ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        sum -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">        hash[nums[i - k + <span class="number">1</span>]] --;</span><br><span class="line">        <span class="keyword">if</span>(!hash[nums[i - k + <span class="number">1</span>]]) </span><br><span class="line">        &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(nums[i - k + <span class="number">1</span>]); <span class="comment">// 复制粘贴写成了 hash.erase(hash[nums[i - k + 1]]); 花费 1h 调试</span></span><br><span class="line">            cnt --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">// 先统计 k-1 个数</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        cnt[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += nums[i]; <span class="comment">// 再添加一个数就是 k 个数了</span></span><br><span class="line">        cnt[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">size</span>() &gt;= m)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> out = nums[i - k + <span class="number">1</span>];</span><br><span class="line">        sum -= out; <span class="comment">// 下一个子数组不包含 out，移出窗口</span></span><br><span class="line">        <span class="keyword">if</span> (--cnt[out] == <span class="number">0</span>)</span><br><span class="line">            cnt.<span class="built_in">erase</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>几乎唯一的意思是至少有 m 个不同元素，满足<strong>几乎唯一</strong>的窗口我们才统计其和，如何判断是否满足几乎唯一？</li>
<li>用 hash map, 统计各个数字在窗口中的数量，另外用一个变量统计窗口中不同元素的数量（<strong>其实只需要用一下 hashmap 的 size 就可以了</strong>）</li>
<li><strong>一个很重的教训</strong>：一定确定 hash map 中存在某元素，才用 [] 取值，否则会无意引入元素！</li>
</ul>
<h4 id="2461-元素各异长度为-k-子数组最大和"><a href="#2461-元素各异长度为-k-子数组最大和" class="headerlink" title="2461 元素各异长度为 k 子数组最大和"></a>2461 元素各异长度为 k 子数组最大和</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>,sum = <span class="number">0</span>;  </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        hash[nums[i]]++;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">size</span>() == k)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        sum -= nums[i - k + <span class="number">1</span>];</span><br><span class="line">        hash[nums[i - k + <span class="number">1</span>]]--;</span><br><span class="line">        <span class="keyword">if</span> (hash[nums[i - k + <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">            hash.<span class="built_in">erase</span>(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cardPoints.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = n - k;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">begin</span>() + m, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> min_s = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">        s += cardPoints[i] - cardPoints[i - m];</span><br><span class="line">        min_s = <span class="built_in">min</span>(min_s, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">end</span>(), <span class="number">0</span>) - min_s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两头取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cardPoints, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="built_in">accumulate</span>(cardPoints.<span class="built_in">begin</span>(), cardPoints.<span class="built_in">begin</span>() + k, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        s += cardPoints[cardPoints.<span class="built_in">size</span>() - i] - cardPoints[k - i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆向思维：总集确定的情况下，求问题的补问题，然后推知要求的问题</li>
<li>一般来说，DP 适用于【子序列】问题，滑窗&#x2F;前缀和等适合【子数组】问题。用 DP 的话也要提前估计下时间复杂度是否正确。</li>
<li>规约函数：<code>reduce</code> 和 <code>accumulate</code> 区别：1）并行&#x2F;串行 2）定制二元操作&#x2F;只支持</li>
</ul>
<h4 id="1297-子串的最大出现次数"><a href="#1297-子串的最大出现次数" class="headerlink" title="1297. 子串的最大出现次数"></a><a href="https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/">1297. 子串的最大出现次数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFreq</span><span class="params">(string s, <span class="type">int</span> maxLetters, <span class="type">int</span> minSize , <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; strs;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; w;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    string t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += s[i];  <span class="comment">// 入窗口，</span></span><br><span class="line">        w[s[i]] ++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; minSize  - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(w.<span class="built_in">size</span>() &lt;= maxLetters)  <span class="comment">// 统计信息</span></span><br><span class="line">        &#123;</span><br><span class="line">            strs[t] ++;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,strs[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        w[t[<span class="number">0</span>]] --; <span class="comment">// 出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(!w[t[<span class="number">0</span>]]) w.<span class="built_in">erase</span>(t[<span class="number">0</span>]);</span><br><span class="line">        t = t.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先应该意识到的是有 maxsize 宽度的字符串达到最大值，一定也有 minsize 宽度的字符串达到最大值</li>
<li>滑动窗口 + 哈希表</li>
</ul>
<h4 id="2653-滑动子数组的美丽值"><a href="#2653-滑动子数组的美丽值" class="headerlink" title="2653. 滑动子数组的美丽值 **"></a><a href="https://leetcode.cn/problems/sliding-subarray-beauty/">2653. 滑动子数组的美丽值</a> **</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSubarrayBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt;small;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt;big;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>(),t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        big.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(big.<span class="built_in">size</span>()&gt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());</span><br><span class="line">            big.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res&#123;big.<span class="built_in">top</span>()&lt;<span class="number">0</span>?big.<span class="built_in">top</span>():<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> p=nums[i-k]&lt;=big.<span class="built_in">top</span>();<span class="comment">//删除的元素是否在左边</span></span><br><span class="line">        mp[nums[i-k]]++;</span><br><span class="line">        <span class="keyword">while</span>(!big.<span class="built_in">empty</span>()&amp;&amp;mp[t=big.<span class="built_in">top</span>()])</span><br><span class="line">        &#123;</span><br><span class="line">            mp[t]--;</span><br><span class="line">            big.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!small.<span class="built_in">empty</span>()&amp;&amp;mp[t=small.<span class="built_in">top</span>()])</span><br><span class="line">        &#123;</span><br><span class="line">            mp[t]--;</span><br><span class="line">            small.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> q=big.<span class="built_in">empty</span>()||nums[i]&gt;big.<span class="built_in">top</span>();<span class="comment">//是否在右边新加元素</span></span><br><span class="line">        <span class="keyword">if</span>(p&amp;&amp;q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左边删右边加</span></span><br><span class="line">            small.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            big.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">            small.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>((t=big.<span class="built_in">top</span>())&lt;<span class="number">0</span>?t:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p&amp;&amp;!q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//左边删左边加</span></span><br><span class="line">            big.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>((t=big.<span class="built_in">top</span>())&lt;<span class="number">0</span>?t:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p&amp;&amp;q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//右边删，右边加</span></span><br><span class="line">            small.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>((t=big.<span class="built_in">top</span>())&lt;<span class="number">0</span>?t:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p&amp;&amp;!q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//右边删左边加</span></span><br><span class="line">            big.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());</span><br><span class="line">            big.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(mp[big.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                mp[big.<span class="built_in">top</span>()]--;</span><br><span class="line">                big.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>((t=big.<span class="built_in">top</span>())&lt;<span class="number">0</span>?t:<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSubarrayBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BIAS = <span class="number">50</span>;</span><br><span class="line">    <span class="type">int</span> cnt[BIAS * <span class="number">2</span> + <span class="number">1</span>]&#123;&#125;, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) <span class="comment">// 先往窗口内添加 k-1 个数</span></span><br><span class="line">        ++cnt[nums[i] + BIAS];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n - k + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ++cnt[nums[i] + BIAS]; <span class="comment">// 进入窗口（保证窗口有恰好 k 个数）</span></span><br><span class="line">        <span class="type">int</span> left = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; BIAS; ++j) &#123; <span class="comment">// 暴力枚举负数范围 [-50,-1]</span></span><br><span class="line">            left -= cnt[j];</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= <span class="number">0</span>) &#123; <span class="comment">// 找到美丽值</span></span><br><span class="line">                ans[i - k + <span class="number">1</span>] = j - BIAS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --cnt[nums[i - k + <span class="number">1</span>] + BIAS]; <span class="comment">// 离开窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2134-最少交换次数来组合所有的-1-II"><a href="#2134-最少交换次数来组合所有的-1-II" class="headerlink" title="2134. 最少交换次数来组合所有的 1 II"></a><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/">2134. 最少交换次数来组合所有的 1 II</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sum; i++) cnt += nums[i];</span><br><span class="line">    <span class="type">int</span> maxCnt = cnt;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sum; i &lt; n + sum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cnt += nums[i % n] - nums[(i - sum) % n];</span><br><span class="line">        maxCnt = <span class="built_in">max</span>(cnt, maxCnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - maxCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>滑动窗口的窗口长度“定”从哪里来？有些时候显性给出，有些时候根据元素特征想</li>
<li>环变链：<code>nums.insert(nums.end(),nums.begin(),nums.end());</code>  容器自身的接口是可行的。用算法中的 <code>copy(nums.begin(),nums.end(),back_inserter(nums));</code>会出现左脚踩右脚的情况，需要找个过渡容器操作。</li>
</ul>
<h4 id="LCR-016-无重复字符的最长子串"><a href="#LCR-016-无重复字符的最长子串" class="headerlink" title="LCR 016. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/wtcaE1/">LCR 016. 无重复字符的最长子串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, ans = <span class="number">0</span> ,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; !hash.<span class="built_in">count</span>(s[j]))</span><br><span class="line">        &#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = j - i;</span><br><span class="line">        ans = <span class="built_in">max</span>(cnt,ans);</span><br><span class="line">        <span class="keyword">while</span>(s[i] != s[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            hash.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        j ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双指针，指针中间的元素重复性用 hashmap 记录</li>
</ul>
<h2 id="不定长窗口"><a href="#不定长窗口" class="headerlink" title="不定长窗口"></a>不定长窗口</h2><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span>(; r &lt; s.<span class="built_in">size</span>(); r ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hash.<span class="built_in">count</span>(s[r])) hash.<span class="built_in">erase</span>(s[l++]);</span><br><span class="line">        hash.<span class="built_in">insert</span>(s[r]);;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3090-每个字符最多出现两次的最长子字符串"><a href="#3090-每个字符最多出现两次的最长子字符串" class="headerlink" title="3090. 每个字符最多出现两次的最长子字符串"></a><a href="https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/">3090. 每个字符最多出现两次的最长子字符串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumLengthSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, ans = <span class="number">0</span>, cnt[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); r ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[s[r]- <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="keyword">while</span>(cnt[s[r] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">2</span>) cnt[s[l ++] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>窗口长度不定的意思就是左边依据条件回缩</li>
</ul>
<h4 id="1493-删掉一个元素以后全为-1-的最长子数组"><a href="#1493-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="1493. 删掉一个元素以后全为 1 的最长子数组"></a><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">1493. 删掉一个元素以后全为 1 的最长子数组</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>, <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.<span class="built_in">size</span>();++r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[r]==<span class="number">0</span>) cnt++;</span><br><span class="line">        <span class="keyword">while</span>(cnt==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(nums[l++]==<span class="number">0</span>) --cnt;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,r-l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans; deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i - q.<span class="built_in">front</span>() &gt;= k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单调队列思想，单调队列中按升序还是降序，是根据保留的元素和两边元素相对大小关系</li>
</ul>
<h4 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">equalSubstring</span><span class="params">(string s, string t, <span class="type">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,cost=<span class="number">0</span>,left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cost += <span class="built_in">abs</span>(s[i]-t[i]);</span><br><span class="line">        <span class="keyword">while</span>(cost&gt;maxCost)&#123;</span><br><span class="line">            cost -= <span class="built_in">abs</span>(s[left]-t[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,i-left<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2730-找到最长的半重复子字符串"><a href="#2730-找到最长的半重复子字符串" class="headerlink" title="2730. 找到最长的半重复子字符串"></a><a href="https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/">2730. 找到最长的半重复子字符串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestSemiRepetitiveSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> max_len = <span class="number">1</span>; <span class="type">int</span> pt = <span class="number">0</span>; <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">1</span>; right &lt; s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[right] == s[right - <span class="number">1</span>]) &#123;</span><br><span class="line">        left = pt;</span><br><span class="line">        pt = right;</span><br><span class="line">    &#125;</span><br><span class="line">    max_len = <span class="built_in">max</span>(max_len, right - left + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于题目要求窗口内只含一对相邻相等字符，可以记录上次相等处的位置。</li>
<li>如果可以允许两对，不能超过三对，可以设置一个记录当前对数的 cnt，且只在cnt &#x3D; 3 的时候移动左窗口</li>
</ul>
<h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; fruits.<span class="built_in">size</span>(); r ++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash[fruits[r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(hash.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[fruits[l]] --;</span><br><span class="line">            <span class="keyword">if</span>(hash[fruits[l]] == <span class="number">0</span>) hash.<span class="built_in">erase</span>(fruits[l]);</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种果树本质就是保证窗口内的元素只有两种</li>
</ul>
<h4 id="1695-删除子数组的最大得分"><a href="#1695-删除子数组的最大得分" class="headerlink" title="1695. 删除子数组的最大得分"></a><a href="https://leetcode.cn/problems/maximum-erasure-value/">1695. 删除子数组的最大得分</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash; <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hash.<span class="built_in">count</span>(nums[r]))</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            hash.<span class="built_in">erase</span>(nums[l ++]);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[r];</span><br><span class="line">        hash.<span class="built_in">insert</span>(nums[r]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,sum);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断窗口元素的重复既然选择用 hash_map，就从这里面判断，一开始写了个 <code>while(nums[l] != nums[r])</code> 耽误半天事</li>
</ul>
<h4 id="2958-最多-K-个重复元素的最长子数组"><a href="#2958-最多-K-个重复元素的最长子数组" class="headerlink" title="2958. 最多 K 个重复元素的最长子数组"></a><a href="https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/">2958. 最多 K 个重复元素的最长子数组</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubarrayLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hash; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r ++)</span><br><span class="line">   &#123;</span><br><span class="line">        hash[nums[r]] ++;</span><br><span class="line">        <span class="keyword">while</span>(hash[nums[r]] &gt; k)</span><br><span class="line">            hash[nums[l ++]] --;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,r - l + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/">2779. 数组的最大美丽值</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[r] - nums[l] &gt; k * <span class="number">2</span>) l ++;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>记得子序列的概念</li>
</ul>
<p>连续定长子数组性质问题：滑动窗口</p>
<p>连续不定长子数组性质问题：前缀和</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招笔试真题记录</title>
    <url>/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录秋招过程中的笔试算法题目</p>
<span id="more"></span>

<h4 id="0905-小米"><a href="#0905-小米" class="headerlink" title="0905 小米"></a>0905 小米</h4><ol>
<li><p>做面包</p>
<p>小明每天早上需要AB两种面包各一个，同时已知小明有 n 个面包机，n 个面包机做 A B 两种面包的时间分别是 a<del>i</del> ，b<del>i</del> 。可以选择用同一台面包机先后制作 A 和 B，这样时间是累加的，也可以选择用不同的面包机并行制作 A B, 这样时间取两块面包制作时间的大者。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表拥有面包机的数量。接下来有两行，每行 n 个数，第一行 n 个数代表 n 台面包机制作 A 面包的时间，第二行 n 个数代表 n 台面包机制作 B 面包的时间。</p>
<p><strong>输出格式：</strong></p>
<p>输出一个数，代表最短制作用时</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">2 6 8</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
<li><p>序列操作</p>
<p>给出一个数字序列，你可以有两种操作，一种是把某个元素加 1，第二种是直接删除某元素，最终期望达到的效果是所有元素之和是 x 的倍数</p>
<p><strong>输入格式：</strong></p>
<p>首行两个数字 n , x。n 代表数组长度， x 为上文描述的意义。</p>
<p><strong>输出格式：</strong></p>
<p>输出最少操作次数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 5 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目前 还没有太成熟的解法，想法是直接根据数据总和，以及数据元素，推算用两种方式各自需要多少次</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x; cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;<span class="type">int</span> t; cin &gt;&gt; t; a.<span class="built_in">push_back</span>(t), sum += t;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum % x  == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (sum + <span class="number">1</span>) % x == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), sum % x);</span><br><span class="line">        <span class="keyword">if</span>(pos != a.<span class="built_in">end</span>() &amp;&amp; *pos == sum % x) </span><br><span class="line">            &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pos &gt; sum % x &amp;&amp; pos != a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s1 = </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个题目有点像动态规划，但是似乎常规方法也可以，暂时没有很好的解法</li>
</ul>
</li>
<li><p>总结：</p>
<ol>
<li>其实题目算是很基础了，但一是心态，而是技术，两方面都需要加强<ol>
<li>心态应该更淡定一些</li>
<li>技术就是要多练</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="0908-饿了吗"><a href="#0908-饿了吗" class="headerlink" title="0908 饿了吗"></a>0908 饿了吗</h4><ol>
<li><p>排队时间</p>
<p>给出一个表示任务执行时间的序列，判断是否可以通过交换其中两个任务的位置，使得总等待时间尽可能小，若存在输出两个位置，不存在就输出 -1</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表任务的数量。接下来是 n 个数字，表示各个任务的处理时间</p>
<p><strong>输出格式：</strong></p>
<p>若存在输出两个位置，不存在就输出 -1</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">12131</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>
</li>
<li><p>权益值最小化</p>
<p>对整型数 a, b 来说，你可以有两种操作，分别变换为（a - b, b)  或 （a, b -a), 我们称 abs(a-b) 为 这队数字的权益值，给出一组这样的整数对，<strong>在使得他们的权益值之和最小前提下</strong>，问最小的操作次数。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表整数对数量，接下来 n 行，每行是两个整型数， 代表一个数对</p>
<p><strong>输出格式：</strong></p>
<p>输出分两行，第一行是最小权益值之和，第二行是对应操作次数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">2 6 8</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
<li><p>都市圈</p>
<p>n 个城市按批次规划高铁，每次规划会给出规划时间，联通城市数，对应的联通城市；被联通的城市称之为都市圈，然后询问在某个时间点上某个城市圈的人数总数？如果规划时间和询问时间一致，那么按照先执行规划再询问处理</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表拥有面包机的数量。接下来有两行，每行 n 个数，第一行 n 个数代表 n 台面包机制作 A 面包的时间，第二行 n 个数代表 n 台面包机制作 B 面包的时间。</p>
<p><strong>输出格式：</strong></p>
<p>输出一个数，代表最短制作用时</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 4</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 2 1 3</span><br><span class="line">3 2 3 4</span><br><span class="line">5 2 2 5</span><br><span class="line">1 1</span><br><span class="line">5 5</span><br><span class="line">2 1</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
</ol>
<h4 id="0914-小红书"><a href="#0914-小红书" class="headerlink" title="0914 小红书"></a>0914 小红书</h4><ol>
<li><p>相似笔记（15分）</p>
<p>小红书笔记有点赞数，如果两篇笔记点赞数异或之后等于我们给定的 k 值，称两篇笔记相似。给你一个表示笔记点赞数的数组，判断这些笔记中有多少相似的。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, k。分别代表笔记数量，上文中的 k 值，接下来是 n 个数字，表示 n 篇笔记点赞数</p>
<p><strong>输出格式：</strong></p>
<p>相似笔记的对数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：1 ^ 4 &#x3D; 5, 所以相似数量为2，(1,4) 和 (1,4)</p>
<p>n 的范围 1 - 10^5	k 及 点赞数范围 1 - 10^9</p>
</blockquote>
<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>桌子最大摆放方式</p>
<p>小红书有一个阅览室长宽高分别为 x y z, 这个阅览室是无重力的，因此里面的桌子可以随意漂浮，给你一个体积为 V 的桌子，桌子的边长可以是任意整数，只要保证体积是 v ,让桌子各边平行于阅览室各轴，并且各个角都位于整数坐标。问桌子可能的最大可摆放的位置数量</p>
<p><strong>输入格式：</strong></p>
<p>首行T, 代表接下来的数据组数。每组数构成为 x y z v，四个数的意义与上面一致</p>
<p><strong>输出格式：</strong></p>
<p>每组情况下桌子的最大摆放方式</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 2 2</span><br><span class="line">1 2 3 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>完全没有思路！</p>
</li>
<li><p>树上距离</p>
<p>小红有一棵 n 个节点， n - 1条变构成的树，边的权重为 w<del>i</del>, 定义树的两个点(u,v)权值为，从 u 到 v 的简单路径上全部边的异或和，特别的当 u 和 v 是同一个点，权值为 0，小红会进行 q 次询问，询问有多少个点到 u 的路径和恰好为 k</p>
<p><strong>输入格式：</strong></p>
<p>首行 n,q,分别代表树的节点数和询问次数，此后 n -  1 行，每行三个整数 u v w，表示 u v 之间有边，权值为 w, 数据保证树联通，没有重边，此后 q 行，每行 u k, 分别表示询问的节点和限定</p>
<p><strong>输出格式：</strong></p>
<p>每个询问输出一个整数，代表到 u 节点距离为 k 的节点数量</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">1 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n q 范围 1 - 10^5,  u &lt;&#x3D; n, k 范围 0 - 2^60</p>
</blockquote>
<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
</ol>
<h4 id="0921-美团笔试"><a href="#0921-美团笔试" class="headerlink" title="0921 美团笔试"></a>0921 美团笔试</h4><ol>
<li><p>数组染色</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_10-34-49.png" alt="Snipaste_2024-09-21_10-34-49"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_10-34-55.png" alt="Snipaste_2024-09-21_10-34-55"></p>
<p>解答：</p>
<p>这道题通过枚举数组长度为 1 2 3 4 5 … 12 之后发现规律，n  为偶数则 f[n] &#x3D; f[n &#x2F; 2  + 1] + 1, n 为奇数则 f[n] &#x3D; f[(n + 1) &#x2F;  2] + 1;</p>
</li>
<li><p>美丽值最大化</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_11-08-00.png" alt="Snipaste_2024-09-21_11-08-00"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_11-08-05.png" alt="Snipaste_2024-09-21_11-08-05"></p>
</li>
<li><p>商家收购</p>
</li>
</ol>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_11-07-38.png" alt="Snipaste_2024-09-21_11-07-38"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_11-07-53.png" alt="Snipaste_2024-09-21_11-07-53"></p>
<p>解答：</p>
<h4 id="0921-米哈游"><a href="#0921-米哈游" class="headerlink" title="0921 米哈游"></a>0921 米哈游</h4><ul>
<li>射箭</li>
</ul>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_21-15-13.png" alt="Snipaste_2024-09-21_21-15-13"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_21-15-32.png" alt="Snipaste_2024-09-21_21-15-32"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_21-15-47.png" alt="Snipaste_2024-09-21_21-15-47"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-21_21-15-57.png" alt="Snipaste_2024-09-21_21-15-57"></p>
<h4 id="0924-帆软"><a href="#0924-帆软" class="headerlink" title="0924 帆软"></a>0924 帆软</h4><ol>
<li><p>凑数</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-24_11-43-34.png" alt="Snipaste_2024-09-24_11-43-34"></p>
</li>
<li><p>最长回文子序列</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-24_11-44-06.png" alt="Snipaste_2024-09-24_11-44-06"></p>
</li>
</ol>
<h4 id="0925-迅雷"><a href="#0925-迅雷" class="headerlink" title="0925 迅雷"></a>0925 迅雷</h4><ol>
<li><p>最长相同数字的长度</p>
<p>给出一个数组，数组长度为 1 - 10^5 ，里面的元素都是 -10 到 10，你有三次可以将元素修改成任意值的机会，问你可以得到的最长相同数字的长度是多少？</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 3 0 1 2 1</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>样例解释</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以改成 0 0 0 0 0 1</span><br><span class="line">或者 0 1 1 1 1 1</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串映射</p>
<p>给你两个字符串分别是 str1 str2，判断 str2 是否可由 str1 映射而来。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accdee deefhh</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ture</span><br></pre></td></tr></table></figure>

<p>解释：映射关系为：a-&gt;d c-&gt;e d-&gt;f e-&gt;h</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abbddc sffger</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="0926-理想笔试"><a href="#0926-理想笔试" class="headerlink" title="0926 理想笔试"></a>0926 理想笔试</h4><p>首道题统计字符串中字母个数大于 k 的字符，略</p>
<ol>
<li>合唱队形</li>
</ol>
<img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/Snipaste_2024-09-26_10-57-27.png" alt="Snipaste_2024-09-26_10-57-27" style="zoom:50%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 基本思路，身高最高的作为塔尖必选[错！]，最大数不一定非要入选，正确的思路是枚举每一个做塔尖，</span><br></pre></td></tr></table></figure>



<h4 id="0928-网易"><a href="#0928-网易" class="headerlink" title="0928 网易"></a>0928 网易</h4><ol>
<li><p>搜索引擎关键字去重</p>
</li>
<li><p>最小代价凑回文数字</p>
<p>问题描述：给一个数字x，加上尽可能小的y, 使得 x+y 是回文数，输出那个最小的 y</p>
<p>解法思路:</p>
<ul>
<li>把 x 位拆开放入数组，从尾部到中间分析使得对称需要的最小数字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x; cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;  num.<span class="built_in">push_back</span>(x % <span class="number">10</span>); x /= <span class="number">10</span>;&#125;</span><br><span class="line">    <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">before</span><span class="params">(num)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[n - <span class="number">1</span> - i]) num[i + <span class="number">1</span>] ++;</span><br><span class="line">        num[i] = num[n - <span class="number">1</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(before.<span class="built_in">begin</span>(),before.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> be = <span class="number">0</span>, af = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        be *= <span class="number">10</span>;</span><br><span class="line">        be += before[i];</span><br><span class="line">        af *= <span class="number">10</span>;</span><br><span class="line">        af += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; af - be;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合法数组最长前缀</p>
</li>
</ol>
<p>​	问题描述：</p>
<p>​	解法思路：</p>
<ol>
<li>安排合法考场</li>
</ol>
<h4 id="0928-滴滴"><a href="#0928-滴滴" class="headerlink" title="0928 滴滴"></a>0928 滴滴</h4><ol>
<li>压岁钱买玩具</li>
</ol>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20240928165558732.png" alt="image-20240928165558732"></p>
<p>1. </p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20240928165535382.png" alt="image-20240928165535382"></p>
<h4 id="1008-虾皮"><a href="#1008-虾皮" class="headerlink" title="1008 虾皮"></a>1008 虾皮</h4><ol>
<li><p>不递减子序列的个数</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span>	 <span class="comment">// 这个测评网站实在脑残，需要自己加头文件</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>() || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(arr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>经典的回溯方法，</li>
</ul>
</li>
<li><p>最小跳数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">int</span> l = <span class="number">0</span>; <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r,s[i] + i);</span><br><span class="line">            <span class="keyword">if</span>(i == l &amp;&amp; i != n - <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                ans ++;</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除链表倒数第 n 个元素</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNode</span><span class="params">(ListNode* node, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,node);</span><br><span class="line">        ListNode *l = dummy, *r = dummy;</span><br><span class="line">        <span class="keyword">while</span>(n --) r = r-&gt;next; <span class="comment">// 这里显然有毛病，就是 r 会空指针访问</span></span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">        <span class="keyword">while</span>(r-&gt;next) &#123;l = l-&gt;next; r = r-&gt;next;&#125;</span><br><span class="line">        l-&gt;next = l-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1009-英伟达"><a href="#1009-英伟达" class="headerlink" title="1009 英伟达"></a>1009 英伟达</h4><h4 id="1010-携程"><a href="#1010-携程" class="headerlink" title="1010 携程"></a>1010 携程</h4><ol>
<li><p>下划线命名改驼峰命名</p>
</li>
<li><p>素数</p>
</li>
<li><p>gcd 之和最大化</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241010122649885.png"></p>
</li>
<li><p>区间与或</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241010122658139.png" alt="image-20241010122658139"></p>
</li>
</ol>
<h4 id="1012-金山"><a href="#1012-金山" class="headerlink" title="1012 金山"></a>1012 金山</h4><ol>
<li><p>杀死木头人</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241012210832513.png" alt="image-20241012210832513"></p>
</li>
<li><p>回文串</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241012210838804.png" alt="image-20241012210838804"></p>
</li>
</ol>
<h4 id="1013-拼多多"><a href="#1013-拼多多" class="headerlink" title="1013 拼多多"></a>1013 拼多多</h4><ol>
<li><p>数组乘积末尾的0的个数</p>
</li>
<li><p>报文破解</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241013170821671.png" alt="image-20241013170821671"></p>
</li>
<li><p>划分子串</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241013170830985.png" alt="image-20241013170830985"></p>
</li>
<li><p>旅游最大快乐值</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241013170838289.png" alt="image-20241013170838289"></p>
</li>
<li><p>围绕简历自我介绍5min</p>
</li>
<li><p>拷问</p>
<ul>
<li>多路复用IO</li>
<li>c++ const static 关键字特性</li>
<li>智能指针</li>
<li>虚函数机制</li>
<li>面向对象三大特性</li>
</ul>
</li>
<li><p>智力题</p>
<ul>
<li>100层楼，两个球</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>深拷贝随机链表</li>
</ul>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241020154436200.png" alt="image-20241020154436200"></p>
</li>
</ol>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241020154452738.png" alt="image-20241020154452738"></p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/image-20241020154508058.png" alt="image-20241020154508058"></p>
<h4 id="1118-微软"><a href="#1118-微软" class="headerlink" title="1118 微软"></a>1118 微软</h4><ol>
<li><p>字母排列</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/cstbjephmfra1ntq1nj0.png" alt="img"></p>
</li>
<li><p>d</p>
<p><img src="/2024/09/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/cstcihofi7c596s7fe00.png" alt="img">****</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>面试野题收集</title>
    <url>/2024/09/01/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%87%8E%E9%A2%98%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>面试题搜集</p>
<span id="more"></span>
<h2 id="面试题刷题："><a href="#面试题刷题：" class="headerlink" title="面试题刷题："></a>面试题刷题：</h2><h4 id="字母和数字"><a href="#字母和数字" class="headerlink" title="字母和数字"></a>字母和数字</h4><p><a href="https://leetcode.cn/problems/find-longest-subarray-lcci/description/">https://leetcode.cn/problems/find-longest-subarray-lcci/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findLongestSubarray</span><span class="params">(vector&lt;string&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = array.<span class="built_in">size</span>(), s[n + <span class="number">1</span>]; s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + (array[i][<span class="number">0</span>] &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = first.<span class="built_in">find</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == first.<span class="built_in">end</span>()) first[s[i]] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - it-&gt;second &gt; r - l)</span><br><span class="line">                l = it-&gt;second, r = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;array.<span class="built_in">begin</span>() + l, array.<span class="built_in">begin</span>() + r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀和+哈希表</li>
<li>前缀和方便处理一段的性质</li>
<li>哈希表方便查找存在性问题</li>
<li>字母和数字的区分用 <code>array[i][0] &gt;&gt; 6 &amp; 1</code></li>
</ul>
<h4 id="和为-k-的数组"><a href="#和为-k-的数组" class="headerlink" title="和为 k 的数组"></a>和为 k 的数组</h4><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sj : s) &#123;</span><br><span class="line">            <span class="comment">// 注意不要直接 += cnt[sj-k]，如果 sj-k 不存在，会插入 sj-k</span></span><br><span class="line">            ans += cnt.<span class="built_in">contains</span>(sj - k) ? cnt[sj - k] : <span class="number">0</span>;</span><br><span class="line">            cnt[sj]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>cnt 哈希表用来记录前缀和为 first 的点的个数 second</li>
<li>ans +&#x3D; cnt[sj - k] 一开始担心会加到位置靠后的前缀和为 sj - k 的点，但是 for (int sj : s) 这样的遍历顺序决定了只会加到前面的点</li>
<li>contains 是 C++ 20 才引入的接口，返回 true &#x2F; false, 同样功能的接口是 count 和 find</li>
</ul>
<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/09/08/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集使用</p>
<span id="more"></span>
<h4 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h4><p>主要解决问题：</p>
<ul>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ul>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点</p>
<ul>
<li>问题1：如何判断树根：if(px] &#x3D;&#x3D; x)</li>
<li>问题2：如何求x的集合编号：while(px]!&#x3D;x)x&#x3D;p[x]:</li>
<li>问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号。p[x]&#x3D;y</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 返回祖先 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机开机过程</title>
    <url>/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>本篇文章描述计算机启动过程</p>
<span id="more"></span>

<h2 id="BIOS-和-UEFI"><a href="#BIOS-和-UEFI" class="headerlink" title="BIOS 和 UEFI"></a>BIOS 和 UEFI</h2><p>总体来说，二者都是负责在操作系统加载之前<strong>初始化硬件</strong>，并为操作系统的启动提供必要的环境。但是二者实现的优雅程度，安全性不太一样。</p>
<p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009144752175.png" alt="image-20241009144752175"></p>
<h3 id="BIOS-启动流程"><a href="#BIOS-启动流程" class="headerlink" title="BIOS 启动流程"></a>BIOS 启动流程</h3><h4 id="BIOS-加载-MBR-中的-GRUB"><a href="#BIOS-加载-MBR-中的-GRUB" class="headerlink" title="BIOS 加载 MBR 中的 GRUB"></a>BIOS 加载 MBR 中的 GRUB</h4><ul>
<li><p>x86芯片中，CPU被硬件设置为一加电就从一个硬编码的内存位置（0xFFFFFFF0）开始执行代码。这个内存位置由主板的BIOS代码ROM提供支持。</p>
</li>
<li><p>BIOS 程序的主要功能包括：</p>
<ol>
<li><strong>加电自检（POST）</strong>：当计算机通电启动时，BIOS执行加电自检，检查硬件组件（如CPU、内存、硬盘、显卡等）是否正常工作。</li>
<li><strong>硬件初始化</strong>：BIOS初始化系统硬件，包括设置硬件参数、配置中断和DMA通道、初始化即插即用设备等。</li>
<li><strong>配置设置</strong>：BIOS存储着系统配置信息，如日期、时间、启动顺序等。用户可以通过特定的菜单（通常是在启动时按特定键进入）来修改这些设置。</li>
<li><strong>中断向量表</strong>：BIOS 在内存0X00~0X3FF处建立中断向量表，这是操作系统和硬件之间进行通信的重要机制。</li>
<li><strong>引导顺序</strong>：BIOS根据用户设定的引导顺序或默认设置，确定从哪个设备（如硬盘、光驱、USB设备等）加载操作系统。</li>
<li><strong>引导装载程序</strong>：BIOS加载并执行引导扇区（通常是硬盘上的MBR或GPT上的EFI分区）中的代码，将操作系统的引导程序加载到内存中。此处是BIOS遍历各个硬盘的第一扇区，找到最后两个字节为 0x55AA 的硬盘作为 MBR 分区。</li>
<li><strong>错误处理</strong>：如果检测到硬件故障或配置问题，BIOS会提供错误信息，如“磁盘引导失败”、“内存检测错误”等。</li>
<li><strong>系统服务</strong>：BIOS提供一些基本的系统服务，如键盘输入、屏幕输出、磁盘读写等，这些服务在操作系统完全加载之前是必需的。</li>
<li><strong>即插即用支持</strong>：BIOS支持即插即用（Plug and Play），可以自动识别和配置新添加的硬件设备。</li>
<li><strong>固件更新</strong>：BIOS允许用户通过特定的程序更新固件，以获得新功能或修复已知问题。</li>
</ol>
</li>
<li><p>找到MBR程序之后，BIOS便将其加载到物理地址 0x7c00 处，然后条状到 0X7c00 处，至此，BIOS完成了它全部的任务，将控制权交给MBR继续运行，MBR 是什么？</p>
<p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009145905457.png" alt="image-20241009145905457"></p>
<p>MBR处于硬盘的第一个扇区，共 512 字节，最后两个字节为 0x55AA。MBR 内部结构为：</p>
<p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009152742348.png" alt="image-20241009152742348"></p>
<p>MBR总共 512 字节，使用可谓精打细算，引导程序 446 字节，然后是四个分区表 16 * 4 &#x3D; 64 字节，最后是结束标志 55AA 两字节。</p>
<p>MBR 中的启动引导程序的功能是什么？</p>
<p>启动引导程序只有 446 字节，不足以加载现代操作系统，因此，启动引导程序的作用是加载操作系统的 boot loader</p>
<p>一个更直观的 MBR 分区是这样的：</p>
<p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009155409746.png" alt="image-20241009155409746"></p>
<p>其所划分的硬盘结构是这样的：</p>
<p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009155446723.png" alt="image-20241009155446723"></p>
</li>
</ul>
<h4 id="GRUB-加载-bootloader"><a href="#GRUB-加载-bootloader" class="headerlink" title="GRUB 加载 bootloader"></a>GRUB 加载 bootloader</h4><ul>
<li>由 BIOS 查找到合格的 MBR 后，将 MBR 中的 GRUB 加载到内存，GRUB 负责从四个分区中确定活动分区，并加载对应分区的 Boot Sector 中的操作系统引导程序 bootloader</li>
</ul>
<blockquote>
<p>如何确定活动分区？</p>
</blockquote>
<h4 id="bootloader-加载操作系统"><a href="#bootloader-加载操作系统" class="headerlink" title="bootloader 加载操作系统"></a>bootloader 加载操作系统</h4><h2 id="日后讨论："><a href="#日后讨论：" class="headerlink" title="日后讨论："></a>日后讨论：</h2><h3 id="MBR-和-GPT"><a href="#MBR-和-GPT" class="headerlink" title="MBR 和 GPT"></a>MBR 和 GPT</h3><p><img src="/2024/10/09/linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20241009150613214.png" alt="image-20241009150613214"></p>
<h3 id="为什么-BIOS-将MBR-加载到-0x7c00"><a href="#为什么-BIOS-将MBR-加载到-0x7c00" class="headerlink" title="为什么 BIOS 将MBR 加载到 0x7c00"></a>为什么 BIOS 将MBR 加载到 0x7c00</h3><p>其实是历史遗留问题，早期电脑 32k 内存，BIOS 设置完中断向量表之后剩余内存的最后 1k, 这个地址就是 31k</p>
<p>参考文章：<br><a href="https://c.biancheng.net/view/1015.html">主引导目录（MBR）结构及作用详解</a></p>
<p><a href="https://knowitlikepro.com/understanding-master-boot-record-mbr/">Understanding Master Boot Record (MBR)</a></p>
<p><a href="https://akaha.blog.csdn.net/article/details/105481086">操作系统的启动都干了些什么</a></p>
<p><a href="https://blog.csdn.net/xiaofeng_yang/article/details/138659090">轻松学Linux文件系统（Ext2&#x2F;Ext3&#x2F;Ext4）</a></p>
<p><a href="https://knowitlikepro.com/understanding-boot-sector/">Understanding Master Boot Sector (MBS)</a></p>
<p><a href="https://www.icviews.cn/semiCommunity/postDetail/6427">一文让你搞懂UEFI</a></p>
]]></content>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/04/09/%E6%A0%A1%E6%8B%9B%E6%B1%82%E8%81%8C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式整理</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>acwing常用代码模板整理</title>
    <url>/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>acwing 代码模板</p>
<span id="more"></span>

<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="快排：例题"><a href="#快排：例题" class="headerlink" title="快排：例题"></a>快排：<a href="https://www.acwing.com/problem/content/787/">例题</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>], i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i] &lt; x) i++;</span><br><span class="line">        <span class="keyword">while</span>(a[j] &gt; x) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) <span class="built_in">swap</span>(a[i++], a[j--]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(a, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, i, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边界情况说明：<a href="https://www.acwing.com/solution/content/16777/">https://www.acwing.com/solution/content/16777/</a></p>
<ul>
<li>属于分治：1）划分 2）递归处理子问题 3）合并问题</li>
</ul>
<h3 id="归并：例题"><a href="#归并：例题" class="headerlink" title="归并：例题"></a>归并：<a href="https://www.acwing.com/problem/content/789/">例题</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>十大排序算法总结：<a href="https://www.acwing.com/solution/content/24716/">https://www.acwing.com/solution/content/24716/</a></li>
</ul>
<h3 id="二分"><a href="#二分" class="headerlink" title="*二分"></a>*二分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowerbound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upperbound</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于重复元素搜索中的 lower_bound 和 upper_bound 问题：<ul>
<li>首先被考虑出来的是 c[mid] 刚好命中时候，区间应该是选左还是选右：对于 lower_bound ,选左 r &#x3D; mid ; 同理upper_bound 选右 l &#x3D; mid; </li>
<li>然后推理出完整的 check 条件</li>
<li>然后根据区间划分是否会死循环决定 mid 的取值是上取整还是下取整</li>
<li>两种情况下返回值为 l 或 r 都可以</li>
</ul>
</li>
</ul>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A); <span class="comment">// 保证 A 比较长</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];	<span class="comment">// A 比较长，无条件加</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C; <span class="comment">// C 是倒序的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">// 借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;	<span class="comment">// 不借</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 首位在末尾，可能会减为 0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 怎么会多压入 0 呢</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>] <span class="comment">// 注意是 l - 1</span></span><br><span class="line"><span class="comment">// 二维</span></span><br><span class="line"><span class="comment">// 1. 构造前缀和矩阵</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j]</span><br><span class="line"><span class="comment">// 2. 查询计算</span></span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>] <span class="comment">// 这里的 -1 都是在 x1 y1 基础上</span></span><br></pre></td></tr></table></figure>
<p>二维辅助理解图：</p>
<p><img src="/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/image-20241010161955975.png" alt="image-20241010161955975"></p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维</span></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line"><span class="comment">// 二维</span></span><br><span class="line"><span class="comment">// 1.差分数组的构造：</span></span><br><span class="line">a[i][j] = s[i][j] - s[i<span class="number">-1</span>][j] - s[i][j<span class="number">-1</span>] + s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">或 <span class="built_in">insert</span>(i,j,i,j,s[i][j]); <span class="comment">// 有点类似于并查集初始化</span></span><br><span class="line"><span class="comment">// 2. insert 操作</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c <span class="comment">// 思路转换到 笛卡尔坐标系更容易理解</span></span><br></pre></td></tr></table></figure>
<p>辅助理解图：</p>
<p><img src="/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/image-20241010165607087.png" alt="image-20241010165607087"></p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助理解</p>
<p><img src="/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/image-20241010175413261.png" alt="image-20241010175413261"></p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>辅助理解</p>
<p><img src="/2024/09/06/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/image-20241010175435457.png" alt="image-20241010175435457"></p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="*并查集"></a>*并查集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line">    <span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>
<h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="STL简介"><a href="#STL简介" class="headerlink" title="*STL简介"></a>*STL简介</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>
<h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><blockquote>
<p>算法可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
</blockquote>
<h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">树是一种特殊的图，与图的存储方式相同。</span><br><span class="line">对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</span><br><span class="line">因此我们可以只考虑有向图的存储。</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 邻接矩阵：g[a][b] 存储边a-&gt;<span class="built_in">b</span></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 邻接表：</span><br><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>
<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n+m) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n+m) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n^2 + m) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(mlogn) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(nm) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa-算法（队列优化的Bellman-Ford算法）"><a href="#spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法）"></a>spfa 算法（队列优化的Bellman-Ford算法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数</span></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素版prim算法"><a href="#朴素版prim算法" class="headerlink" title="朴素版prim算法"></a>朴素版prim算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(mlogm) n 表示点数，m 表示边数</span></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素筛法求素数"><a href="#朴素筛法求素数" class="headerlink" title="朴素筛法求素数"></a>朴素筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nt primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">https:<span class="comment">//www.acwing.com/solution/content/7950/</span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/100051075</span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/105467597</span></span><br></pre></td></tr></table></figure>
<h3 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约数个数和约数之和-数论"><a href="#约数个数和约数之和-数论" class="headerlink" title="约数个数和约数之和 (数论)"></a>约数个数和约数之和 (数论)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure>
<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; __gcd(a,b) &lt;&lt; endl;<span class="comment">//调用STL函数备用</span></span><br></pre></td></tr></table></figure>
<h3 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure>


<p>参考文章：</p>
<p><a href="https://www.acwing.com/blog/content/277/">常用代码模板1——基础算法</a></p>
<p><a href="https://www.acwing.com/blog/content/404/">常用代码模板2——数据结构</a></p>
<p><a href="https://www.acwing.com/blog/content/405/">常用代码模板3——搜索与图论</a></p>
<p><a href="https://www.acwing.com/blog/content/406/">常用代码模板4——数学知识</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络io</title>
    <url>/2024/10/13/linux/linux%E7%BD%91%E7%BB%9Cio/</url>
    <content><![CDATA[<p>linux 网络 io</p>
<span id="more"></span>

<p>参考文章：</p>
<p><a href="https://blog.csdn.net/historyasamirror/article/details/5778378">同步，异步，阻塞，非阻塞</a></p>
<p><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li>阻塞产生的原因是程序等待资源</li>
<li>阻塞是由系统自动执行阻塞原语(Block)的主动行为</li>
</ul>
<blockquote>
<p>阻塞机制中操作系统内核做了什么？</p>
</blockquote>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul>
<li>尽管程序等待某种资源，但这种资源并非是接下来运行的必要条件</li>
<li>程序得以在等待资源同时继续运行</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>进程间行为有明显的先后顺序，前者没执行完后者只能阻塞</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul>
<li>进程间行为有先后顺序，但不是前者的执行结果不是后者的必要条件</li>
<li>后者得以在前者执行过程中继续执行。</li>
</ul>
<blockquote>
<p>总结：阻塞非阻塞描述的是一个程序的 io 方式，而同步异步是程序间信息传递机制。</p>
</blockquote>
<p>另一种说法：</p>
<ul>
<li>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回.但是一旦调用返回，就得到返回值了；换句话说，就是由调用者主动等待这个调用的结果：</li>
<li>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果：换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果：而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用</li>
</ul>
<h3 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h3><ul>
<li><p>在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p><img src="/2024/10/13/linux/linux%E7%BD%91%E7%BB%9Cio/image-20241013130230393.png" alt="image-20241013130230393"></p>
</li>
<li><p>也就是说IO操作其实分为了<strong>两个阶段</strong></p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
</li>
</ul>
<h2 id="linux-网络-IO"><a href="#linux-网络-IO" class="headerlink" title="linux 网络 IO"></a>linux 网络 IO</h2><h3 id="五种模型"><a href="#五种模型" class="headerlink" title="五种模型"></a>五种模型</h3><ol>
<li>阻塞 I&#x2F;O（blocking IO）</li>
<li>非阻塞 I&#x2F;O（nonblocking IO）</li>
<li>I&#x2F;O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I&#x2F;O（ signal driven IO）</li>
<li>异步 I&#x2F;O（asynchronous IO）</li>
</ol>
<blockquote>
<p>signal driven IO在实际中并不常用，只讨论剩下的四种IO Model。</p>
</blockquote>
<h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="/2024/10/13/linux/linux%E7%BD%91%E7%BB%9Cio/image-20241013131247401.png" alt="image-20241013131247401"></p>
<p>总结：</p>
<ul>
<li>阻塞IO就是在 <strong>准备数据</strong> 和 <strong>复制数据</strong> 两个过程应用层程序都被 block</li>
<li>非阻塞IO就是在 <strong>准备数据</strong> 不被block, 但是 <strong>复制数据</strong> 过程被 block</li>
<li>IO 多路复用也是在 <strong>准备数据</strong> 和 <strong>复制数据</strong> 两个过程应用层程序都被 block，但是不同的是一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</li>
<li>异步 IO 两个过程都不会阻塞，问题是何时停下来进行读写呢？ 其实是异步 IO 机制本身实现了往应用程序空间复制数据，因而引用程序不用管，只需要等着“数据已到位”的信号。</li>
</ul>
<p><img src="/2024/10/13/linux/linux%E7%BD%91%E7%BB%9Cio/image-20241013131416339.png" alt="image-20241013131416339"></p>
<h3 id="I-O-多路复用详解"><a href="#I-O-多路复用详解" class="headerlink" title="I&#x2F;O 多路复用详解"></a>I&#x2F;O 多路复用详解</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>I&#x2F;O多路复用就是通过一种机制，<strong>一个进程可以监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，poll，epoll都是IO多路复用的机制。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds 三个位图描述监控对象，timeout 为监控超时时间。</li>
<li>返回值：调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时时，select函数返回。此时应用程序通过遍历fdset，来找到就绪的描述符。</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：pollfd结构包含了要监视的event和发生的event。</li>
<li>返回值：遇到有描述符就绪，poll返回。然后应用程序轮询pollfd来获取就绪的描述符。</li>
</ul>
<blockquote>
<p>select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。然而同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中</li>
</ul>
]]></content>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>专注力</title>
    <url>/2024/11/19/%E6%9D%82%E9%A1%B9/%E4%B8%93%E6%B3%A8%E5%8A%9B/</url>
    <content><![CDATA[<p>专注力</p>
<!-- -->

<ul>
<li><p>如何提高孩子的专注力? - 米典的回答 - 知乎<br><a href="https://www.zhihu.com/question/25547062/answer/1326148777">https://www.zhihu.com/question/25547062/answer/1326148777</a></p>
<p>从顶层理解，提高专注力的最重要的理解是：<strong>让自己拿出全力以赴的状态去做事情，拿出下决心要做成的态度去做。</strong></p>
</li>
<li><p>如何提高孩子的专注力? - Jennie真真的回答 - 知乎<br><a href="https://www.zhihu.com/question/25547062/answer/2274445488">https://www.zhihu.com/question/25547062/answer/2274445488</a></p>
<p>实际操作中可<strong>以使用策略性运动训练专注力</strong>：羽毛球，网球，篮球，跑酷</p>
</li>
<li><p>一些可能会有帮助的思维练习：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTIxOTk3Ng==&mid=401583322&idx=1&sn=806e7f4ea94c846dd8a973fed4a9136c#rd">https://mp.weixin.qq.com/s?__biz=MzIwMTIxOTk3Ng==&amp;mid=401583322&amp;idx=1&amp;sn=806e7f4ea94c846dd8a973fed4a9136c#rd</a></p>
</li>
<li><p>总的来说，专注力不是靠练习能练出来的，更多的是一种习惯，需要保护自己的专注力（远离各种短视频），也需要做事情能够静下心来，做一事成一事。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>梅琳达盖茨在斯坦福2024毕业典礼上的演讲</title>
    <url>/2024/11/29/%E6%9D%82%E9%A1%B9/%E6%A2%85%E7%90%B3%E8%BE%BE%E7%9B%96%E8%8C%A8%E5%9C%A8%E6%96%AF%E5%9D%A6%E7%A6%8F2024%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E4%B8%8A%E7%9A%84%E6%BC%94%E8%AE%B2/</url>
    <content><![CDATA[<p>梅琳达·盖茨在斯坦福毕业典礼上的演讲</p>
<!-- -->

<p>前几天梅琳达·盖茨在斯坦福毕业典礼上的演讲，挺不错的。</p>
<p>她用了一个充满哲理的故事贯穿其中：</p>
<p>海洋中有两朵浪花，一大一小，正朝着岸边涌去。眼看离岸越来越近，大浪忽然意识到了即将发生的事。它看到前方的浪花一个接一个拍打在岸边，瞬间消失不见。</p>
<p>大浪顿时慌了神，对小浪喊道：”完了完了，我们就要到头了！”</p>
<p>小浪却笑眯眯地说：”别担心，我们不会有事的。”</p>
<p>大浪急了：”你不明白啊！我们马上就要消失了！”</p>
<p>小浪依然淡定自若，说道：”不会的。我用六个字就能告诉你为什么。”</p>
<p>“什么意思？”大浪疑惑地问。</p>
<p>小浪答道：”汝非浪乃水也。”</p>
<p>这个故事形象地描绘了如何在经历巨大的转变时，依旧保持自我本心。</p>
<p>她给斯坦福的毕业生们给了三条人生建议：</p>
<ol>
<li>以全然开放的心态面对人生的重要转变</li>
</ol>
<p>当我们从学校毕业，难免会被各种标签束缚自己，名校毕业会觉得应该去改变世界，普通人会觉得这些离自己太远，其实我们不过就像故事里的大浪、小浪，都不过是水罢了。</p>
<ol>
<li>找到你的“小浪”</li>
</ol>
<p>在那个关于浪花的故事里，小浪才是英雄，因为它帮助大浪用另一种方式看待事物。实际上，那个小浪并不小。它有着独到的见解，有一种大浪自己所没有的洞察。毕业生们，无论你是谁，无论你处于人生的哪个阶段，拥有“小浪”是极其宝贵的。在你人生的不同时期，不同的人会扮演这个角色。</p>
<ol>
<li>建立一个值得信任的关系网</li>
</ol>
<p>生命中，有幸能遇到“小浪”那样的贵人，睿智、看透生活的本质，适当的时候给我们建议，同样我们自己也可以当“小浪”那样的人，给别人建议和帮助。就像梅琳达讲她自己在她的好朋友去世时，帮助她的好朋友 Emmy 度过悲伤，三年前她和比尔盖茨离婚的时候，正是 Emmy 陪在她身边，帮她度过难关。</p>
<p>希望你们能以彻底开放的心态迈向未来，被那些与你同行的更小、更睿智的浪花的智慧和洞察所鼓舞，致力于拓展你们已经开始在周围编织的信任网络。</p>
<p>完整的演讲文稿：</p>
<p>感谢你，Saller 校长，同时向 2024 届的同学们道早安。（观众鼓掌）很荣幸能在这样一个欢乐的时刻和你们及你们的家人在一起。今天，你们即将从斯坦福大学毕业，这是一项了不起的成就。</p>
<p>斯坦福在我家心中总是有着特殊的意义。我爸爸，Ray French，于 1960 年得到奖学金在这里学习机械工程，他在攻读硕士学位时，我妈妈，Elaine French，靠在一家瓶装水公司的工作来支持他们。并且，在晚上和周末，她是我爸爸的实验室助理。我一直珍藏着一张老照片，照片上妈妈怀着我姐姐，她站在工程实验室的风洞旁边，手里拿着剪贴板和秒表。今天，我爸爸和妈妈又回到了这个校园，这次是为了一个非常特别的场合——看着他们的孙女，Phoebe，从改变了我爸爸生活的大学毕业。（观众鼓掌）</p>
<p>而 Phoebe 不是唯一一个跟随他足迹的人。我的大女儿，Jenn，和我的女婿，Nayel，也在这里拿到了学位。祝你父亲节快乐，爸爸，还有在场的所有爸爸们，也感谢妈妈，使这个故事成为可能。（观众鼓掌）</p>
<p>我知道在座的父母非常多，祖父母和亲人也在这里，他们和我及我的家人一样，都为能在这儿感到自豪。毕业生们，你们给了我们很多值得庆祝的事情，也给了我们很多值得钦佩的事情。你们来到这个校园时就已经是才华横溢、雄心勃勃的年轻人了。在校期间，你们还证明了自己能适应环境，以及你们是多么有力的倡导者，为你们信仰的事业而奋斗。</p>
<p>斯坦福是一所要求严格的大学，而你们在这里的时光因周围世界发生的事情变得更具挑战性。从百年一遇的疫情改变了你们的生活和学习方式，到我知道这个校园深深感受到的多场战争。毋庸置疑，你们毕业时的世界与你们入学时的世界完全不同，但你们离开这个校园时，也已经准备好成为我们所需要的领导者，今天标志着你们旅程中的一个重要里程碑。</p>
<p>我坐下后不久，你们会被邀请起立，如果你们能的话。你们将以斯坦福学生的身份听到这个召唤，而以斯坦福毕业生的身份回应这个召唤。随之，你们人生的一个重大转变将开始。最近，我一直在思考人生的转变这个话题。这让我想起心灵导师拉姆·达斯曾经讲过一个发人深省的故事。</p>
<p>海洋中有两朵浪花，一大一小，正朝着岸边涌去。眼看离岸越来越近，大浪忽然意识到了即将发生的事。它看到前方的浪花一个接一个拍打在岸边，瞬间消失不见。大浪顿时慌了神，对小浪喊道：”完了完了，我们就要到头了！” 小浪却笑眯眯地说：”别担心，我们不会有事的。” 大浪急了：”你不明白啊！我们马上就要消失了！” 小浪依然淡定自若，说道：”不会的。我用六个字就能告诉你为什么。” “汝非浪乃水也”（你不仅是浪花，还是水）</p>
<p>我很喜欢这个故事。它形象地描绘了如何在经历巨大的转变时，依旧保持自我本质的状态。我今年 60 岁了，你不可能到这个年纪还没有经历过各种生活的转变。有些变化你主动接受，有些变化你从未预期。有些变化你期待着，有些变化你尽全力抵抗。对我来说，这些变化包括在微软开始我的职业生涯，一个我最亲密的朋友去世，恋爱，成家，开始我为女性和女孩们的工作，以及结束了近 30 年的婚姻和伙伴关系。最近，我做出了重大的职业更迭。每一次转变，都有那么一刻，我会感受到像巨浪般的恐惧，害怕我所熟悉的生活即将改变，但我总是能挺过去，你也一样会的。我明白，真正的挑战从第二天开始，因为我们在第二天做的决定，塑造了我们的自我。所以，除了赞扬你今天的所有成就，我也想给你一些思考，等你明天醒来的时候。</p>
<p>我从自己的经历中学到的三个教训。第一条建议是，以全然开放的心态面对这些转变。大多数时候，我们都是在日常生活的琐事中度过，但在转变的时候，我们会离开熟悉的环境，走进一个全新、开放的空间。面对这些空间，我们有两种方式。你可以向下看，寻找从一个熟悉的事物到另一个的最快路径，或者你也可以鼓起勇气，在这个临界空间停留，看看它有什么可以告诉你的。这就是我理解的开放心态。</p>
<p>我必须承认，年轻的我，总是采取第一种方式去应对变化。我有一份想要达成的目标清单，每完成一个，我就赶紧投入到下一个目标中，因为坦白说，这样会让我感到更少的恐惧。但随着年龄的增长，我学会了欣然接受不确定性的代价。我来举个例子，阐述这在我的生活中是如何体现的。当我 25 年前踏入慈善领域时，这对我来说是一个完全陌生的领域。我在全球健康或开发方面没有任何经验，我知道我还有很多东西需要学习，所以我清楚我需要时刻保持关注。</p>
<p>起初，我们认为基金会的工作主要会集中在疫苗接种上，但当我开始环游世界，亲眼看到项目的执行情况时，我遇到的女性们总是把话题转向别处。“我过去打过的那些针怎么样了？”她们会问我。他们实际上在谈论避孕药。于是，我停下来，倾听她们的诉说。很快，我在几乎所有的旅程中都开始讨论避孕问题，并在回到家后，继续和我的团队进行这些话题的讨论。这些对话带来了更多的讨论。我了解到，当女性可以自主决策，拥有自己的资源，以及规划自己的未来时，社会将会收获巨大的好处。（观众热烈掌声）</p>
<p>于是，我开始将精力集中在那里。现在回望那些早期的旅行，我满怀感激，因为那些与我相遇的女性引领我走上了新的道路，帮助我找到了生活的目标。</p>
<p>我想，作为斯坦福的学生，你们大多数人今天毕业时都怀揣着宏伟的计划：继续深造、推动事业、创办公司、颠覆行业。这些雄心壮志固然可贵，世界也需要你们，但我的建议是：给这些计划留些改变的余地。不要认为你在斯坦福所做的一切已经把你锁定在某一条路上，或某种职业上。要对这样一个事实保持兴奋：你将遇到许多你甚至无法想象的可能性。要愿意让你所学到的东西改变你对自己在这个世界上的使命的看法。请记住，一旦浪花学会用另一个名字称呼自己，一旦它意识到自己不仅仅是浪花，而是水本身，它就获得了自由，可以呈现新的形态。对你们来说也是如此。</p>
<p>这就引出了我的第二个建议，很简短：找到你的小浪。在那个关于浪花的故事里，小浪才是英雄，因为它帮助大浪用另一种方式看待事物。实际上，那个小浪并不小。它有着独到的见解，有一种大浪自己所没有的洞察。毕业生们，无论你是谁，无论你处于人生的哪个阶段，拥有“小浪”是极其宝贵的。在你人生的不同时期，不同的人会扮演这个角色。</p>
<p>在我职业生涯的初期，扮演这个角色的是我的一位同事，名叫 Charlotte。我加入微软的时候，我非常热爱所做的工作，但随着时间的推移，我发现我并不喜欢那里的文化。那里的氛围咄咄逼人、充满攻击性，这与我的性格不符。我是我们那届 MBA 班毕业招聘中唯一的女性，我感到很大压力，要模仿周围的男性。最终，我到了一个想要离开公司的地步。就像故事中的大浪一样，我以为我的事业已经走到了尽头，但 Charlotte 帮我用不同的角度看待这一切。她比我年长一些，经验更为丰富，她已经找到了如何在不失去自我的情况下适应那里的文化。有了 Charlotte 在我身边，我才能想象自己在微软的未来。</p>
<p>所以，毕业生们，我向你们保证，今天在这个体育馆里，一定有人会成为你们的“小浪”，帮助你们塑造并实现自己的理想形象。同样重要的是，这里有人需要你为他们担任这个角色。</p>
<p>这就引出了我今天的最后一条建议。建立一个值得信任的关系网。这个美妙的短语来自传奇商人查理·芒格，他改变了这个校园的面貌，在他的慷慨捐赠下建造了漂亮的学生宿舍。查理曾说过一句名言：文明能达到的最高形式是一个无缝的、值得信赖的关系网，人们完全可靠，彼此正确地信任着对方，一个值得信赖的关系网。这是我们应该追求的目标。作为一个社会，我们并不总是为身边的人负责，或者在分歧或辩论另一边的人负责，尤其是在当下。但我们彼此需要。无论你是谁，在你的人生旅程中都会有需要被他人扶持的时刻，也会有他人需要你扶持的时候。</p>
<p>当我好朋友 John 在 37 岁时去世，我是试图帮助他的妻子 Emmy 度过悲伤的小组成员之一。三年前，当我的婚姻结束时，她是那些帮我度过难关的人之一。我们之间的这种联系非常深厚，但当然，查理谈论的远不止于此。他说的是一个整个社会都建立在这种关系之上，一种强大而互惠的纽带，但要乘以数百万、数十亿倍。</p>
<p>在你们呆在校园的这段时间里，目睹了许多让人心痛的历史，世界仍然离这个愿景很远，但你们也证明了自己已经准备好成为世界所需要的进步力量。是的，你们毕业后将进入一个破碎的世界，但恢复的力量来自于社区。你们已经在这里开始建立这个社区，只有团结一致，你们才能使破碎的事物重新完整。</p>
<p>但首先，你需要毕业，在接下来的几分钟里，当你和你的同学被邀请起立时，我希望你能在这个邀请中听到行动的召唤。我希望你们能想到每一个帮助你们达到今天这个里程碑的人，并发誓要回报他们对你们的投资。最重要的是，我希望你们能以彻底开放的心态迈向未来，被那些与你同行的更小、更睿智的浪花的智慧和洞察所鼓舞，致力于拓展你们已经开始在周围编织的信任网络。</p>
<p>当你们明天醒来，你们将不再是今天的自己，也还没成为未来的自己。我希望你能从中汲取勇气和信心，因为你们这些毕业生就是水本身，是塑造海岸线的力量。你们是多么强大的力量啊！</p>
<p>来自：<a href="https://baoyu.io/blog/life/2024-stanford-commencement-speech-melinda-french-gates">https://baoyu.io/blog/life/2024-stanford-commencement-speech-melinda-french-gates</a></p>
]]></content>
  </entry>
  <entry>
    <title>Azure学生优惠申请</title>
    <url>/2024/12/02/%E6%9D%82%E9%A1%B9/Azure%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0%E7%94%B3%E8%AF%B7/</url>
    <content><![CDATA[<p>Azure 学生优惠申请</p>
<!-- -->



<p>账户认证成功的部署过程：<a href="https://blog.csdn.net/qq_33177599/article/details/132333921">手把手教你白嫖微软Azure学生免费服务器及配置教程（IPv4+IPv6）_azure ipv6-CSDN博客</a></p>
<p>解决认证无法通过问题：<a href="https://www.bilibili.com/opus/779661621020590113">如何使用 edu 邮箱申请 Azure 云学生优惠 - 哔哩哔哩 (bilibili.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/10/19/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hot%20100/</url>
    <content><![CDATA[<h2 id="hot-100"><a href="#hot-100" class="headerlink" title="hot 100"></a>hot 100</h2><h4 id="1-两数凑-target"><a href="#1-两数凑-target" class="headerlink" title="1. 两数凑 target"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数凑 target</a></h4><p>思路：哈希检测“另一半”的存在性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(target - nums[i]) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            <span class="keyword">else</span> m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>思路：仅仅是字母异位那么排序后一定相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string sort_e = e; ranges::<span class="built_in">sort</span>(sort_e);</span><br><span class="line">            m[sort_e].<span class="built_in">push_back</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans; ans.<span class="built_in">reserve</span>(m.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_, value] : m) ans.<span class="built_in">push_back</span>(value);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++ 20 引入的排序方式：<code>ranges::sort(sort_e);</code>, 如果要用算法中的要这样 ： <code>sort(sort_e.begin(),sort_e.end())</code></li>
<li>对一个 hash 遍历可以用这样的方式 <code>for(auto &amp;[_, value] : m)</code></li>
<li>resize 和 reserve 的区别是： 前者增加了size(), 后者增加了 capcity</li>
</ul>
<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><p>题目描述：一个乱序数组，问其中子序列可能组成的最长连续数组的长度是多少？时间复杂度 O(n)</p>
<p>思路：先用哈希表对数组去重，并形成数字的集合，然后遍历 hash 表。从这样一个左边不在集合内的数据开始递增查询其右边元素的存在性，记录子段长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e: nums) hash.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : hash)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(e - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = e; w = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(hash.<span class="built_in">count</span>(t ++)) w ++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(w, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="283-移动零到末尾"><a href="#283-移动零到末尾" class="headerlink" title="283. 移动零到末尾"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零到末尾</a></h4><p>题目描述：给一个数组，把其中的零全部移动到末尾，保持非零元素相对顺序不变</p>
<p>思路1：从前往后过一遍，统计前置 0 的量，根据前置零数量防止非零元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) cnt ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">swap</span>(nums[i],nums[i - cnt]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路2：快慢指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] != <span class="number">0</span>) nums[l ++] = nums[r];</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n) nums[l ++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>题目描述：一个数组代表板子高度，问两板之间可以存的最多的水的体积</p>
<p>思路：左右指针向中间靠拢，具体的让低板向高板子靠拢，以求得可能会体积增大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = h.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">            <span class="keyword">if</span>(h[i] &lt; h[j]) ans = <span class="built_in">max</span>(ans, (j - i) * h[i ++]);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, (j - i) * h[j --]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>题目描述：从一个数组中找出三个数，让三个数之和为 0；若有多种情况，用一个 vector&lt;vector<int>&gt; 返回</int></p>
<p>思路：数组排序，然后用 i j k 三个指针， i 用于枚举第一个元素， j k 相向指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(nums); <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i]; </span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; x == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(x + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> s = x + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span>(s &gt; <span class="number">0</span>) k --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; <span class="number">0</span>) j ++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;x,nums[j],nums[k]&#125;);</span><br><span class="line">                    j ++; k --;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) j ++;</span><br><span class="line">                    <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) k --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = h.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">empty</span>() || h[i] &gt; t.<span class="built_in">top</span>()) t.<span class="built_in">push</span>(h[i]);</span><br><span class="line">            l[i] = t.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 注意清空操作</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">empty</span>() || h[i] &gt; t.<span class="built_in">top</span>()) t.<span class="built_in">push</span>(h[i]);</span><br><span class="line">            r[i] = t.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">            ans += (<span class="built_in">min</span>(l[i], r[i]) - h[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前后指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; hash; <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; !hash.<span class="built_in">count</span>(s[r])) hash.<span class="built_in">insert</span>(s[r ++]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">            <span class="keyword">while</span>(s[l] != s[r])  hash.<span class="built_in">erase</span>(s[l ++]);</span><br><span class="line">            l ++; r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), ans = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; window; <span class="comment">// 维护从下标 left 到下标 right 的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="comment">// 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素</span></span><br><span class="line">            <span class="comment">// 所以要在加入 c 之前，先移出窗口内的 c</span></span><br><span class="line">            <span class="keyword">while</span> (window.<span class="built_in">count</span>(c)) &#123; <span class="comment">// 窗口内有 c</span></span><br><span class="line">                window.<span class="built_in">erase</span>(s[left++]); <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            window.<span class="built_in">insert</span>(c); <span class="comment">// 加入 c</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>); <span class="comment">// 更新窗口长度最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>题目描述：给一个字符串 s 和 p , 找出所有 s 中可以异位匹配 p 的起始位置。</p>
<p>思路：暴力，异位匹配等价于 sort 后相等；滑动窗口；快慢指针；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), k = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; <span class="type">int</span> pp[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) pp[p[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            pp[s[r] - <span class="string">&#x27;a&#x27;</span>] --; <span class="comment">// 消耗法</span></span><br><span class="line">            <span class="keyword">while</span>(pp[s[r] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="comment">// 去杂质，去冗余</span></span><br><span class="line">            &#123;</span><br><span class="line">                pp[s[l] - <span class="string">&#x27;a&#x27;</span>] ++; l ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) ans.<span class="built_in">push_back</span>(l);</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s_cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            p_cnt[p[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; ++right) &#123;</span><br><span class="line">            <span class="type">int</span> cur_right = s[right] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//窗口右端进入的字符对应序号</span></span><br><span class="line">            s_cnt[cur_right]++;         <span class="comment">//右端进入的字符对应数量+1</span></span><br><span class="line">            <span class="keyword">while</span>(s_cnt[cur_right] &gt; p_cnt[cur_right])&#123;</span><br><span class="line">                <span class="type">int</span> cur_left = s[left] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                s_cnt[cur_left]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> == n)</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定长滑动窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), k = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; </span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 首段</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s_cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>; <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p_cnt</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            s_cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            p_cnt[p[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s_cnt == p_cnt) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            s_cnt[s[i - k] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            s_cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            <span class="keyword">if</span>(s_cnt == p_cnt) ans.<span class="built_in">push_back</span>(i - k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这道题目要解决的一个问题是 s 串中出现 p 中没有的字符时的情况，两种方法都最这样的字符来者不拒。但是滑动窗口的办法通过 <code>s_cnt == p_cnt</code> 这一个条件就可以解决 “杂质” 问题，快慢指针通过 while 可以达到去杂质的效果。</li>
</ul>
<h4 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>题目描述：给你一个数组和一个k, 返回和为 k 的子数组的数量</p>
<p>思路：遍历一遍原数组建立前缀和数组，再遍历一遍前缀和数组，统计在前缀和数组的前置位中有多少的 s[i] - k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(); <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) s[i + <span class="number">1</span>] = s[i] + nums[i];</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(e - k) ? mp[e - k] : <span class="number">0</span>;</span><br><span class="line">            mp[e] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), s = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            s += e;</span><br><span class="line">            ans += mp.<span class="built_in">count</span>(s - k) ? mp[s - k] : <span class="number">0</span>;</span><br><span class="line">            mp[s] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>题目描述：给你一个数组和一个窗口宽度 k ,从数组的第 k 个位置开始，返回以该位置为结尾的宽度为 k  的数组中的最大值</p>
<p>思路：利用单调队列，维护一个 k 宽度内递减的队列，则当前窗口内最大值为队首</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 入</span></span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 出</span></span><br><span class="line">            <span class="keyword">if</span>(i - q.<span class="built_in">front</span>() &gt;= k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">// 记录/维护答案(根据队首)</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>单调栈和单调队列的对比<ul>
<li>新来的元素由于位置和值的原因会使得栈中或队中某些数据永远不可能 “出头”， 于是入队时把这部分元素剔除。</li>
<li>使用单调栈意味着<strong>位置考虑范围从当前元素一直到端点</strong>（原因是出栈原因只可能是被当前元素遮蔽），而使用单调队列则意味着<strong>位置考虑范围是从当前元素到某一条件处</strong>（条件在出队处体现）。</li>
</ul>
</li>
<li>单调队列模型<ul>
<li>入（元素进入<strong>队尾</strong>，同时维护队列<strong>单调性</strong>）</li>
<li>出（元素离开<strong>队首</strong>）</li>
<li>记录&#x2F;维护答案（根据<strong>队首</strong>）</li>
</ul>
</li>
<li>单调栈模型<ul>
<li>有选择性入：利用当前元素剔除栈顶元素，有必要的话入栈。</li>
<li>记录&#x2F;维护答案（根据<strong>栈顶</strong>）</li>
</ul>
</li>
</ul>
<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>题目描述：给出字符串 s 和 t,求出 t 的一个最小子串可以包含 t 中所有字符。</p>
<p>思路：<a href="https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_covered</span><span class="params">(<span class="type">int</span> cnt_s[], <span class="type">int</span> <span class="type">cnt_t</span>[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt_s[i] &lt; <span class="type">cnt_t</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt_s[i] &lt; <span class="type">cnt_t</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>, ans_right = m;</span><br><span class="line">        <span class="type">int</span> cnt_s[<span class="number">128</span>]&#123;&#125;; <span class="comment">// s 子串字母的出现次数</span></span><br><span class="line">        <span class="type">int</span> <span class="type">cnt_t</span>[<span class="number">128</span>]&#123;&#125;; <span class="comment">// t 中字母的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) <span class="type">cnt_t</span>[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            cnt_s[s[right]]++; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">is_covered</span>(cnt_s, <span class="type">cnt_t</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ans_right - ans_left) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ans_left = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ans_right = right;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt_s[s[left]]--; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_left &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ans_left, ans_right - ans_left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> ans_left = <span class="number">-1</span>, ans_right = m;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">128</span>]&#123;&#125;;</span><br><span class="line">        <span class="type">int</span> less = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                less++; <span class="comment">// 有 less 种字母的出现次数 &lt; t 中的字母出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; m; right++) &#123; <span class="comment">// 移动子串右端点</span></span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 右端点字母</span></span><br><span class="line">            cnt[c]--; <span class="comment">// 右端点字母移入子串</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 原来窗口内 c 的出现次数比 t 的少，现在一样多</span></span><br><span class="line">                less--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less == <span class="number">0</span>) &#123; <span class="comment">// 涵盖：所有字母的出现次数都是 &gt;=</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; ans_right - ans_left) &#123; <span class="comment">// 找到更短的子串</span></span><br><span class="line">                    ans_left = left; <span class="comment">// 记录此时的左右端点</span></span><br><span class="line">                    ans_right = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> x = s[left]; <span class="comment">// 左端点字母</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// x 移出窗口之前，检查出现次数，</span></span><br><span class="line">                    <span class="comment">// 如果窗口内 x 的出现次数和 t 一样，</span></span><br><span class="line">                    <span class="comment">// 那么 x 移出窗口后，窗口内 x 的出现次数比 t 的少</span></span><br><span class="line">                    less++;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[x]++; <span class="comment">// 左端点字母移出子串</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_left &lt; <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(ans_left, ans_right - ans_left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><p>题目描述：经典的最大子段和问题</p>
<p>思路：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN; <span class="comment">// 注意答案可以是负数，不能初始化成 0</span></span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            f = <span class="built_in">max</span>(f, <span class="number">0</span>) + x;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN; <span class="type">int</span> min_pre_sum = <span class="number">0</span>， pre_sum = <span class="number">0</span>; <span class="comment">// 初始化有讲究</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> e : nums)</span><br><span class="line">       &#123;</span><br><span class="line">            pre_sum += e; <span class="comment">// 三句话的顺序有讲究：更新了当前位置的 pre_sum 才能更新 ans, ans 要用到当前位置之前的 min_pre_sum， 所以 ans 的更新要在 min_pre_sum 更新之前</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre_sum - min_pre_sum);	</span><br><span class="line">            min_pre_sum = <span class="built_in">min</span>(pre_sum, min_pre_sum);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4><p>题目描述：经典区间合并</p>
<p>思路：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        ranges::<span class="built_in">sort</span>(intervals); vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ans.<span class="built_in">empty</span>() &amp;&amp; e[<span class="number">0</span>] &lt;= ans.<span class="built_in">back</span>()[<span class="number">1</span>]) <span class="comment">// 合并</span></span><br><span class="line">                ans.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(ans.<span class="built_in">back</span>()[<span class="number">1</span>], e[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>() - k);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">end</span>() - k, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> reverse = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) <span class="built_in">swap</span>(nums[i ++], nums[j --]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(); k %= n;</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>题目描述：给出一个数组，算出每个位置的除了此位置的其余元素乘积</p>
<p>思路：前后缀；总乘积（无法处理含 0  元素的情况）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            suf[i] = suf[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans[i] = pre[i] * suf[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果一个在范围内的数([1, n])没有放到正确的位置, 就纠正其位置</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) <span class="comment">// 此位置一直处理到合理或换过来一个不在范围内的数字</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 占用了内存空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash; <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: nums) <span class="keyword">if</span>(e &gt;=<span class="number">1</span> &amp;&amp; e &lt;= n) hash.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(i)) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nums[i]&gt; 0 &amp;&amp; nums[i]&lt;= nums.size() &amp;&amp; nums[i]!=i+1 &amp;&amp; nums[nums[i]-1]!=nums[i]</code> 中 nums[i]&gt; 0 &amp;&amp; nums[i]&lt;&#x3D; nums.size() 表示只处理数组中值在 1 - n  之间的元素，nums[i]!&#x3D;i+1 &amp;&amp; nums[nums[i]-1]!&#x3D;nums[i] 表示在 num[i] 没有到位，且目的地处没有被同样的值占据的时候才执行交换</li>
</ul>
<h4 id="73-矩阵原地置零"><a href="#73-矩阵原地置零" class="headerlink" title="73. 矩阵原地置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵原地置零</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(); <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> row1 = <span class="number">1</span>, col1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;row1 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;col1 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j ++)</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">fill</span>(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(row1 == <span class="number">0</span>) <span class="built_in">fill</span>(matrix[<span class="number">0</span>].<span class="built_in">begin</span>(), matrix[<span class="number">0</span>].<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(col1 == <span class="number">0</span>) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="54-螺旋遍历矩阵"><a href="#54-螺旋遍历矩阵" class="headerlink" title="54. 螺旋遍历矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋遍历矩阵</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设边界</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) res.<span class="built_in">push_back</span>(matrix[t][i]); <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= b; i++) res.<span class="built_in">push_back</span>(matrix[i][r]); <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; i--) res.<span class="built_in">push_back</span>(matrix[b][i]); <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= t; i--) res.<span class="built_in">push_back</span>(matrix[i][l]); <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(columns));</span><br><span class="line">        <span class="type">int</span> total = rows * columns;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(total)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order[i] = matrix[row][column];</span><br><span class="line">            visited[row][column] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="48-矩阵顺时针90度"><a href="#48-矩阵顺时针90度" class="headerlink" title="48. 矩阵顺时针90度"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 矩阵顺时针90度</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接分析出映射关系，需要借助备份矩阵</span></span><br><span class="line">、<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 深拷贝 matrix -&gt; tmp</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp = matrix;</span><br><span class="line">        <span class="comment">// 根据元素旋转公式，遍历修改原矩阵 matrix 的各元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺时针 90 ： 先转置，再行reverse; 先列reverse,再转置</span></span><br><span class="line"><span class="comment">// 逆时针 90 ： 先转置，再列reverse; 先行reverse,再转置</span></span><br></pre></td></tr></table></figure>

<h4 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h4><p>题目描述：一个矩阵，里面的数字行里面是升序的，列里面是升序的，请问如何设计一个搜索算法在其中搜索数字 target</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123; <span class="comment">// 还有剩余元素</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到 target</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">                i++; <span class="comment">// 这一行剩余元素全部小于 target，排除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--; <span class="comment">// 这一列剩余元素全部大于 target，排除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="160-链表交叉点"><a href="#160-链表交叉点" class="headerlink" title="160. 链表交叉点"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 链表交叉点</a></h4><p>题目描述：找到链表的交叉点</p>
<p>思路：</p>
<ol>
<li>若相交，链表A： a+c, 链表B : b+c. a+c+b+c &#x3D; b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b &#x3D; b+a 。因此相遇处是NULL</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!pA) pA = headB; <span class="keyword">else</span> pA = pA-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!pB) pB = headA; <span class="keyword">else</span> pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用哈希表检验是否在集合内</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hash;</span><br><span class="line">        ListNode * p = headA;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;hash.<span class="built_in">insert</span>(p); p = p-&gt;next;&#125;</span><br><span class="line">        p = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;<span class="keyword">if</span>(hash.<span class="built_in">count</span>(p)) <span class="keyword">return</span> p; p = p-&gt;next;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>去长</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* h1, ListNode* h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!h1 || !h2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *a = h1, *b = h2;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a-&gt;next != <span class="literal">nullptr</span>) &#123; a = a-&gt;next; lenA ++;&#125;</span><br><span class="line">        <span class="keyword">while</span> (b-&gt;next != <span class="literal">nullptr</span>) &#123; b = b-&gt;next; lenB ++;&#125;</span><br><span class="line">        a = h1; b = h2; <span class="comment">// 去长</span></span><br><span class="line">        <span class="keyword">while</span>(lenA &gt; lenB) &#123;a = a-&gt;next; lenA --;&#125;</span><br><span class="line">        <span class="keyword">while</span>(lenB &gt; lenA) &#123;b = b-&gt;next; lenB --;&#125;</span><br><span class="line">        <span class="keyword">while</span>(a != b) &#123;a = a-&gt; next; b = b-&gt; next;&#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><ul>
<li>双指针法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * cur = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>头插法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode * cur;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            cur-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = head-&gt;next-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = cur;</span><br><span class="line">            cur = head-&gt;next;</span><br><span class="line">            head-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链表为空或者仅一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = <span class="built_in">reverseList</span>(head-&gt;next); <span class="comment">// 只负责向下递，然后把最后一个节点指针通过ret带回到入口;</span></span><br><span class="line">        <span class="comment">// 动作是从倒数第二个节点网往前做，每个节点都是一样动作</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归相当于利用参数压栈，保留了前面方法里的那个 t</li>
</ul>
<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h4><ul>
<li>思路：反转后半段，然后双指针比对</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">        <span class="keyword">auto</span> head2 = <span class="built_in">reverseList</span>(mid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一边遍历一遍反转，反转前半段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        ListNode *p, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            p = slow;</span><br><span class="line">            slow = slow-&gt;next;    <span class="comment">//快慢遍历</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast)  <span class="comment">//奇数个节点时跳过中间节点</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;       <span class="comment">//前半部分和后半部分比较</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != slow-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s; ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123; s.<span class="built_in">push</span>(p-&gt;val); p = p-&gt;next;&#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != s.<span class="built_in">top</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">pop</span>(); p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h4><ul>
<li>快慢指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head; <span class="comment">// 乌龟和兔子同时从起点出发</span></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 乌龟走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 兔子走两步</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="comment">// 兔子追上乌龟（套圈），说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 访问到了链表末尾，无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; hash;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">count</span>(head)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            hash.<span class="built_in">insert</span>(head); head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="142-环形链表-II-找环入口"><a href="#142-环形链表-II-找环入口" class="headerlink" title="142. 环形链表 II 找环入口"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II 找环入口</a></h4><ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) <span class="keyword">return</span> head;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>快慢指针：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/?envType=study-plan-v2&envId=top-100-liked">原理讲解</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (slow != head) <span class="comment">// 关键要明白一旦有环，通过这种方式一定可以找到环入口</span></span><br><span class="line">                &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="21-两个有序链表的merge"><a href="#21-两个有序链表的merge" class="headerlink" title="21. 两个有序链表的merge"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 两个有序链表的merge</a></h4><ul>
<li>直观merge</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21.</span> 合并两个有序链表<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* dum = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), * cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 != <span class="literal">nullptr</span> ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//归并模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) <span class="comment">// 两个都存在</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">	<span class="comment">// 剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!l2)  <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-链表大数加法"><a href="#2-链表大数加法" class="headerlink" title="2. 链表大数加法"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 链表大数加法</a></h4><ul>
<li>迭代方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), * cur = dummy;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || t) <span class="comment">// 只要有一个在就循环这个逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1) t += l1-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(l2) t += l2-&gt;val;</span><br><span class="line">            ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>);</span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// l1 和 l2 为当前遍历的节点，carry 为进位</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 递归边界：l1 和 l2 都是空节点</span></span><br><span class="line">            <span class="keyword">return</span> carry ? <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry) : <span class="literal">nullptr</span>; <span class="comment">// 如果进位了，就额外创建一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果 l1 是空的，那么此时 l2 一定不是空节点</span></span><br><span class="line">            <span class="built_in">swap</span>(l1, l2); <span class="comment">// 交换 l1 与 l2，保证 l1 非空，从而简化代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = carry + l1-&gt;val + (l2 ? l2-&gt;val : <span class="number">0</span>); <span class="comment">// 节点值和进位加在一起</span></span><br><span class="line">        l1-&gt;val = sum % <span class="number">10</span>; <span class="comment">// 每个节点保存一个数位</span></span><br><span class="line">        l1-&gt;next = <span class="built_in">addTwoNumbers</span>(l1-&gt;next, (l2 ? l2-&gt;next : <span class="literal">nullptr</span>), sum / <span class="number">10</span>); <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * right = dummy, * left = dummy;</span><br><span class="line">        <span class="keyword">while</span>(n --) right = right-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(right-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>怎样获得处理链表时的边界感？就如同<code>while(right-&gt;next)</code> 这里的条件可以根据需要控制指向最后一个实体元素，也可以指向 nullptr。</li>
</ul>
<h4 id="24-两个一组交换链表中的节点"><a href="#24-两个一组交换链表中的节点" class="headerlink" title="24. 两个一组交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两个一组交换链表中的节点</a></h4><ul>
<li>迭代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * node0 = dummy;</span><br><span class="line">        ListNode * node1 = node0 -&gt; next, *node2, *node3;</span><br><span class="line">        <span class="keyword">while</span>(node1 &amp;&amp; node1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            node2 = node1-&gt;next;</span><br><span class="line">            node3 = node2-&gt;next;</span><br><span class="line"></span><br><span class="line">            node0-&gt;next = node2;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            node1-&gt;next = node3;</span><br><span class="line"></span><br><span class="line">            node0 = node1;</span><br><span class="line">            node1 = node3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>何时需要哨兵 dummy? 可能会改动头结点的时候。</p>
</li>
<li><p>递归</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> node1 = head;</span><br><span class="line">        <span class="keyword">auto</span> node2 = head-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> node3 = node2-&gt;next;</span><br><span class="line"></span><br><span class="line">        node1-&gt;next = <span class="built_in">swapPairs</span>(node3); <span class="comment">// 1 指向递归返回的链表头</span></span><br><span class="line">        node2-&gt;next = node1; <span class="comment">// 2 指向 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node2; <span class="comment">// 返回交换后的链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * cur = head; <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;cur = cur-&gt;next; n ++;&#125; <span class="comment">// 先数出来个数这个处理避免了最后一段的麻烦</span></span><br><span class="line"></span><br><span class="line">        ListNode * tail = dummy;</span><br><span class="line"></span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(; n &gt;= k; n -= k)</span><br><span class="line">        &#123;   <span class="comment">// 段内翻转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++) </span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * t = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 段连接</span></span><br><span class="line">            ListNode *<span class="type">new_t</span> = tail-&gt;next;</span><br><span class="line">            <span class="type">new_t</span>-&gt;next = cur;</span><br><span class="line">            tail-&gt;next = pre;</span><br><span class="line">            tail = <span class="type">new_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="138-随机链表深拷贝"><a href="#138-随机链表深拷贝" class="headerlink" title="138. 随机链表深拷贝"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表深拷贝</a></h4><ul>
<li>哈希表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node *, Node*&gt; mp; </span><br><span class="line">        Node * dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>), * cur = dummy;</span><br><span class="line">        Node * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            Node * node = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            mp[p] = node;</span><br><span class="line">            cur = cur -&gt; next = node;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dummy-&gt;next; p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;random = mp[p-&gt;random];</span><br><span class="line">            cur = cur-&gt;next; p = p-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>原地方法：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/889447/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/?envType=study-plan-v2&envId=top-100-liked">这里</a></li>
</ul>
<h4 id="148-链表排序"><a href="#148-链表排序" class="headerlink" title="148. 链表排序"></a><a href="https://leetcode.cn/problems/sort-list/">148. 链表排序</a></h4><p>链表下的排序算法整理：<a href="https://leetcode.cn/problems/sort-list/solutions/2400774/ge-chong-pai-xu-suan-fa-jie-jue-mou-pao-9dwmt/?envType=study-plan-v2&envId=top-100-liked">这里</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN);</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = cur-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> p = dummy;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val) p = p-&gt;next;</span><br><span class="line">            cur-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h4><ul>
<li>小根堆</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> ListNode*a, <span class="type">const</span> ListNode* b) &#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">        priority_queue&lt;ListNode *, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head: lists) <span class="keyword">if</span>(head) pq.<span class="built_in">push</span>(head);</span><br><span class="line"></span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next) pq.<span class="built_in">push</span>(node-&gt;next);</span><br><span class="line">            cur = cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>priority_queue 默认是大根堆，小根堆要重载</li>
<li>decltype(cmp) 进行模版实例化</li>
</ul>
<h4 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h4><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><ul>
<li>递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode * root, vector&lt;<span class="type">int</span>&gt; &amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">inorder</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(root || !stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root) &#123;stk.<span class="built_in">push</span>(root); root = root-&gt;left;&#125; <span class="comment">// 左侧路径全部进栈</span></span><br><span class="line">            root = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Morris 中序遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        TreeNode *predecessor = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) </span><br><span class="line">            &#123;</span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (predecessor-&gt;right &amp;&amp; predecessor-&gt;right != root) predecessor = predecessor-&gt;right;</span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span> (!predecessor-&gt;right) &#123;predecessor-&gt;right = root; root = root-&gt;left;&#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;res.<span class="built_in">push_back</span>(root-&gt;val); root = root-&gt;right;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>![image-20241021161319977](.&#x2F;hot 100&#x2F;image-20241021161319977.png)</p>
<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">            <span class="type">int</span> sz = Q.<span class="built_in">size</span>(); <span class="comment">// 每次处理一层</span></span><br><span class="line">            <span class="keyword">while</span> (sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode* node = Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                sz -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自底向上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 翻转左子树</span></span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">invertTree</span>(root-&gt;right); <span class="comment">// 翻转右子树</span></span><br><span class="line">        root-&gt;left = right; <span class="comment">// 交换左右儿子</span></span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自顶向下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right); <span class="comment">// 交换左右儿子</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 翻转左子树</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right); <span class="comment">// 翻转右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> p == q;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* node) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 下面 +1 后，对于叶子节点就刚好是 0</span></span><br><span class="line">            <span class="type">int</span> l_len = <span class="built_in">dfs</span>(dfs, node-&gt;left) + <span class="number">1</span>; <span class="comment">// 左子树最大链长+1</span></span><br><span class="line">            <span class="type">int</span> r_len = <span class="built_in">dfs</span>(dfs, node-&gt;right) + <span class="number">1</span>; <span class="comment">// 右子树最大链长+1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l_len + r_len); <span class="comment">// 两条链拼成路径</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(l_len, r_len); <span class="comment">// 当前子树最大链长</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>转化成了树深度问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 访问到空节点了，返回0</span></span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(rt-&gt;left); <span class="comment">// 左儿子为根的子树的深度</span></span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(rt-&gt;right); <span class="comment">// 右儿子为根的子树的深度</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>); <span class="comment">// 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>; <span class="comment">// 返回该节点为根的子树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = INT_MIN;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>写递归的一开始就需要想明白要返回什么，如此才能在递归逻辑中正确利用子问题的返回值。</li>
</ul>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; cur = &#123;root&#125;;</span><br><span class="line">        <span class="keyword">while</span> (cur.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; nxt; <span class="comment">// 下一层的节点</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> node : cur) &#123;</span><br><span class="line">                vals.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)  nxt.<span class="built_in">push_back</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) nxt.<span class="built_in">push_back</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = <span class="built_in">move</span>(nxt); <span class="comment">// 下一层节点交接</span></span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans; <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q; q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>(); ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());<span class="comment">// 按层处理</span></span><br><span class="line">            <span class="keyword">while</span>(n --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>分层处理的技巧，就是每一层入口处统计队里的数量</li>
<li>对于树的遍历用到的容器，容器元素放节点，从而方便用节点找左右子树</li>
</ul>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> m = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[m],<span class="built_in">dfs</span>(nums,left,m),<span class="built_in">dfs</span>(nums,m + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/">详细理解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, <span class="type">long</span> <span class="type">long</span> left = LLONG_MIN, <span class="type">long</span> <span class="type">long</span> right = LLONG_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &amp;&amp; x &lt; right &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;left, left, x) &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right,x,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre = LLONG_MIN;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;left) || root-&gt;val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;LLONG_MAX, LLONG_MIN&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>[l_min, l_max] = <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span>[r_min, r_max] = <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = node-&gt;val;</span><br><span class="line">        <span class="comment">// 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= l_max || x &gt;= r_min) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;LLONG_MIN, LLONG_MAX&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">min</span>(l_min, x), <span class="built_in">max</span>(r_max, x)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root).second != LLONG_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; k)</span> </span>&#123; <span class="comment">// 注意这里改成了引用</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 题目保证节点值非负，用 -1 表示没有找到</span></span><br><span class="line">        <span class="type">int</span> left_res = <span class="built_in">kthSmallest</span>(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span> (left_res != <span class="number">-1</span>) <span class="keyword">return</span> left_res; <span class="comment">// 答案在左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;right, k); <span class="comment">// 右子树会返回答案或者 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* node) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 题目保证节点值非负，用 -1 表示没有找到</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left_res = <span class="built_in">dfs</span>(dfs, node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (left_res != <span class="number">-1</span>) &#123; <span class="comment">// 答案在左子树中</span></span><br><span class="line">                <span class="keyword">return</span> left_res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123; <span class="comment">// 答案就是当前节点</span></span><br><span class="line">                <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, node-&gt;right); <span class="comment">// 右子树会返回答案或者 -1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == ans.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode * pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right) pre = pre-&gt;right; <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">                pre-&gt;right = root-&gt;right;   <span class="comment">// 右子树接到左子树最右节点</span></span><br><span class="line">                root-&gt;right = root-&gt;left;   <span class="comment">// 左子树接到右子树的位置</span></span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>待理解的算法：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked</a></li>
</ul>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> left_size = ranges::<span class="built_in">find</span>(inorder, preorder[<span class="number">0</span>]) - inorder.<span class="built_in">begin</span>(); <span class="comment">// 左子树的大小</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre1</span><span class="params">(preorder.begin() + <span class="number">1</span>, preorder.begin() + <span class="number">1</span> + left_size)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre2</span><span class="params">(preorder.begin() + <span class="number">1</span> + left_size, preorder.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in1</span><span class="params">(inorder.begin(), inorder.begin() + left_size)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in2</span><span class="params">(inorder.begin() + <span class="number">1</span> + left_size, inorder.end())</span></span>;</span><br><span class="line">        TreeNode *left = <span class="built_in">buildTree</span>(pre1, in1);</span><br><span class="line">        TreeNode *right = <span class="built_in">buildTree</span>(pre2, in2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>], left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) index[inorder[i]] = i;</span><br><span class="line"></span><br><span class="line">        function&lt;TreeNode*(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> pre_l, <span class="type">int</span> pre_r, <span class="type">int</span> in_l, <span class="type">int</span> in_r) -&gt; TreeNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre_l == pre_r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="type">int</span> left_size = index[preorder[pre_l]] - in_l; <span class="comment">// 左子树的大小</span></span><br><span class="line">            TreeNode *left = <span class="built_in">dfs</span>(pre_l + <span class="number">1</span>, pre_l + <span class="number">1</span> + left_size, in_l, in_l + left_size);</span><br><span class="line">            TreeNode *right = <span class="built_in">dfs</span>(pre_l + <span class="number">1</span> + left_size, pre_r, in_l + <span class="number">1</span> + left_size, in_r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[pre_l], left, right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, n, <span class="number">0</span>, n); <span class="comment">// 左闭右开区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>后序 + 中序 构建：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2646359/tu-jie-cong-on2-dao-onpythonjavacgojsrus-aob8/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/2646359/tu-jie-cong-on2-dao-onpythonjavacgojsrus-aob8/</a></li>
</ul>
<h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">int</span> t;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; cnt&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode * node, <span class="type">long</span> <span class="type">long</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        s += node-&gt;val;</span><br><span class="line">        ans += cnt.<span class="built_in">count</span>(s - t) ? cnt[s - t] : <span class="number">0</span>;</span><br><span class="line">        cnt[s] ++;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left, s);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right, s);</span><br><span class="line">        cnt[s] --;  <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        t = targetSum;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 遇到 p 或 q 就可以返回</span></span><br><span class="line">        TreeNode * left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode * right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode * root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">max</span>( root-&gt;val + l, root-&gt;val + r);</span><br><span class="line">        t = <span class="built_in">max</span>(t, root-&gt;val);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(root-&gt;val + l + r,t));</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(); <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123; <span class="built_in">dfs</span>(grid, i, j); cnt++;&#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">inArea</span>(grid, i, j)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]!=<span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i<span class="number">+1</span>, j);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>岛屿问题：<a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&envId=top-100-liked">https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&amp;envId=top-100-liked</a></p>
<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(); <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123; <span class="type">int</span> a = <span class="built_in">dfs</span>(grid, i, j); cnt = <span class="built_in">max</span>(cnt, a);&#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">inArea</span>(grid, i, j)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i<span class="number">-1</span>, j)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i<span class="number">+1</span>, j)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i, j<span class="number">-1</span>)</span><br><span class="line">        + <span class="built_in">dfs</span>(grid, i, j<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><p>题目描述：一个 m 行 n 列矩阵，初始时刻有若干坏橘子，和若干好橘子，其余为空位。已知坏橘子周围好橘子在下一刻会变成坏橘子。问全部橘子腐烂需要多久？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> DIRECTIONS[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 四方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) fresh ++; <span class="comment">// 统计新鲜橘子个数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">emplace_back</span>(i, j); <span class="comment">// 一开始就腐烂的橘子</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fresh &amp;&amp; !q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans++; <span class="comment">// 经过一分钟</span></span><br><span class="line">            vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; nxt; <span class="comment">// 层序遍历已经开始用这种技术了？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : q) </span><br><span class="line">            &#123; <span class="comment">// 已经腐烂的橘子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> d : DIRECTIONS) </span><br><span class="line">                &#123; <span class="comment">// 四方向</span></span><br><span class="line">                    <span class="type">int</span> i = x + d[<span class="number">0</span>], j = y + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= i &amp;&amp; i &lt; m &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; n &amp;&amp; grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                    &#123; <span class="comment">// 新鲜橘子</span></span><br><span class="line">                        fresh--;</span><br><span class="line">                        grid[i][j] = <span class="number">2</span>; <span class="comment">// 变成腐烂橘子</span></span><br><span class="line">                        nxt.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q = <span class="built_in">move</span>(nxt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;<span class="comment">//准备一个vector记录每个节点（课）的入度</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; map;<span class="comment">//准备一个哈希表/二维邻接矩阵记录课与课（节点）之间的关系 int -&gt; vector&lt;int&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++ i) &#123;<span class="comment">//遍历所有requistes，获取入度和所有关系</span></span><br><span class="line">            inDegree[prerequisites[i][<span class="number">0</span>]] ++; <span class="comment">//记录入度</span></span><br><span class="line">            map[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);<span class="comment">//记录所有关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个队列，进行BFS广度优先遍历，遍历入度为0的课</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) que.<span class="built_in">push</span>(i); <span class="comment">//将入度为0的课放入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//用于记录有多少门课已经上过了</span></span><br><span class="line">        <span class="comment">//遍历inDegree，更新入度，更新inDegree，直到inDegree的size为0，再确认count是否等于numCourses</span></span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> selected = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//更新所有关联课程的入度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; map[selected].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[map[selected][i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    inDegree[map[selected][i]]--;</span><br><span class="line">                    <span class="keyword">if</span>(inDegree[map[selected][i]] == <span class="number">0</span>) </span><br><span class="line">                        que.<span class="built_in">push</span>(map[selected][i]);<span class="comment">//将入度降至0的课程放入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mem[n]) <span class="keyword">return</span> mem[n];</span><br><span class="line">        mem[n] = <span class="built_in">dfs</span>(n - <span class="number">1</span>) + <span class="built_in">dfs</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> mem[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        mem.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">1</span>, f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = f1 + f0;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            c[i].<span class="built_in">resize</span>(i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="comment">// dfs(i) 表示从 nums[0] 到 nums[i] 最多能偷多少</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 递归边界（没有房子）</span></span><br><span class="line">            <span class="keyword">if</span> (memo[i] != <span class="number">-1</span>) <span class="keyword">return</span> memo[i]; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>), <span class="built_in">dfs</span>(dfs, i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, n - <span class="number">1</span>); <span class="comment">// 从最后一个房子开始思考</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            f[i + <span class="number">2</span>] = <span class="built_in">max</span>(f[i + <span class="number">1</span>], f[i] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = <span class="built_in">max</span>(f1, f0 + x);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>论文投稿整理</title>
    <url>/2024/12/04/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>12月份可投论文整理：</p>
<!-- -->

<table>
<thead>
<tr>
<th>会议名称</th>
<th>主页</th>
<th>截稿日期</th>
<th>通知时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ICCCS2025</td>
<td><a href="https://icccs.org/index.html">https://icccs.org/index.html</a></td>
<td>12月5号</td>
<td>1月5号</td>
<td>抗干扰试验室</td>
</tr>
<tr>
<td>IoTBDS2025</td>
<td><a href="https://iotbds.scitevents.org/Home.aspx">https://iotbds.scitevents.org/Home.aspx</a></td>
<td>12月13号</td>
<td>1月30号</td>
<td>主题可能不相关</td>
</tr>
<tr>
<td>AINA</td>
<td><a href="https://voyager.ce.fit.ac.jp/conf/aina/2025/index.php">https://voyager.ce.fit.ac.jp/conf/aina/2025/index.php</a></td>
<td>12月10号</td>
<td>1月10号</td>
<td>Distributed Ledger Technologies and Distributed-Parallel Computing，<strong>Workshop Proposal Due</strong>？</td>
</tr>
<tr>
<td>LATS2025</td>
<td><a href="https://cas.polito.it/LATS2025/">https://cas.polito.it/LATS2025/</a></td>
<td>12月3号</td>
<td>12月28号</td>
<td></td>
</tr>
<tr>
<td>CSP2025</td>
<td><a href="https://www.iccsp.org/index.html">https://www.iccsp.org/index.html</a></td>
<td>12月20号</td>
<td>1月20号</td>
<td></td>
</tr>
<tr>
<td>EIDWT-2025</td>
<td><a href="https://voyager.ce.fit.ac.jp/conf/eidwt/2025/cfp.php">https://voyager.ce.fit.ac.jp/conf/eidwt/2025/cfp.php</a></td>
<td>12月4号</td>
<td>12月5号</td>
<td>不确定是不是 EI</td>
</tr>
<tr>
<td>WCCCT.org</td>
<td><a href="https://www.wccct.org/index.html">https://www.wccct.org/index.html</a></td>
<td>12月10号</td>
<td>1月5号</td>
<td>比较合适</td>
</tr>
<tr>
<td>DIMVA-25</td>
<td><a href="https://www.dimva.org/dimva2025/">https://www.dimva.org/dimva2025/</a></td>
<td>12月4号</td>
<td>1月22号</td>
<td>C会</td>
</tr>
<tr>
<td>CODASPY 2025</td>
<td><a href="https://www.codaspy.org/2025/index.html">https://www.codaspy.org/2025/index.html</a></td>
<td>12月9摘要，12月16论文</td>
<td>1月31号</td>
<td></td>
</tr>
<tr>
<td>ISDA25</td>
<td><a href="https://www.fsts.ac.ma/isda25/">https://www.fsts.ac.ma/isda25/</a></td>
<td>12月20号</td>
<td>1月15号</td>
<td>高老师</td>
</tr>
</tbody></table>
<p>如何查询一个会议是否是EI:<a href="https://blog.csdn.net/binbinczsohu/article/details/108219845">https://blog.csdn.net/binbinczsohu/article/details/108219845</a></p>
<p>安全 C 会</p>
<table>
<thead>
<tr>
<th>会名</th>
<th>主页</th>
<th>提交</th>
<th>通知</th>
<th>开会</th>
</tr>
</thead>
<tbody><tr>
<td>EuroS&amp;P</td>
<td><a href="https://eurosp2025.ieee-security.org/">IEEE European Symposium on Security and Privacy</a></td>
<td>10月24号</td>
<td>2月13</td>
<td>6月30</td>
</tr>
<tr>
<td>Inscrypt</td>
<td><a href="http://www.icisc.org/">International Conference on Information Security and Cryptology</a></td>
<td>9月22日</td>
<td>10月30</td>
<td>12月20</td>
</tr>
<tr>
<td>HotSec</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>SOUPS</td>
<td><a href="https://www.usenix.org/conference/soups2024/call-for-papers">Symposium On Usable Privacy and Security</a></td>
<td>2月8号</td>
<td>3月21（退），5月13</td>
<td></td>
</tr>
<tr>
<td>SAC</td>
<td>Selected Areasin Cryptography</td>
<td>1月27</td>
<td>3月13</td>
<td>8月12</td>
</tr>
<tr>
<td>PETS</td>
<td><a href="https://petsymposium.org/2024/paperlist.php">Privacy Enhancing Technologies Symposium</a></td>
<td></td>
<td>全年4次</td>
<td>7月15</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>灵神题单7-动态规划</title>
    <url>/2024/10/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%957-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="入门DP"><a href="#入门DP" class="headerlink" title="入门DP"></a>入门DP</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><ul>
<li><p>递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会超时的递归代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// 递归边界           </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i - <span class="number">1</span>) + <span class="built_in">dfs</span>(i - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归 + 记录返回值 &#x3D; 记忆化搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 递归边界</span></span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> &amp;res = memo[i]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">        <span class="keyword">if</span> (res) <span class="keyword">return</span> res; <span class="comment">// 之前计算过  </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res = <span class="built_in">dfs</span>(i - <span class="number">1</span>) + <span class="built_in">dfs</span>(i - <span class="number">2</span>); <span class="comment">// 记忆化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        memo.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递推打表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双指针滚动递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(-- n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="746-跳台阶"><a href="#746-跳台阶" class="headerlink" title="746. 跳台阶"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 跳台阶</a></h3><ul>
<li><p>递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">dfs</span>(cost, i - <span class="number">1</span>) + cost[i - <span class="number">1</span>], <span class="built_in">dfs</span>(cost, i - <span class="number">2</span>) + cost[i - <span class="number">2</span>]);;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost, cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会超时的递归代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 递归边界</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>) + cost[i - <span class="number">1</span>], <span class="built_in">dfs</span>(i - <span class="number">2</span>) + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里看似 minCostClimbingStairs 和递归函数返回值的意义相同，似乎可以直接将 minCostClimbingStairs 实现为递归，但这里问题在于递归函数需要一个长度参数 n, 而 minCostClimbingStairs 的参数不可改动，所以递归逻辑只能在外部实现</li>
<li>使用匿名函数的好处是，可以使用父函数的局部变量，并且可以作为函数装载递归逻辑。</li>
</ul>
</li>
<li><p>递归 + 记录返回值 &#x3D; 记忆化搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; meme;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(meme[i] != <span class="number">-1</span>) <span class="keyword">return</span> meme[i];</span><br><span class="line">        meme[i] = <span class="built_in">min</span>(<span class="built_in">dfs</span>(cost, i - <span class="number">1</span>) + cost[i - <span class="number">1</span>], <span class="built_in">dfs</span>(cost, i - <span class="number">2</span>) + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> meme[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        meme.<span class="built_in">assign</span>(cost.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(cost, cost.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 递归边界</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> &amp;res = memo[i]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>) + cost[i - <span class="number">1</span>], <span class="built_in">dfs</span>(i - <span class="number">2</span>) + cost[i - <span class="number">2</span>]); <span class="comment">// 记忆化</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();  <span class="type">int</span> dp[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) </span><br><span class="line">            	dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">1010</span>] = &#123;<span class="number">0</span>, cost[<span class="number">0</span>]&#125;; <span class="comment">// 从 0 开始跳到第 i 台阶的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> dp1[<span class="number">1010</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, cost[<span class="number">1</span>]&#125;; <span class="comment">// 从 1 开始跳到第 i 台阶的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) dp1[i] = <span class="built_in">min</span>(dp1[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp1[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n],dp1[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方法显得很啰嗦，所以关键在于想清楚状态表示，状态转移</li>
</ul>
</li>
</ul>
<h3 id="377-拼凑-target"><a href="#377-拼凑-target" class="headerlink" title="377. 拼凑 target"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 拼凑 target</a></h3><p>题目描述：从一个无重复元素数组中任意取用元素，达到总和为 target, 每个元素可取用任意次</p>
<p>思路：本质是跳楼梯问题，只不过元素变多了</p>
<p>解答：</p>
<ul>
<li><p>记忆化搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[target] != <span class="number">-1</span>) <span class="keyword">return</span> memo[target];</span><br><span class="line">        memo[target] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : nums) <span class="keyword">if</span>(e &lt;= target) memo[target] += <span class="built_in">dfs</span>(target - e, nums, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[target];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">memo</span><span class="params">(target + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(target, nums, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">f</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= target; i++)	<span class="comment">// 计算凑够 i 由多少种方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : nums)</span><br><span class="line">                <span class="keyword">if</span> (x &lt;= i) f[i] += f[i - x];</span><br><span class="line">        <span class="keyword">return</span> f[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2466-凑够长度为low-high-之间"><a href="#2466-凑够长度为low-high-之间" class="headerlink" title="2466. 凑够长度为low high 之间"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466. 凑够长度为low high 之间</a></h3><p>题目描述：给出四个参数 low high zero one, zero one 分别代表可以在字符串末尾插入 0 1 的数量，问最终操作后凑出来字符串长度为 low high 之间的操作有多少种？</p>
<p>思路：其实还是跳台阶，不过是统计下最终跳到 low high 之间要有几种跳法？</p>
<ul>
<li><p>递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; memo;</span><br><span class="line">    <span class="type">int</span> _zero, _one;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[len] != <span class="number">-1</span>) <span class="keyword">return</span> memo[len];</span><br><span class="line">        memo[len] = (<span class="built_in">dfs</span>(len - _zero) + <span class="built_in">dfs</span>(len - _one))% MOD;</span><br><span class="line">        <span class="keyword">return</span> memo[len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">        _zero = zero; _one = one;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        memo.<span class="built_in">resize</span>(high + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = low; i &lt;= high; i ++)</span><br><span class="line">            ans = (ans + <span class="built_in">dfs</span>(i)) % MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1&#x27;000&#x27;000&#x27;007</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(high + <span class="number">1</span>)</span></span>; <span class="comment">// f[i] 表示构造长为 i 的字符串的方案数</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 构造空串的方案数为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) f[i] = f[i - zero];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one)  f[i] = (f[i] + f[i - one]) % MOD;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= low)  ans = (ans + f[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2266-还原键盘捕获"><a href="#2266-还原键盘捕获" class="headerlink" title="2266. 还原键盘捕获"></a><a href="https://leetcode.cn/problems/count-number-of-texts/">2266. 还原键盘捕获</a></h3><p>问题描述：诺基亚手机输入，但是我们只是用键盘监控病毒拿到了按键的信息，请计算这个按键信息可能的字符串有多少种？结果对 10^9 + 7 取余</p>
<p>解答：</p>
<p>其实对于按键上有三个字母的键位来说，其逻辑一样，只要递推出长为 i 的按键串代表的字符串数量。同理推出四个字母的按键。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>; <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dp[N], dp79[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = dp79[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = dp79[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = dp79[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = dp79[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = (dp[i <span class="number">-1</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">3</span>]) % MOD;</span><br><span class="line">        dp79[i] = (dp79[i <span class="number">-1</span>] + dp79[i - <span class="number">2</span>] + dp79[i - <span class="number">3</span>] + dp79[i - <span class="number">4</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 打表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countTexts</span><span class="params">(string pressedKeys)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, len = pressedKeys.<span class="built_in">length</span>(), ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j != len - <span class="number">1</span> &amp;&amp; pressedKeys[j] == pressedKeys[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        cnt = j - i + <span class="number">1</span>;  <span class="type">char</span> c = pressedKeys[i];</span><br><span class="line">            ans = (ans * (c != <span class="string">&#x27;7&#x27;</span> &amp;&amp; c != <span class="string">&#x27;9&#x27;</span> ? dp[cnt] : dp79[cnt])) % MOD;</span><br><span class="line">            cnt = <span class="number">0</span>; i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><p>题目描述：给出一个数组代表各家财产，已知如果取相邻两家会触发报警，那么问在不触发报警情况下可以取得的最大值</p>
<p>思路：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>] + nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= N; k++)</span><br><span class="line">        dp[k] = <span class="built_in">max</span>(dp[k<span class="number">-1</span>], nums[k<span class="number">-1</span>] + dp[k<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回溯 前面两个是否入选需要反方向特判</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i --)</span><br><span class="line">    <span class="keyword">if</span>(dp[i] == dp[i<span class="number">-2</span>] + nums[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, nums[i]);</span><br><span class="line">        i --;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两种方法本质完全一样，不同只在于前者用 dp[i - 1] 代表打劫前 i  家所获最大值，后者用 dp[i] 表示同样的意义。因此后者dp 和 num 数组的 idx  有一个 1 的错位。</li>
<li>如果想要回溯看看投了哪家，其实本质是求出来各个状态是否是靠 <code>nums[k-1] + dp[k-2]</code> 转移过来的</li>
</ul>
<h3 id="740-数组值域打家劫舍"><a href="#740-数组值域打家劫舍" class="headerlink" title="740. 数组值域打家劫舍"></a><a href="https://leetcode.cn/problems/delete-and-earn/">740. 数组值域打家劫舍</a></h3><p>题目描述：给你一个序数组，如果你选择了 num[i] 这个值，那么 num[i] - 1 和  num[i] + 1 都会被从数组中删除，请问这样选下去直到数组为空，你可以选到的数的最大值。</p>
<p>思路：选了 num[i] 旁边不能选，那么 num[i] 要么不选要么全选，就成了打家劫舍问题。但是这里需要克服一个思维痒点，就是本来要求左右均不能相邻，在 动态规划过程中似乎只考虑了左边不相邻，而不是双边不相邻。其实是因为假如有 a b c 三个元素，考虑 b 的左边不相邻和 c 的左边不相邻，合起来就是考虑了 b 的双边不相邻。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> s[<span class="number">10010</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">10010</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteAndEarn</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : nums) </span><br><span class="line">            &#123;s[e] += e; <span class="keyword">if</span>(e &gt; m) m = e;&#125;</span><br><span class="line">        dp[<span class="number">1</span>] = s[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i ++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], s[i] + dp[i - <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[m]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2320-街边门面房的安置方式数"><a href="#2320-街边门面房的安置方式数" class="headerlink" title="2320. 街边门面房的安置方式数"></a><a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">2320. 街边门面房的安置方式数</a></h3><p>题目描述：街两边每边 n 个槽位，要求每边门面房不能出现相邻，问两边综合来看多少种安置办法？</p>
<p>思路：两边逻辑完全一样，只求单边问题，类似打家劫舍，但转移方式不一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countHousePlacements</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> dp[n] * dp[n];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">3</span>;  <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> dp[n] * dp[n]; <span class="comment">// 这个初始化比较靠后，要注意n可能的极端值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++)</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> (dp[n] * dp[n]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="213-环形打家劫舍"><a href="#213-环形打家劫舍" class="headerlink" title="213. 环形打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 环形打家劫舍</a></h3><p>题目描述：打家劫舍环形版本</p>
<p>思路：分 num[0] 是否打劫两种情况，子问题是非环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(r + <span class="number">1</span>)</span></span>; dp[l] = nums[l]; </span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> dp[l];</span><br><span class="line">        dp[l + <span class="number">1</span>] = <span class="built_in">max</span>(nums[l], nums[l + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">2</span>; i &lt;= r; i ++)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>] + <span class="built_in">rob1</span>(nums, <span class="number">2</span>, n - <span class="number">2</span>), <span class="built_in">rob1</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 198. 打家劫舍 滚动求值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123; <span class="comment">// [start,end) 左闭右开</span></span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = <span class="built_in">max</span>(f1, f0 + nums[i]);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>] + <span class="built_in">rob1</span>(nums, <span class="number">2</span>, n - <span class="number">1</span>), <span class="built_in">rob1</span>(nums, <span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3186-施咒的最大总伤害-待完善"><a href="#3186-施咒的最大总伤害-待完善" class="headerlink" title="3186. 施咒的最大总伤害*(待完善)"></a><a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/">3186. 施咒的最大总伤害</a>*(待完善)</h3><p>题目描述：一个数组给出含有重复元素的全部伤害值，取用值 num[i] 则左右值差为 2 君不能取用，问所有可能的最大伤害</p>
<p>思路：就是打家劫舍变成了距离为 2 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 80 %， 需要调试</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> s[<span class="number">100010</span>]; </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumTotalDamage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; power)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: power) &#123; s[e] += e; <span class="keyword">if</span>(e &gt; m) m = e;&#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">kill</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        kill[<span class="number">1</span>] = s[<span class="number">1</span>]; <span class="keyword">if</span>(m == <span class="number">1</span>) <span class="keyword">return</span> kill[<span class="number">1</span>];</span><br><span class="line">        kill[<span class="number">2</span>] = <span class="built_in">max</span>(s[<span class="number">1</span>],s[<span class="number">2</span>]); <span class="keyword">if</span>(m == <span class="number">2</span>) <span class="keyword">return</span> kill[<span class="number">2</span>];</span><br><span class="line">        kill[<span class="number">3</span>] = <span class="built_in">max</span>(kill[<span class="number">2</span>], s[<span class="number">3</span>]); <span class="keyword">if</span>(m == <span class="number">3</span>) <span class="keyword">return</span> kill[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt;= m; i ++)</span><br><span class="line">            kill[i] = <span class="built_in">max</span>(s[i] + kill[i - <span class="number">3</span>], kill[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> kill[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumTotalDamage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; power)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : power) cnt[x]++;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>()); <span class="comment">// 注意！</span></span><br><span class="line">        ranges::<span class="built_in">sort</span>(a);</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [x, c] = a[i];</span><br><span class="line">            <span class="keyword">while</span> (a[j].first &lt; x - <span class="number">2</span>) j++;</span><br><span class="line">            f[i + <span class="number">1</span>] = <span class="built_in">max</span>(f[i], f[j] + (<span class="type">long</span> <span class="type">long</span>) x * c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><blockquote>
<p>各种子段和总结：<a href="https://www.luogu.com.cn/article/0e229ar6">完全整理</a></p>
</blockquote>
<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><blockquote>
<p>这个经典动态规划的前世今生：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/94638/zheng-li-yi-xia-kan-de-dong-de-da-an-by-lizhiqiang/">完全整理</a></p>
</blockquote>
<p>问题描述：给出数组，返回其最大子数组和</p>
<p>思路：</p>
<ul>
<li><p>动态规划 ：f[i] 表示前 i 个元素中的最大子段和，当f[i] &lt; 0 则舍弃掉从头开始</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ranges::<span class="built_in">max</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, f = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f = nums[i] + <span class="built_in">max</span>(<span class="number">0</span>, f);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀和：相当于在前缀和数组上进行一次股票交易：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">股票交易思想</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 股票交易：仅一次交易 或 时机不好不交易</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - min_price);</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 本题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> min_pre_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre_sum += x; <span class="comment">// 当前的前缀和</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre_sum - min_pre_sum); <span class="comment">// 减去前缀和的最小值</span></span><br><span class="line">            min_pre_sum = <span class="built_in">min</span>(min_pre_sum, pre_sum); <span class="comment">// 维护前缀和的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分治</p>
<p>宫水三叶对此题的分治讲解非常清楚：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/2534027/gong-shui-san-xie-cong-on-de-chang-gui-l-22hq/">分治法</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回值: [sum, lm, rm, max] = [区间和, 前缀最大值, 后缀最大值, 最大子数组和]</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">max</span>(nums[l], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;nums[l], t, t, t&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 划分成两个子区间，分别求解</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(nums, l, mid), right = <span class="built_in">dfs</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 组合左右子区间的信息，得到当前区间的信息</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = left[<span class="number">0</span>] + right[<span class="number">0</span>]; <span class="comment">// 当前区间和</span></span><br><span class="line">        ans[<span class="number">1</span>] = <span class="built_in">max</span>(left[<span class="number">1</span>], left[<span class="number">0</span>] + right[<span class="number">1</span>]); <span class="comment">// 当前区间前缀最大值</span></span><br><span class="line">        ans[<span class="number">2</span>] = <span class="built_in">max</span>(right[<span class="number">2</span>], right[<span class="number">0</span>] + left[<span class="number">2</span>]); <span class="comment">// 当前区间后缀最大值</span></span><br><span class="line">        ans[<span class="number">3</span>] = <span class="built_in">max</span>(&#123;left[<span class="number">3</span>], right[<span class="number">3</span>], left[<span class="number">2</span>] + right[<span class="number">1</span>]&#125;); <span class="comment">// 最大子数组和</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) m = <span class="built_in">max</span>(m, x);</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>)[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2606-最大开销的子字符串"><a href="#2606-最大开销的子字符串" class="headerlink" title="2606. 最大开销的子字符串"></a><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">2606. 最大开销的子字符串</a></h3><p>题目描述：从 a 到 z 字符串的默认价值是 1 - 26，给出一个无重复的字符串 chars，同时有一个对应长度的 vals, 对 chars 中的价值进行覆盖。然后给出字符串 s, 求 s 子串的最大值。</p>
<p>思路：完完全全是最大子段和模型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCostSubstring</span><span class="params">(string s, string chars, vector&lt;<span class="type">int</span>&gt; &amp;vals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mapping[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">        <span class="built_in">iota</span>(mapping, mapping + <span class="number">26</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.<span class="built_in">length</span>(); ++i)</span><br><span class="line">            mapping[chars[i] - <span class="string">&#x27;a&#x27;</span>] = vals[i];</span><br><span class="line">        <span class="comment">// 最大子段和（允许子数组为空）</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: s) &#123;</span><br><span class="line">            f = <span class="built_in">max</span>(f, <span class="number">0</span>) + mapping[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1749-子数组和的绝对值的最大值"><a href="#1749-子数组和的绝对值的最大值" class="headerlink" title="1749. 子数组和的绝对值的最大值"></a><a href="https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/">1749. 子数组和的绝对值的最大值</a></h3><p>题目描述：子段和的绝对值的最大值</p>
<p>思路：</p>
<ul>
<li><p>动态规划：相当于求最大子数组和，最小子数组和的相反数，二者的最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAbsoluteSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, f_max = <span class="number">0</span>, f_min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: nums) &#123;</span><br><span class="line">            f_max = <span class="built_in">max</span>(f_max, <span class="number">0</span>) + x;</span><br><span class="line">            f_min = <span class="built_in">min</span>(f_min, <span class="number">0</span>) + x;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f_max, -f_min));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxAbsoluteSum(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">        int s = 0, mx = 0, mn = 0;</span><br><span class="line">        for (int x: nums) &#123;</span><br><span class="line">            s += x;</span><br><span class="line">            mx = max(mx, s);</span><br><span class="line">            mn = min(mn, s);</span><br><span class="line">        &#125;</span><br><span class="line">        return mx - mn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1191-K-次串联后最大子数组之和"><a href="#1191-K-次串联后最大子数组之和" class="headerlink" title="1191. K 次串联后最大子数组之和"></a><a href="https://leetcode.cn/problems/k-concatenation-maximum-sum/">1191. K 次串联后最大子数组之和</a></h3><p>题目描述：给一个数组 arr 和整数 k, 从 arr 重复 k 次的数组中求最大子段和</p>
<p>思路：如果 k &#x3D; 1那就是经典问题，如果 k &#x3D; 2, 那就需要在 arr * 2 上跑一遍，如果 k &gt; 2, 关注 arr 的和，和为正，则在中间插入 k - 2 段，为负则其实就考虑前 2 段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    using ll = long long;</span><br><span class="line">    const ll M = 1e9 + 7;</span><br><span class="line">    int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        if (arr.empty() || k == 0) return 0;</span><br><span class="line">        ll s = accumulate(arr.begin(), arr.end(), 0LL);</span><br><span class="line">        ll s1 = 0;</span><br><span class="line">        ll m = 0;</span><br><span class="line">        for (auto x : arr) &#123;</span><br><span class="line">            s1 = max(s1, 0LL) + x;</span><br><span class="line">            m = max(m, s1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 1) return m;</span><br><span class="line">        for (auto x : arr) &#123;</span><br><span class="line">            s1 = max(s1, 0LL) + x;</span><br><span class="line">            m = max(m, s1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 2 || s &lt;= 0) return m;</span><br><span class="line">        return ((m + (k - 2) * (s % M)) % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">      int n=arr.size(),s=0,a=0,mi=0;</span><br><span class="line">      int mod=1e9+7;</span><br><span class="line">      int t=1;</span><br><span class="line">      if(k&gt;1) t=2;</span><br><span class="line">      for(int i=1;i&lt;=t;i++)</span><br><span class="line">        for(int x:arr)&#123;</span><br><span class="line">            s+=x;</span><br><span class="line">            mi=min(mi,s);</span><br><span class="line">            a=max(a,s-mi);</span><br><span class="line">        &#125;</span><br><span class="line">      s/=2;</span><br><span class="line">      if(s&gt;0)&#123;</span><br><span class="line">        long long t=max(0,k-2);</span><br><span class="line">        a = (a+s*t)%mod;</span><br><span class="line">      &#125;</span><br><span class="line">      return a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和*"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a>*</h3><p>题目描述：子数组最大和问题考虑环</p>
<p>思路：</p>
<p><img src="/2024/10/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%957-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1689750394-drKSAI-lc918-c.png" alt="lc918-c.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_s = INT_MIN; <span class="comment">// 最大子数组和，不能为空</span></span><br><span class="line">        <span class="type">int</span> min_s = <span class="number">0</span>;       <span class="comment">// 最小子数组和，可以为空</span></span><br><span class="line">        <span class="type">int</span> max_f = <span class="number">0</span>, min_f = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: nums) &#123;</span><br><span class="line">            <span class="comment">// 以 nums[i-1] 结尾的子数组选或不选（取 max）+ x = 以 x 结尾的最大子数组和</span></span><br><span class="line">            max_f = <span class="built_in">max</span>(max_f, <span class="number">0</span>) + x;</span><br><span class="line">            max_s = <span class="built_in">max</span>(max_s, max_f);</span><br><span class="line">            <span class="comment">// 以 nums[i-1] 结尾的子数组选或不选（取 min）+ x = 以 x 结尾的最小子数组和</span></span><br><span class="line">            min_f = <span class="built_in">min</span>(min_f, <span class="number">0</span>) + x;</span><br><span class="line">            min_s = <span class="built_in">min</span>(min_s, min_f);</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum == min_s ? max_s : <span class="built_in">max</span>(max_s, sum - min_s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="P2642-双子序列最大和"><a href="#P2642-双子序列最大和" class="headerlink" title="P2642 双子序列最大和"></a><a href="https://www.luogu.com.cn/problem/P2642">P2642 双子序列最大和</a></h3><p>题目描述：从数组中找两个子序列，求其最大和，两个子序列无重叠且至少中间隔一个元素</p>
<p>思路：双端处理，打擂法找最大值</p>
<blockquote>
<p>原来这道题就是某一次笔试，合唱队形的思路</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x[<span class="number">1000010</span>],f[<span class="number">1000010</span>],l[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin &gt;&gt; x[i];</span><br><span class="line">    f[<span class="number">1</span>]=x[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+x[i],x[i]);<span class="comment">//算最大子段</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[i]);<span class="comment">//算最大子段</span></span><br><span class="line">	l[n]=x[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)l[i]=<span class="built_in">max</span>(l[i<span class="number">+1</span>]+x[i],x[i]);<span class="comment">//算最大子段</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)l[i]=<span class="built_in">max</span>(l[i<span class="number">+1</span>],l[i]);<span class="comment">//算最大子段</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=f[<span class="number">1</span>]+l[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)ans=<span class="built_in">max</span>(ans,f[i<span class="number">-1</span>]+l[i<span class="number">+1</span>]);<span class="comment">//枚举中间数</span></span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P1121-环状两段子段和"><a href="#P1121-环状两段子段和" class="headerlink" title="P1121 环状两段子段和"></a><a href="https://www.luogu.com.cn/problem/P1121">P1121 环状两段子段和</a></h3><p>题目描述：考虑环，考虑双段，两段可以相邻</p>
<p>思路：<a href="https://www.luogu.com.cn/article/nerqlh15">https://www.luogu.com.cn/article/nerqlh15</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ***<span class="number">11111</span>*<span class="number">11111</span>***</span><br><span class="line"><span class="number">2.</span> <span class="number">11111</span>**<span class="number">111111</span>**<span class="number">11</span></span><br><span class="line">对于第一种情况，采用双子段和的方式</span><br><span class="line">对于第二种情况，正难则反，计算出双段最小子段和。有一种特殊情况 原数列只有一个正数</span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,f[N],g[N],a[N],sum=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=-INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],<span class="number">0</span>)+a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)g[i]=<span class="built_in">max</span>(g[i<span class="number">+1</span>],<span class="number">0</span>)+a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],f[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)g[i]=<span class="built_in">max</span>(g[i<span class="number">+1</span>],g[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)res=<span class="built_in">max</span>(res,f[i]+g[i<span class="number">+1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(f,~<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="built_in">memset</span>(g,~<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),sum+=a[i],tot+=a[i]&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t1=<span class="built_in">query</span>();</span><br><span class="line">    <span class="keyword">if</span> (tot==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=-a[i];</span><br><span class="line">        <span class="type">int</span> t2=sum+<span class="built_in">query</span>();</span><br><span class="line">        <span class="keyword">if</span> (!t2)t2=-INF;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(t1,t2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2321-拼接数组的最大分数"><a href="#2321-拼接数组的最大分数" class="headerlink" title="2321. 拼接数组的最大分数"></a><a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">2321. 拼接数组的最大分数</a></h3><p>问题描述：给出两个长度相同数组 num1 和 num2, 你可以任意选择一个区间 [l r], 对二者的[l,r]区间进行交换，也可以不交换。问，你可以得到的 max(sum(num1),sum(num2)) 的最大值</p>
<p>思路：</p>
<p><img src="/2024/10/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%957-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20241015080244822.png" alt="image-20241015080244822"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s1 = <span class="number">0</span>, maxSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, s = <span class="number">0</span>; i &lt; nums<span class="number">1.</span><span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            s1 += nums1[i];</span><br><span class="line">            s = <span class="built_in">max</span>(s + nums2[i] - nums1[i], <span class="number">0</span>);</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1 + maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumsSplicedArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">solve</span>(nums1, nums2), <span class="built_in">solve</span>(nums2, nums1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1186-删除一次得到的最大子段和"><a href="#1186-删除一次得到的最大子段和" class="headerlink" title="1186. 删除一次得到的最大子段和"></a><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/">1186. 删除一次得到的最大子段和</a></h3><p>题目描述：子段和最大值，不同的是你有从子段中删除一个的权利，并需要保证最终子段不空，问你能得到的最大子段和</p>
<p>思路：删除或者不删除，氛围两类情况进行动态规划</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归 + 返回值 = 记忆化搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN, n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN));</span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp;dfs, <span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> INT_MIN / <span class="number">2</span>; <span class="comment">// 除 2 防止负数相加溢出</span></span><br><span class="line">            <span class="type">int</span> &amp;res = memo[i][j]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">            <span class="keyword">if</span> (res != INT_MIN) <span class="keyword">return</span> res; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="number">0</span>), <span class="number">0</span>) + arr[i];</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="number">1</span>) + arr[i], <span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i, <span class="number">0</span>), <span class="built_in">dfs</span>(dfs, i, <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>]; <span class="comment">// 原地初始化的方法</span></span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>] + arr[i], f[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MIN ? arr[<span class="number">0</span>] : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN, n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, INT_MIN / <span class="number">2</span>)); <span class="comment">// 除 2 防止负数相加溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>] + arr[i], f[i][<span class="number">0</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f[i + <span class="number">1</span>][<span class="number">0</span>], f[i + <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f0 = arr[<span class="number">0</span>]; <span class="type">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1 + arr[i], f0);</span><br><span class="line">            f0 = <span class="built_in">max</span>(f0, <span class="number">0</span>) + arr[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(f0, f1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MIN ? arr[<span class="number">0</span>] : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思维拓展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多删 k 次</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> k, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(k, i - <span class="number">1</span>, <span class="number">0</span>), <span class="number">0</span>) + arr[i]; <span class="comment">// 不删</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(k - <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">1</span>) + arr[i], <span class="built_in">dfs</span>(k - <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// 必须删</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n  = arr.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(<span class="built_in">dfs</span>(k, i, <span class="number">0</span>), <span class="built_in">dfs</span>(k, i, <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恰好 k 次</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>最大子段和的基本思路是动态求解已每个元素为结尾的最大子段和，然后求出所有情况的最大和</li>
</ul>
<p>思路2：前后缀方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">r</span><span class="params">(n + <span class="number">2</span>)</span></span>; l[<span class="number">0</span>] = r[n + <span class="number">1</span>] = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            l[i] = <span class="built_in">max</span>(l[i - <span class="number">1</span>], <span class="number">0</span>) + arr[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i + <span class="number">1</span>], <span class="number">0</span>) + arr[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123; cout &lt;&lt; l[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125; cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123; cout &lt;&lt; r[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125; cout &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = l[i] + r[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(t - arr[i - <span class="number">1</span>], t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/2201406/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-o3y4/">股票系列</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 仅一次交易 或 时机不好不交易</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : prices) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p - min_price);</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2. 可多次交易，但同时手里只能有一张</span></span><br><span class="line"><span class="comment">// 占遍所有上升段，最好理解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>]) </span><br><span class="line">                	ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">memo</span>(n, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;); <span class="comment">// -1 表示还没有计算过</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="type">int</span> i, <span class="type">bool</span> hold) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hold ? INT_MIN : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>&amp; res = memo[i][hold]; <span class="comment">// 注意这里是引用</span></span><br><span class="line">            <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res; <span class="comment">// 之前计算过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hold) &#123;</span><br><span class="line">                <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="literal">true</span>), <span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="literal">false</span>) - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res = <span class="built_in">max</span>(<span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="literal">false</span>), <span class="built_in">dfs</span>(dfs, i - <span class="number">1</span>, <span class="literal">true</span>) + prices[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(dfs, n - <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上面的递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN; <span class="comment">// 没开始的时候持有认为是无底洞 基本上可以保证 f[1][0] = 0,f[1][1] = - p[0];倒不如直接这样初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i]); <span class="comment">// 第 i + 1 天不持有状态手里的钱</span></span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i]); <span class="comment">// 第 i + 1 天持有的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>, f1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p: prices) &#123;</span><br><span class="line">            <span class="type">int</span> new_f0 = <span class="built_in">max</span>(f0, f1 + p);</span><br><span class="line">            f1 = <span class="built_in">max</span>(f1, f0 - p);</span><br><span class="line">            f0 = new_f0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.同一时间手里只能拥有至多一张股票，可以交易至多 2 次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>symcc</title>
    <url>/2024/11/24/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/symcc/</url>
    <content><![CDATA[<p>Symcc 和 AFL 结合实践：<a href="https://www.freebuf.com/articles/system/266815.html">https://www.freebuf.com/articles/system/266815.html</a></p>
<p>带你搞懂符号执行的前世今生与最近技术：<a href="https://www.anquanke.com/post/id/231413">https://www.anquanke.com/post/id/231413</a></p>
<!-- -->

<h3 id="symcc-安装"><a href="#symcc-安装" class="headerlink" title="symcc 安装"></a>symcc 安装</h3><p>symcc 官网：<a href="https://www.s3.eurecom.fr/tools/symbolic_execution/symcc.html">https://www.s3.eurecom.fr/tools/symbolic_execution/symcc.html</a></p>
<ol>
<li><p>安装前置依赖</p>
<p><code>sudo apt install -y git cargo clang-14 cmake g++ git libz3-dev llvm-14-dev llvm-14-tools ninja-build python3-pip zlib1g-dev &amp;&amp; sudo pip3 install lit</code></p>
</li>
<li><p>拉取 symcc 源码</p>
<p><code>git clone https://github.com/eurecom-s3/symcc.git</code></p>
</li>
<li><p>拉取 z3</p>
</li>
</ol>
<h4 id="symcc-交叉编译问题"><a href="#symcc-交叉编译问题" class="headerlink" title="symcc 交叉编译问题"></a>symcc 交叉编译问题</h4><p>理论上symcc 可以使用 clang 将文件交叉编译到任意 llvm 支持的 architecture, 但是这需要对 backend 以及 dependencies 也进行交叉编译，然后将 backend 链接到目标程序，目前仅可以自动处理在 64 位平台交叉编译 32 位程序的场景，其他情况最好是直接在目标机上编译。</p>
<p>如果你在 64 位机器上编译 32 位程序，首先应该保证你拥有 32 位的依赖（ LLVM 和 Z3） </p>
<p>拥有了 32 位依赖以后，使用 cmake 编译源码时打开 <code>-DTARGET_32BIT=ON</code> , 如果编译系统找不到 32 位版本的 LLVM 和 Z3 , 则需要通过 <code>-DLLVM_32BIT_DIR=/some/path</code> 和 <code>-DZ3_32BIT_DIR=/some/other/path</code> 手动指定。</p>
<p>编译成的 symcc 将会识别 -m32 开关，symcc 调用 clang 编译 32 位工件。</p>
<h3 id="symcc-处理-C-程序问题"><a href="#symcc-处理-C-程序问题" class="headerlink" title="symcc 处理 C++ 程序问题"></a>symcc 处理 C++ 程序问题</h3><p>symcc 处理 c++ 程序时，对于 c++ 库有两种链接方法：</p>
<ol>
<li>使用原始的 C++ 库，此时符号执行到调用库时就要传进去具体(concretized)数字，此时相当于符号执行中断了</li>
<li>使用插桩后的 C++ 库，此时可以实现符号执行全流程追踪，这条路径需要提前编译出来一个插桩的 C++ 库文件，同时对主程序进行编译插桩，不能混合。</li>
</ol>
<p>第一种方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_REGULAR_LIBCXX=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sym++ -o myprogram mysource.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myprogram</span></span><br></pre></td></tr></table></figure>

<p>这种方案其实就是用sym++编译主程序，缺点就是不能跟踪 c++ 标准库中的操作，如 vector。</p>
<p>第二种方案：</p>
<p>首先是编译出插桩的 C++ 标准库，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/llvm/llvm-project.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> libcxx_symcc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> libcxx_symcc</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_REGULAR_LIBCXX=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_NO_SYMBOLIC_INPUT=<span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake -G Ninja /path-to-llvm-project/llvm \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;libcxx;libcxxabi&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;X86&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DLLVM_DISTRIBUTION_COMPONENTS=<span class="string">&quot;cxx;cxxabi;cxx-headers&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_BUILD_TYPE=Release \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_INSTALL_PREFIX=/some/convenient/location \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_C_COMPILER=/path-to-symcc-with-simple-backend/symcc \</span></span><br><span class="line"><span class="language-bash">    -DCMAKE_CXX_COMPILER=/path-to-symcc-with-simple-backend/sym++</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ninja distribution</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ninja install-distribution</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unset</span> SYMCC_REGULAR_LIBCXX SYMCC_NO_SYMBOLIC_INPUT</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>export SYMCC_REGULAR_LIBCXX=yes</code> 和 <code>export SYMCC_NO_SYMBOLIC_INPUT=yes</code> 两个环境变量的设置，前者其实避免了chicken-and-egg problem，也就是在编译插桩库阶段不使用插桩库。后者是应为在编译插桩库过程中有很多 helper programs, 不希望对这些函数进行符号分析。</p>
<p>插桩库我们称之为 libc++, 这里插桩库编译出来之后，有一个 backends 的选择问题，不太理解，先做记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A word on the choice of backends: While the instrumented libc++ will work with</span><br><span class="line">both backends, building it currently doesn&#x27;t work with the QSYM backend. Just</span><br><span class="line">use the simple backend for the build process - there is no problem in using the</span><br><span class="line">library with the QSYM backend later. For very interested readers, here is an</span><br><span class="line">explanation of the problem: libc++ is an LLVM project and as such uses LLVM</span><br><span class="line">support code. During the build process, it builds a code-generation tool that is</span><br><span class="line">subsequently invoked (hence the recommendation to set SYMCC_NO_SYMBOLIC_INPUT).</span><br><span class="line">At run-time, the tool loads code built from the LLVM sources we obtained via git</span><br><span class="line">above. Why is this a problem for the QSYM backend? QSYM uses support code from</span><br><span class="line">LLVM as well, which means that the QSYM backend is linked against your system&#x27;s</span><br><span class="line">LLVM libraries. If we build libc++ with the QSYM backend, the code-generation</span><br><span class="line">tool loads the QSYM code at run time and, via dependency resolution, also the</span><br><span class="line">system&#x27;s LLVM installation. The end result is that we have two versions of LLVM</span><br><span class="line">support code in the same process - the system version and the one built from git</span><br><span class="line">- which will most likely collide. Using the simple backend avoids the problem</span><br><span class="line">because it doesn&#x27;t depend on the system installation of LLVM.</span><br></pre></td></tr></table></figure>

<p>然后就可以用插桩库进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SYMCC_LIBCXX_PATH=/path-provided-as-cmake-install-prefix-for-libcxx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sym++ -o myprogram mysource.cpp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./myprogram</span></span><br></pre></td></tr></table></figure>



<h3 id="backend-问题"><a href="#backend-问题" class="headerlink" title="backend 问题"></a>backend 问题</h3><p>backend 在 symcc 的 runtime 插件中有一个文档专门描述，backend 分为 simple_backend 和 qsym_backend，前者是 Z3 的一个 wrapper，后者是 QSYM</p>
<p> 问题是 后端是干嘛的？</p>
<h3 id="symcc-的配置问题"><a href="#symcc-的配置问题" class="headerlink" title="symcc 的配置问题"></a>symcc 的配置问题</h3><p>配置主要分两种：</p>
<ol>
<li>编译源码时配置，影响编译时间和依赖设置，这个主要通过给 cmake 传参进行设置</li>
<li>运行时，运行通过 symcc 编译出的程序时，可以通过环境变量设置可以改变执行和分析过程</li>
</ol>
<p>第一类编译时选项：</p>
<ul>
<li><p>QSYM_BACKEND&#x3D;ON&#x2F;OFF (default OFF): 选择后端</p>
</li>
<li><p>TARGET_32BIT&#x3D;ON&#x2F;OFF (default OFF): 32 位程序编译支持</p>
</li>
<li><p>LLVM_DIR&#x2F;LLVM_32BIT_DIR (default empty): 如果 LLVM 不是默认位置，可以用于指定其位置，给build system 用</p>
</li>
<li><p>Z3_DIR&#x2F;Z3_32BIT_DIR (default empty): 指定Z3位置，给 build system 用</p>
</li>
<li><p>Z3_TRUST_SYSTEM_VERSION (default OFF): 无条件信任 Z3 的版本</p>
<p>运行时</p>
</li>
<li><p>SYMCC_NO_SYMBOLIC_INPUT&#x3D;0&#x2F;1 (default 0): 当被置 1 的时候 input is never marked<br>  as symbolic</p>
</li>
<li><p>SYMCC_OUTPUT_DIR (default “&#x2F;tmp&#x2F;output”): 保存 new inputs 的文件夹</p>
</li>
<li><p>SYMCC_INPUT_FILE (default empty): 默认情况下从标准输入中读取符号</p>
</li>
<li><p>SYMCC_MEMORY_INPUT&#x3D;0&#x2F;1 (default 0): 被置位时允许通过调 symcc_make_symbolic 来communicate symbolic</p>
</li>
<li><p>SYMCC_LOG_FILE (default empty): 后端日志文件</p>
</li>
<li><p>SYMCC_ENABLE_LINEARIZATION&#x3D;0&#x2F;1 (default 0): 开启 QSYM 剪枝</p>
</li>
<li><p>SYMCC_AFL_COVERAGE_MAP (default empty): 使用 AFL 的路径覆盖记录方法来跳过已经执行过的路径（QSYM backend only)</p>
</li>
<li><p>SYMCC_RUNTIME_DIR 和 SYMCC_RUNTIME32_DIR，运行时库所在文件夹</p>
</li>
<li><p>SYMCC_PASS_DIR ： compiler pass 所在文件夹</p>
</li>
<li><p>SYMCC_CLANG 和 SYMCC_CLANGPP： clang 和 clang++ 所在的文件夹</p>
</li>
</ul>
<h3 id="symcc-和-AFL-的配合"><a href="#symcc-和-AFL-的配合" class="headerlink" title="symcc 和 AFL 的配合"></a>symcc 和 AFL 的配合</h3><p>配合方式：</p>
<p>the basic idea is that SymCC and the fuzzer periodically exchange new inputs. SymCC comes with a helper that coordinates the collaboration with the fuzzer.</p>
<p>这里的 helper 在 symcc&#x2F;util&#x2F;symcc_fuzzing_helper 文件夹下，用 rust 语言写成</p>
<ol>
<li>编译生成 symcc_fuzzing_helper <code>cargo install --path util/symcc_fuzzing_helper</code>, 此时在 <code>~/.cargo/bin/symcc_fuzzing_helper</code> 位置会产生 symcc_fuzzing_helper 程序</li>
</ol>
<p>下面是联合使用 afl 和 symcc 的一个示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           Testing an example program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Suppose we wanted to search memory-related vulnerabilities in tcpdump&#x27;s</span><br><span class="line">link-layer parsers. The program can be instructed to read from a pcap and print</span><br><span class="line">relevant headers like so:</span><br><span class="line"></span><br><span class="line">$ tcpdump -e -r &lt;pcap_file&gt;</span><br><span class="line"></span><br><span class="line">Compile tcpdump and libpcap, the library it uses for pcap reading, once with</span><br><span class="line">SymCC and once with one of AFL&#x27;s compiler wrappers (e.g., afl-clang). In order</span><br><span class="line">to detect memory corruptions, enable address sanitizer in the AFL-instrumented</span><br><span class="line">version by exporting AFL_USE_ASAN=1 before compiling:</span><br><span class="line"></span><br><span class="line">$ git clone https://github.com/the-tcpdump-group/libpcap.git</span><br><span class="line">$ git clone https://github.com/the-tcpdump-group/tcpdump.git</span><br><span class="line"></span><br><span class="line">$ mkdir symcc_build; cd symcc_build</span><br><span class="line">$ cp -r ../&#123;libpcap,tcpdump&#125; .</span><br><span class="line">$ cd libpcap</span><br><span class="line">$ CC=/path/to/symcc ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ../tcpdump</span><br><span class="line">$ CC=/path/to/symcc ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">$ mkdir afl_build; cd afl_build</span><br><span class="line">$ export AFL_USE_ASAN=1</span><br><span class="line">$ cp -r ../&#123;libpcap,tcpdump&#125; .</span><br><span class="line">$ cd libpcap</span><br><span class="line">$ CC=/path/to/afl-clang ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ../tcpdump</span><br><span class="line">$ CC=/path/to/afl-clang ./configure</span><br><span class="line">$ make</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">Note that we need two copies of the source code because the projects build</span><br><span class="line">in-tree. Also, it is important to place the source code directories next to each</span><br><span class="line">other, so that tcpdump&#x27;s build system can find and statically link the</span><br><span class="line">previously built libpcap.</span><br><span class="line"></span><br><span class="line">Create a corpus of dummy files somewhere (say, in a directory called &quot;corpus&quot;);</span><br><span class="line">for tcpdump, we just start with an empty corpus containing only a dummy file for</span><br><span class="line">AFL:</span><br><span class="line"></span><br><span class="line">$ mkdir corpus</span><br><span class="line">$ echo A &gt; corpus/dummy</span><br><span class="line"></span><br><span class="line">Then launch one AFL master and one AFL secondary instance, both writing their</span><br><span class="line">outputs to the arbitrarily named directory &quot;afl_out&quot;:</span><br><span class="line"></span><br><span class="line">$ afl-fuzz -M afl-master -i corpus -o afl_out -m none -- afl_build/tcpdump/tcpdump -e -r @@</span><br><span class="line">$ afl-fuzz -S afl-secondary -i corpus -o afl_out -m none -- afl_build/tcpdump/tcpdump -e -r @@</span><br><span class="line"></span><br><span class="line">For simplicity, we disable memory limits (with &quot;-m none&quot;); be sure to read AFL&#x27;s</span><br><span class="line">notes on address sanitizer to learn about the implications. Alternatively, you</span><br><span class="line">can compile the target program without address sanitizer, in which case you</span><br><span class="line">don&#x27;t need to disable the memory limit.</span><br><span class="line"></span><br><span class="line">Finally, we can run SymCC using the helper:</span><br><span class="line"></span><br><span class="line">$ ~/.cargo/bin/symcc_fuzzing_helper -o afl_out -a afl-secondary -n symcc -- symcc_build/tcpdump/tcpdump -e -r @@</span><br><span class="line"></span><br><span class="line">It will run SymCC on the most promising inputs generated by the secondary AFL</span><br><span class="line">instance and feed any interesting results back to AFL. In AFL&#x27;s status screen,</span><br><span class="line">you should see the counter &quot;imported&quot; in the &quot;path geometry&quot; section increase</span><br><span class="line">after a short time - this means that the fuzzer instances and SymCC are</span><br><span class="line">exchanging inputs. Crashes will be stored in afl_out/*/crashes as usual.</span><br><span class="line"></span><br><span class="line">It is possible to run SymCC with only an AFL master or only a secondary AFL</span><br><span class="line">instance; see the AFL docs for the implications. Moreover, the number of fuzzer</span><br><span class="line">and SymCC instances can be increased - just make sure that each has a unique</span><br><span class="line">name.</span><br><span class="line"></span><br><span class="line">Note that there are currently a few gotchas with the fuzzing helper:</span><br><span class="line"></span><br><span class="line">1. It expects afl-showmap to be in the same directory as afl-fuzz (which is</span><br><span class="line">   usually the case), and it finds that directory via your afl-fuzz command. If</span><br><span class="line">   afl-fuzz is on your PATH (as we assumed in the example above), all is good</span><br><span class="line">   and you can ignore this point. Otherwise, you need to either call afl-fuzz</span><br><span class="line">   with an absolute path (e.g., /afl/afl-fuzz in the Docker image) or, if you</span><br><span class="line">   use a relative path, start afl-fuzz from the same working directory as the</span><br><span class="line">   fuzzing helper.</span><br><span class="line"></span><br><span class="line">2. The helper needs to know how to call the AFL-instrumented version of the</span><br><span class="line">   target, and it finds that information by scanning your afl-fuzz command. To</span><br><span class="line">   this end, it _requires_ the double dash that we used in the example above to</span><br><span class="line">   separate afl-fuzz options from the target command; if you omit it, you&#x27;ll</span><br><span class="line">   likely get errors from the helper when it tries to run afl-showmap.</span><br></pre></td></tr></table></figure>



<p>使用 symcc 编译样例文件时遇到下面一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tiger@cornerstone:~/papers/symcc/build$ ./symcc -O2 -o foo foo.c</span><br><span class="line">error: unable to load plugin &#x27;/home/tiger/papers/symcc/build/libsymcc.so&#x27;: &#x27;Plugin entry point not found in &#x27;/home/tiger/papers/symcc/build/libsymcc.so&#x27;. Is this a legacy plugin?&#x27;</span><br></pre></td></tr></table></figure>

<p>这里的 plugin 我以为是指子模块编译出来的 libsymcc-rt.so，但是事实上似乎应该是缺少运行时插桩库，果然在完成了后面的插桩库构建时候顺利解决了这个问题。</p>
<h4 id="编译-backend"><a href="#编译-backend" class="headerlink" title="编译 backend"></a>编译 backend</h4><p>simple backend</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir symcc_build_simple </span><br><span class="line">cd symcc_build_simple </span><br><span class="line">CC=clang-14 CXX=clang++-14 cmake -G Ninja \</span><br><span class="line">    -DQSYM_BACKEND=OFF \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=RelWithDebInfo \</span><br><span class="line">    -DZ3_TRUST_SYSTEM_VERSION=on \</span><br><span class="line">    -DLLVM_DIR=/usr/lib/llvm-14/cmake \</span><br><span class="line">    ../ \</span><br><span class="line">    &amp;&amp; ninja check</span><br></pre></td></tr></table></figure>



<p>qsym backend</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir symcc_build_qsym </span><br><span class="line">cd symcc_build_qsym</span><br><span class="line">cmake -G Ninja \</span><br><span class="line">            -DQSYM_BACKEND=ON \</span><br><span class="line">            -DCMAKE_BUILD_TYPE=RelWithDebInfo \</span><br><span class="line">            -DZ3_TRUST_SYSTEM_VERSION=on \</span><br><span class="line">            -DLLVM_DIR=/usr/lib/llvm-14/cmake \</span><br><span class="line">            -DZ3_DIR=/usr/bin/z3 \</span><br><span class="line">            ../ \</span><br><span class="line">            &amp;&amp; ninja check \</span><br><span class="line">            &amp;&amp; cargo install --path ../symcc_source/util/symcc_fuzzing_helper</span><br></pre></td></tr></table></figure>



<h4 id="编译-C-插桩库"><a href="#编译-C-插桩库" class="headerlink" title="编译 C++ 插桩库"></a>编译 C++ 插桩库</h4><blockquote>
<p>方法是用 symcc 编译 llvm 的 libcxx</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">BASE=/home/tiger/papers/symcc</span><br><span class="line">git clone -b llvmorg-14.0.1 --depth 1 https://github.com/llvm/llvm-project.git llvm_source </span><br><span class="line">mkdir libcxx_symcc_install </span><br><span class="line">mkdir libcxx_symcc_build </span><br><span class="line">cd libcxx_symcc_build </span><br><span class="line">export SYMCC_REGULAR_LIBCXX=yes SYMCC_NO_SYMBOLIC_INPUT=yes \</span><br><span class="line">    &amp;&amp; cmake -G Ninja ../llvm_source/llvm \</span><br><span class="line">    	-DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \</span><br><span class="line">        -DLLVM_ENABLE_PROJECTS=&quot;libcxx;libcxxabi&quot; \</span><br><span class="line">        -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \</span><br><span class="line">        -DLLVM_DISTRIBUTION_COMPONENTS=&quot;cxx;cxxabi;cxx-headers&quot; \</span><br><span class="line">        -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=$BASE/libcxx_symcc_install \</span><br><span class="line">        -DCMAKE_C_COMPILER=$BASE/symcc_build_simple/symcc \</span><br><span class="line">        -DCMAKE_CXX_COMPILER=$BASE/symcc_build_simple/sym++ \</span><br><span class="line">    &amp;&amp; ninja distribution &amp;&amp; ninja install-distribution</span><br></pre></td></tr></table></figure>



<p>上面的构建过程报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at /home/tiger/papers/symcc/llvm_source/libcxxabi/src/CMakeLists.txt:179 (add_library):</span><br><span class="line">  The install of the cxxabi_shared target requires changing an RPATH from the</span><br><span class="line">  build tree, but this is not supported with the Ninja generator unless on an</span><br><span class="line">  ELF-based or XCOFF-based platform.  The CMAKE_BUILD_WITH_INSTALL_RPATH</span><br><span class="line">  variable may be set to avoid this relinking step.</span><br></pre></td></tr></table></figure>

<p>CMake错误信息表明在构建过程中遇到了与RPATH（运行时库搜索路径）相关的问题。RPATH是ELF（Executable and Linkable Format）文件中的一种设置，用于指定动态链接器在运行时搜索共享库的路径。错误信息指出，在使用Ninja作为生成器时，除非在ELF或XCOFF（Extended COFF，一种对象文件格式）平台上，否则不支持从构建树中更改RPATH。</p>
<p>这些错误通常发生在尝试安装共享库时，CMake需要更改RPATH以指向安装位置，而不是构建树中的临时位置。以下是一些可能的解决方案：</p>
<ul>
<li>cmake 编译库文件是添加变量 <code>cmake -DCMAKE_BUILD_WITH_INSTALL_RPATH=ON</code></li>
<li>如果构建过程中不想或不能更改 rpath, 可以在构建完成后使用 <code>patchelf --set-rpath /desired/path/to/libs your_executable_or_library</code> 手动设置</li>
<li>也可以在 cmake 脚本 CMakeLists.txt 中手动设置：<code>set_target_properties(your_target PROPERTIES INSTALL_RPATH &quot;/desired/path/to/libs&quot;)</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tiger@cornerstone:/$ ls</span><br><span class="line">bin   dev  home  lib32  libx32      media  opt   root  sbin  srv       sys  usr</span><br><span class="line">boot  etc  lib   lib64  lost+found  mnt    proc  run   snap  swap.img  tmp  var</span><br><span class="line">tiger@cornerstone:/$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>把 afl 添加到系统环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时，只在这个终端中有效</span></span><br><span class="line">export PATH=&quot;/home/tiger/papers/afl:$PATH&quot;</span><br><span class="line">echo $PATH</span><br><span class="line">export PATH=&quot;/home/tiger/papers/symcc/symcc_build_qsym:$PATH&quot;</span><br><span class="line">export PATH=&quot;/home/tiger/.cargo/bin:$PATH&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>z3</title>
    <url>/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/</url>
    <content><![CDATA[<p>Z3 介绍</p>
<!-- -->

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Satisfiability Modulo Theories (SMT) problem is <strong>a decision problem for logical formulas</strong> with respect to combinations of background theories such as <strong>arithmetic</strong>, <strong>bit-vectors,</strong> <strong>arrays</strong>, and <strong>uninterpreted functions</strong>。Z3 是一个高效的 SMT 求解器，带有专门的算法求解背景理论，SMT 擅长于和其他软件分析工具如形式化验证和符号执行工具协同使用。这很大程度上归功于 Z3 对软件分析领域常见问题的支持。在一些场景中，这些工具（软件分析工具)提出的部分查询可以根据受支持逻辑中的公式进行转换。对于工具编写人员来说，了解什么是可用的支持逻辑，以及如何解决公式是很有用的。但是与SMT求解器的交互并不总是局限于将查询作为单个公式。它可能需要一系列的交互来获得可用的答案，并且工具编写人员需要了解可用的方法和旋钮。总之，本教程旨在通过示例和理论来回答以下类型的问题：</p>
<ul>
<li><strong>Z3中有哪些可用的特性，它们的设计用途是什么？</strong></li>
<li><strong>Z3中使用的底层算法是什么？</strong></li>
<li><strong>如何在Z3之上编写应用程序？</strong></li>
</ul>
<p>图1显示了Z3从4.8版本开始的整体系统关系图。左上角总结了到Z3的接口。可以通过作为文本文件或管道提供的 SMT-LIB2 脚本与Z3进行交互，也可以使用来自高级编程语言的API调用，这些编程语言是基于 c 的API调用的代理。我们将重点关注使用 Python 前端作为与 Z3接口的一种方式，并在第 2 节中开始描述 Z3 接受的术语和公式的抽象语法。第 3 节描述理论基础，这些理论定义了 z3 的输出公式及符号。第4、5、6节提供了判定公式可满足性的服务。第7节提供了预处理简化和创建子目标的方法。第8节讲解 Z3 还提供了一些不纯粹是可满足性查询的服务。服务允许用户求解可满足性模目标函数以最大化或最小化值。在第4.6.6节中还描述了用于枚举结果（骨干字面量）的专门过程。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202163058605.png" alt="image-20241202163058605"></p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>GitHub 存储库：<a href="https://github.com/z3prover/z3">https://github.com/z3prover/z3</a></p>
<p>Lvy 使用了 z3 : <a href="https://github.com/Microsoft/ivy">https://github.com/Microsoft/ivy</a></p>
<p>二进制分析工具包 Angr ： <a href="https://docs.angr.io/">https://docs.angr.io/</a></p>
<p>Z3 教程：<a href="https://microsoft.github.io/z3guide">https://microsoft.github.io/z3guide</a></p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>本教程中的材料来自多个来源。一些运行中的例子来自于在SAT和SMT社区中流传的幻灯片。第一个SAT的例子是无耻地从Armin Biere的SAT教程中摘抄的，其他的例子出现在Natarajan Shankar的幻灯片中</p>
<h2 id="Logical-interfaces-to-Z3"><a href="#Logical-interfaces-to-Z3" class="headerlink" title="Logical interfaces to Z3"></a>Logical interfaces to Z3</h2><p>Z3接受简单排序公式作为输入，这些公式可能包含由理论定义的具有预定义含义的符号。本节介绍可以用作Z3输入的逻辑公式。</p>
<p>作为基础，命题公式是由原子变量和逻辑连接词构成的。Z3接受的命题逻辑公式示例为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">Tie, Shirt = Bools(&#x27;Tie Shirt&#x27;)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(Or(Tie, Shirt), </span><br><span class="line">    Or(Not(Tie), Shirt), </span><br><span class="line">    Or(Not(Tie), Not(Shirt)))</span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure>

<p>这个例子引入了两个布尔变量Tie和Shirt。然后创建一个Solver对象并添加三个断言。</p>
<p>调用 s.check() 会产生一个判决结果；这些公式有一个令人满意的赋值。可以使用 s.model() 提取一个令人满意的模型，其中 Tie 为假，Shirt 为真。为方便起见，Z3 的 Python 前端包含一些简写函数。函数 solve 设置求解器，添加断言，检查可满足性，如果可用则打印模型。</p>
<p>命题逻辑是 Z3 处理的一个重要但较小的公式子集。它可以对组合了多个理论中的符号的公式进行推理，例如数组和算术的理论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Z = IntSort()</span><br><span class="line">f = Function(&#x27;f&#x27;, Z, Z)</span><br><span class="line">x, y, z = Ints(&#x27;x y z&#x27;)</span><br><span class="line">A = Array(&#x27;A&#x27;, Z, Z)</span><br><span class="line">fml = Implies(x + 2 == y, f(Store(A, x, 3)[y - 2]) == f(y - x + 1))</span><br><span class="line">solve(Not(fml))</span><br></pre></td></tr></table></figure>

<p>公式 fml 是有效的。它对所有整数 x，y， z，数组A，以及函数 f 的图像都成立。注意，z 甚至没有出现在公式中，但我们在这里声明它，因为我们将使用 z 来表示一个整数变量。注意，我们使用 array[index] 作为 Select（array, index）的简写。我们可以使用以下参数手动验证公式的有效性：整数常量 x 和 y 是使用函数 ints 创建的，该函数创建一个整数常量列表。在 x + 2 &#x3D; y 的假设下，右边的含义很简单等价于 <code>f(Store(A, x, 3)[x]) == f(3)</code></p>
<p>因为我们用 x + 2 替换了 y。对于 f 是什么没有限制，所以只有当 f 的参数相同时，两边与 f 相等才成立。因此，我们需要确定 <code>Store(A, x, 3)[x] == 3</code></p>
<p>左边是数组理论中的一个术语，它捕获了应用映射。Store 将位置 x 处的数组 A 更新为值3。然后……[x]检索索引 x 处的数组内容，在本例中是 3。在双重情况下，fml 的否定是不令人满意的，对 Z3 的调用产生 unsat。</p>
<p>Z3接受的公式通常遵循 SMT-LIB2 标准[4]中描述的格式。这个标准（目前的版本是2.6）定义了一阶多排序逻辑和一组由一系列背景理论定义的逻辑的文本语言。例如，在SMT-LIB2中称为 QF_LIA 的  <em>quantifier-free linear integer arithmetic</em> 的逻辑是一阶逻辑的片段，其中公式是无量词的，变量范围大于整数，解释常数是整数，允许的函数是+，-，整数乘法，除法，余数，带常数的模，允许的关系除了每个理论的一部分相等之外，还有&lt;,&lt;&#x3D;,&gt;&#x3D;,&gt;。作为一个例子，我们提供了一个SMT-LIB和同一个任意公式的Python变体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(set-logic QF_LIA)</span><br><span class="line">(declare-const x Int)</span><br><span class="line">(declare-const y Int)</span><br><span class="line">(assert (&gt; (+ (mod x 4) (* 3 (div y 2))) (- x y)))</span><br><span class="line">(check-sat)</span><br></pre></td></tr></table></figure>

<p>其对应的 python 版本是 <code>solve((x % 4) + 3 * (y / 2) &gt; x - y)</code></p>
<p>还可以提取求解器状态的SMT-LIB2表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">x, y = Ints(&#x27;x y&#x27;)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add((x % 4) + 3 * (y / 2) &gt; x - y)</span><br><span class="line">print(s.sexpr())</span><br></pre></td></tr></table></figure>

<p>产生输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(declare-fun y () Int)</span><br><span class="line">(declare-fun x () Int)</span><br><span class="line">(assert (&gt; (+ (mod x 4) (* 3 (div y 2))) (- x y)))</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>通常，SMT-LIB2 公式使用一组有限的简单排序。它包括内置的 Bool 排序，支持的理论定义了自己的排序，值得注意的Int， Real, bit-vectors （_ BitVec n）对于每一个正的位宽 n，数组(Array Index Elem) 对于每个排序索引和元素，每个排序S的字符串和序列（Seq S）。也可以声明新的排序。他们的领域可能永远不会是空的。因此，如下公式 <strong>is unsatisfiable</strong>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = DeclareSort(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">s = Const(<span class="string">&#x27;s&#x27;</span>, S)</span><br><span class="line">solve(ForAll(s, s != s))</span><br></pre></td></tr></table></figure>

<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>公式可以包含解释函数和自由函数以及常量的混合。例如，整数常量 0 和 28 被解释，而在前面的例子中使用的常量 x、y 是自由的。常量被视为虚函数。可以声明带参数的函数，例如 f &#x3D; Function（’f’， Z， Z）创建一个带整数参数的函数声明，其范围为整数。具有布尔范围的函数可用于创建公式。</p>
<h3 id="术语和公式"><a href="#术语和公式" class="headerlink" title="术语和公式"></a>术语和公式</h3><p>断言中使用的公式或添加到求解器中的公式是布尔排序的项。否则，在排序匹配的情况下，布尔和非布尔排序的项可能以任何组合混合在一起。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B = BoolSort()</span><br><span class="line">f = Function(&#x27;f&#x27;, B, Z)</span><br><span class="line">g = Function(&#x27;g&#x27;, Z, B)</span><br><span class="line">a = Bool(&#x27;a&#x27;)</span><br><span class="line">solve(g(1+f(a)))</span><br></pre></td></tr></table></figure>

<p>能产生这样的解吗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a = False, f = [else -&gt; 0], g = [else -&gt; True]]</span><br></pre></td></tr></table></figure>

<p>模型将a赋值为False， f  将所有参数映射为0，g 将所有值映射为True。标准的内置逻辑连接词是And、Or、Not、Implies、Xor。双蕴涵是等式的一种特殊情况，因此从Python中，当对布尔值 a 和 b 说a &#x3D;&#x3D; b时，它被视为 a 和 b 的双蕴涵的逻辑公式。</p>
<p>创建表达式后，有一组实用程序可用于遍历表达式。每个函数应用程序都有一个函数声明和一组作为子函数访问的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = Int(&#x27;x&#x27;)</span><br><span class="line">y = Int(&#x27;y&#x27;)</span><br><span class="line">n = x + y &gt;= 3</span><br><span class="line">print(&quot;num args: &quot;, n.num_args())</span><br><span class="line">print(&quot;children: &quot;, n.children())</span><br><span class="line">print(&quot;1st child:&quot;, n.arg(0))</span><br><span class="line">print(&quot;2nd child:&quot;, n.arg(1))</span><br><span class="line">print(&quot;operator: &quot;, n.decl())</span><br><span class="line">print(&quot;op name:  &quot;, n.decl().name())</span><br></pre></td></tr></table></figure>

<h3 id="量词和Lambda绑定"><a href="#量词和Lambda绑定" class="headerlink" title="量词和Lambda绑定"></a>量词和Lambda绑定</h3><p>全称量词和存在量词将变量绑定到量化公式的范围。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solve([y == x + 1, ForAll([y], Implies(y &lt;= 0, x &lt; y))]) # no solution</span><br></pre></td></tr></table></figure>

<p>没有解因为不管我们赋给 x 什么值，y  都有一个非正的小于这个值的值。y 的限定值与自由值无关其中 y 被限制为 x + 1。等式约束 y &#x3D;&#x3D; x + 1 也不应被误认为是对  y  的赋值。y  的边界出现并不是 x + 1 的同义词。注意，公式略有不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">solve([y == x + 1, ForAll([y], Implies(y &lt;= 0, x &gt; y))]) # [y = 3, x = 2]</span><br></pre></td></tr></table></figure>

<p>有一个解，其中<em>x</em>为1，<em>y</em>的自由出现次数为2。</p>
<p>Z3还支持基于模型构造实例化引擎的基本推理支持。s 在表示数组属性时可能很方便，Z3 使用数组排序来表示 lambda 表达式的排序。因此，memset 的结果是一个从整数到整数的数组，它产生的值 y 在从 lo 到 hi 的范围内，否则表现为范围外的 m。Z3 通过实例化类的主体来推断包含 memset 的无量词公式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m, m1 = Array(&#x27;m&#x27;, Z, Z), Array(&#x27;m1&#x27;, Z, Z)</span><br><span class="line">def memset(lo, hi, y, m):</span><br><span class="line">    return Lambda([x], If(And(lo &lt;= x, x &lt;= hi), y, Select(m, x)))</span><br><span class="line">solve([m1 == memset(1, 700, z, m), Select(m1, 6) != z])</span><br></pre></td></tr></table></figure>

<p>Lambda 绑定对于创建闭包很方便。回想一下 Lambda（[x,y], e）的含义，其中 e 是一个自由出现 x 和 y 的表达式，作为一个函数，它接受两个参数，并将它们的值替换为 e 中的 x 和 y。Z3 使用 Lambda 提升，结合Reynold的去功能化，将关于闭包的推理减少到普遍量化的定义。Z3 将数组视为一般的函数空间。所有一阶可定义函数都可以是数组。通过实例化综合项，可以建立一些二阶定理。因此,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q = Array(&#x27;Q&#x27;, Z, B)</span><br><span class="line">prove(Implies(ForAll(Q, Implies(Select(Q, x), Select(Q, y))), </span><br><span class="line">              x == y))</span><br></pre></td></tr></table></figure>

<p>可证明的。Z3合成一个实例，对应于Q的Lambda（z, z &#x3D;&#x3D; x）。</p>
<h2 id="Theories"><a href="#Theories" class="headerlink" title="Theories"></a>Theories</h2><p>我们将在这里总结Z3中支持的主要理论。在少数情况下，我们将简要介绍用于这些理论的决策程序。希望更深入地了解这些决策过程是如何实现的读者可以参考其中的一些引文。</p>
<h3 id="EUF：Equality-and-Uninterpreted-Functions"><a href="#EUF：Equality-and-Uninterpreted-Functions" class="headerlink" title="EUF：Equality and Uninterpreted Functions"></a>EUF：Equality and Uninterpreted Functions</h3><p>EUF 是一阶谓词逻辑的基本成分，在有理论之前，有常数、函数和谓词符号，以及内在的相等关系。在下面的例子中，f 是一元函数，x 是常数。求解的第一个调用对于一个模型是可行的，其中 x 被解释为 S 中的一个元素，f 是一个恒等函数。第二次调用solve是不可行的；没有模型 f 能将 x 映射到除了它本身以外的任何东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = DeclareSort(&#x27;S&#x27;)</span><br><span class="line">f = Function(&#x27;f&#x27;, S, S)</span><br><span class="line">x = Const(&#x27;x&#x27;, S)</span><br><span class="line">solve(f(f(x)) == x, f(f(f(x))) == x)</span><br><span class="line">solve(f(f(x)) == x, f(f(f(x))) == x, f(x) != x)</span><br></pre></td></tr></table></figure>

<p>无量词的EUF公式的决策过程通常基于并集查找[59]来维护相等项的等价类。形象地说，一系列相等断言 a &#x3D; b, b &#x3D; c, b &#x3D; s 产生一个等价类，它捕获相等的传递性</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202183753365.png" alt="image-20241202183753365"></p>
<p>可以通过检查与两个不相等项相关联的等价类是否相同来检查不相等的可满足性。因此，加上 a !&#x3D; d 并不产生矛盾，可以通过比较阶级代表和阶级代表来检验。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202183808026.png" alt="image-20241202183808026"></p>
<p>另一方面，当断言 c ！&#x3D; s 时，我们可以推导出冲突，因为断言为不相等的两个项属于同一类。具有联合查找数据结构的类隶属关系在几乎常数时间内平摊。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184543400.png" alt="image-20241202184543400"></p>
<p>当使用函数符号时，仅使用Union-find是不够的，如下例所示：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184629970.png" alt="image-20241202184629970"></p>
<p>在这种情况下，决策过程需要用同余规则进行推理</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184659482.png" alt="image-20241202184659482"></p>
<p>作为解决示例的准备，让我们引入可以用作子项简写的常量。因此，引入常数作为四个复合子项的代表。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184739136.png" alt="image-20241202184739136"></p>
<p>只有相等性信息可用，我们得到等价类：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184808707.png" alt="image-20241202184808707"></p>
<p>自底向上工作，同余规则要求和的类应该合并。因此,</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184857114.png" alt="image-20241202184857114"></p>
<p>暗含以下等价的粗糙集合。</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202184942465.png" alt="image-20241202184942465"></p>
<p>此时，同余法则可以再应用一次，</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202185054726.png" alt="image-20241202185054726"></p>
<p>生成等价类</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241202185110692.png" alt="image-20241202185110692"></p>
<p>v3 和 v4 的类现在被合并了。由于我们的原始公式要求这些是不同的，同余闭包推理确定公式是不可满足的。</p>
<h4 id="同余闭包"><a href="#同余闭包" class="headerlink" title="同余闭包"></a>同余闭包</h4><p>同余闭包可以用于检验等式的可满足性，</p>
<h4 id="EUF-模型"><a href="#EUF-模型" class="headerlink" title="EUF 模型"></a>EUF 模型</h4><p>运行示例的一个令人满意的版本是：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241203093137969.png" alt="image-20241203093137969"></p>
<p>这可以变形为：</p>
<p><img src="/2024/12/02/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/z3/image-20241203093224275.png" alt="image-20241203093224275"></p>
<p>然后可以输入 Z3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = DeclareSort(&#x27;S&#x27;)</span><br><span class="line">a, b, c, d, e, s, t = Consts(&#x27;a b c d e s t&#x27;, S)</span><br><span class="line">f = Function(&#x27;f&#x27;, S, S, S)</span><br><span class="line">g = Function(&#x27;g&#x27;, S, S)</span><br><span class="line">solve([a == b, b == c, d == e, b == s, </span><br><span class="line">       d == t, f(a, g(d)) != f(g(e), b)])</span><br></pre></td></tr></table></figure>

<p>经过求解，产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s = S!val!0, b = S!val!0, a = S!val!0,</span><br><span class="line"> c = S!val!0, d = S!val!1, e = S!val!1, t = S!val!1,</span><br><span class="line"> f = [(S!val!2, S!val!0) -&gt; S!val!4, else -&gt; S!val!3],</span><br><span class="line"> g = [else -&gt; S!val!2]]</span><br></pre></td></tr></table></figure>

<p>在模型中，值 S!val!0 是一个不同于S!val!1的新常数。f 的图映射了参数 S!val!2， S!val!0 到 S!val!4。所有其他参数都通过else子句映射到S!val!3, else子句被用作解释中未列出的参数的默认解释。S的解释是一个有限集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;S!val!0, S!val!1, S!val!2, S!val!3, S!val!4&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h3><p><a href="https://z3prover.github.io/papers/programmingz3.html">https://z3prover.github.io/papers/programmingz3.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>符号执行综述</title>
    <url>/2024/11/22/%E7%A7%91%E7%A0%94/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>从 symQEMU 说起，符号执行综述：</p>
<!-- -->

<ol>
<li>这篇论文主要讲解了 <a href="https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649774557&idx=1&sn=fda94410040b518fc0baa3e373de1b71&chksm=889369b2bfe4e0a4d2a9d0c583ea9ab1f45ac637d450b0b966afdbfcf902bffdfffe2efd8d61&scene=27">SymQEMU</a> 这个二进制分析工具，对比了其和之前的工作 symcc 以及经典工具 s2e QSYM 之间的差异</li>
<li>这篇<a href="https://blog.csdn.net/hmysn/article/details/124797125">文章</a>以下概念的阐述很清晰且有逻辑：符号执行，动态执行，并行执行，选择符号执行。</li>
<li>一个符号执行的<a href="https://www.cnblogs.com/lqerio/p/15980670.html">综述</a></li>
<li>符号执行工具：<a href="https://blog.csdn.net/kitsch0x97/article/details/138508887">https://blog.csdn.net/kitsch0x97/article/details/138508887</a></li>
</ol>
<p>如果要理解符号执行是什么，比较合理的顺序是以上三篇文章按照 2 -&gt; 3 -&gt; 1 的顺序阅读。</p>
<h4 id="基础工具研究"><a href="#基础工具研究" class="headerlink" title="基础工具研究"></a>基础工具研究</h4><ul>
<li>s2e</li>
<li>LLVM</li>
<li>KLEE</li>
<li>QEMU</li>
</ul>
<h4 id="SymQEMU"><a href="#SymQEMU" class="headerlink" title="SymQEMU"></a>SymQEMU</h4>]]></content>
  </entry>
  <entry>
    <title>智能合约二进制码漏洞检测工具</title>
    <url>/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/A_Survey_on_Vulnerability_Detection_Tool_%20of_Smart_Contract_Bytecode/</url>
    <content><![CDATA[<p>智能合约二进制码漏洞检测工具</p>
<!-- -->

<h3 id="当前工具分类"><a href="#当前工具分类" class="headerlink" title="当前工具分类"></a>当前工具分类</h3><h4 id="code-translation"><a href="#code-translation" class="headerlink" title="code translation"></a>code translation</h4><blockquote>
<p>使用反汇编从二进制码到源码</p>
</blockquote>
<ul>
<li>Disassembly: 二进制码到汇编</li>
<li>Decompilation：汇编到高级语言</li>
</ul>
<h4 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h4><ul>
<li><h5 id="control-glow-analysis"><a href="#control-glow-analysis" class="headerlink" title="control glow analysis"></a>control glow analysis</h5></li>
</ul>
<blockquote>
<p>use a CFG to represent paths trversed through a program during execution</p>
</blockquote>
<ul>
<li><h5 id="pattern-matching"><a href="#pattern-matching" class="headerlink" title="pattern matching"></a>pattern matching</h5></li>
</ul>
<blockquote>
<p>search a given sequence od instructions</p>
</blockquote>
<ul>
<li><h5 id="data-flow-analysis："><a href="#data-flow-analysis：" class="headerlink" title="data flow analysis："></a>data flow analysis：</h5></li>
</ul>
<blockquote>
<p>collecting information about the dependencies and possible ranges of values at various points in a program </p>
</blockquote>
<ul>
<li><h5 id="symbolic-executiom"><a href="#symbolic-executiom" class="headerlink" title="symbolic executiom"></a>symbolic executiom</h5></li>
</ul>
<blockquote>
<p>executing a program at a symbolic level. it treats values as symbols and code instructions as symbolic equations to reason about the logic of code exection.</p>
</blockquote>
<h4 id="Dynamic-Analysis"><a href="#Dynamic-Analysis" class="headerlink" title="Dynamic Analysis"></a>Dynamic Analysis</h4><blockquote>
<p>examining the code by executing it on a real or virtual processor.  on most vulnerability dection tools make use of dynamic analysis to validate the result of static analysis, others take advantage of fuzzing</p>
</blockquote>
<h3 id="智能合约漏洞类型"><a href="#智能合约漏洞类型" class="headerlink" title="智能合约漏洞类型"></a>智能合约漏洞类型</h3><h4 id="general-vulnerability-types"><a href="#general-vulnerability-types" class="headerlink" title="general vulnerability types"></a>general vulnerability types</h4><ul>
<li>interger overflow</li>
<li>premission verification missing</li>
<li>execption handling error</li>
</ul>
<h4 id="unique-vulnerabilities-in-smart-contract"><a href="#unique-vulnerabilities-in-smart-contract" class="headerlink" title="unique vulnerabilities in smart contract"></a>unique vulnerabilities in smart contract</h4><ul>
<li><p>transaction ordering dependency</p>
<blockquote>
<p>由于交易顺序和交易之间的数据依赖关系造成的逻辑错。比如 A 给 B 转账某个数字，而这个数字可以在另一个合约中被改写，第一个提交到第一个执行过程中假如被别的合约改掉了这个数字，则发生错误。本质原因是交易的提交和执行有时间差。</p>
</blockquote>
</li>
<li><p>predictable random number</p>
<blockquote>
<p>用块时间戳或者块号产生伪随机数，攻击者可能在理解了随机数机制之后预测随机数</p>
</blockquote>
</li>
<li><p>reentrancy</p>
<blockquote>
</blockquote>
</li>
<li><p>frozen token</p>
<blockquote>
<p>有些合约要调用外部合约库来传递 token ，而这个被调用的合约库可能已经失效注销，这时候这个调用就会被冻结在合约中。</p>
</blockquote>
</li>
<li><p>fake EOS and fake notice</p>
<blockquote>
<p> A want to transfer a token to B， A will push transfer action to eosio.token and then eosio.token will send a notice to B, triggerint B’s apply function.</p>
</blockquote>
</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="Oyente"><a href="#Oyente" class="headerlink" title="Oyente"></a>Oyente</h4><ul>
<li>static analysis tool based on sysmbolic execution run directly on EVM bytecode</li>
<li>has four modules: CFGBuilder吗， Explore, CoreAnalysis, Validator.</li>
</ul>
<h4 id="Securify"><a href="#Securify" class="headerlink" title="Securify"></a>Securify</h4><ul>
<li>lightweight and scalable security verifier</li>
<li>static analysis tool based on symbolic abstraction and pattern matching</li>
<li>Bytecode to SSA，then encoding the dependence graph of the contracts in stratified Datalog, then use Datalog solvers to analysze the Datalog code and get <strong>semantic facts</strong> of contract effciently. the semantic facts include data flow dependency and control flow dependency. the compliance and violation patterns are defined in a designed domain-specific language(DSL)</li>
</ul>
<h4 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h4><ul>
<li>base on symbolic execution and taint analysis</li>
<li>disassembling the EVM byteccode，initalize the account then use a couple of  transactions to explore the state space of the contract until an undesierd state is discovered. then  Mythril will calculate the transactions required to reach that state.</li>
</ul>
<h4 id="Manticore"><a href="#Manticore" class="headerlink" title="Manticore"></a>Manticore</h4><ul>
<li>symbolic execution framework for Ethereum smart contracts as well as Linux ELF binaries. </li>
<li>Manticore can execute the contract with <strong>symbolic transactions</strong> where both value and data are symbolic and explore all possible states, generating corresponding concrete inputs for any program state with Z3-Slover</li>
</ul>
<h4 id="teEther"><a href="#teEther" class="headerlink" title="teEther"></a>teEther</h4><ul>
<li>ethereum EVM contracts based on symbolic execution and result validation.</li>
<li>the first step is  to build a CFG，second is to scan the contract for important instructions DELEGATECLL SELFDESTRUCT SSTORE， third step is to explore paths to these instructions, the fourth step is to generate a set of path constraints through symbolic wexecution. fifth is to slove the constraints of these paths to detect the vulnerabilities.</li>
</ul>
<h4 id="MAIAN"><a href="#MAIAN" class="headerlink" title="MAIAN"></a>MAIAN</h4><ul>
<li>based on symbolic execution and result validation</li>
</ul>
<h4 id="ContractFuzzer"><a href="#ContractFuzzer" class="headerlink" title="ContractFuzzer"></a>ContractFuzzer</h4><ul>
<li>two parts: offline instrumentation and online fuzzing</li>
<li>offline instrumention is to instrument the EVM code in order for the fuzzing part to monitor the execution of the contract</li>
<li>online fuzzing : after analyzing the contract, ContractFuzzer extract the information of ABI and EVM bytecode of the contract, whilch help the tool genreate valid fuzzing inputs</li>
</ul>
<h3 id="tools-for-EOSIO-Contracts"><a href="#tools-for-EOSIO-Contracts" class="headerlink" title="tools for EOSIO Contracts"></a>tools for EOSIO Contracts</h3><h4 id="EVulHunter"><a href="#EVulHunter" class="headerlink" title="EVulHunter"></a>EVulHunter</h4><ul>
<li>static analysis tool for EOSIO WASM contracts based on pattern matching.</li>
<li>three modules: CFG bulider(Octopus), WASM Simulator, Detector Engine(two detector for fake EOS and fake notice)</li>
</ul>
<h4 id="EOSafe"><a href="#EOSafe" class="headerlink" title="EOSafe"></a>EOSafe</h4><ul>
<li>a static anasis framework for vulnerability dection in EOSIO WASM smart contracts.</li>
<li>three moudles: Engine, Emulator, Scanner </li>
<li>engine ：symbolic execution of a contract, receiving the CFG and dissembled instructions of the contract as input, execute the code and within basic blocks, exploring all workable path and gathering path costractions. </li>
<li>Emulator:  emulating the side effects of imported functions in the contract.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>PrivSSO</title>
    <url>/2024/11/19/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/PrivSSO/</url>
    <content><![CDATA[<p>PrivSSO</p>
<!-- -->

<ul>
<li><p>PrivSSO is a tuple of five phases: (Initialize, Register, DevBind, Login, DevUnbind). Each of these phases has one or more algorithms presented as follows.</p>
</li>
<li><p><a href="https://blog.csdn.net/GoodLuckAC/article/details/125217887">EUF_CMA</a>：一种验证安全性的方法</p>
</li>
<li><p>本文的主要思路是针对之前的 SSO(single-sign-on) 机制以容易泄露用户的订阅信息和访问模式的问题，设计了一种 “混合” 认证机制。一个长期密钥存储在一个保护良好的硬件令牌中，作为“主要”认证因子，保证强安全性。与便携设备绑定的临时密钥作为“日常使用”的 AF,已实现高度便利性。为了保护订阅模式和访问模式不被泄露，文章提出了可修改的令牌生成机制，允许由用户指定 idp sp(serive provider) 可以从中访问到的信息。</p>
</li>
</ul>
]]></content>
  </entry>
</search>
