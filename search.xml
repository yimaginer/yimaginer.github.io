<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL源码阅读</title>
    <url>/2024/07/06/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>AFL 源码阅读记录</p>
<span id="more"></span>

<ul>
<li><p>main 函数</p>
<ul>
<li><p>函数功能：解析命令参数，</p>
</li>
<li><p>具体过程：</p>
<ul>
<li>命令解析</li>
<li>分别调用 setup_signal_handlers(); check_asan_opts(); 设置信号处理函数，设置 asan；如果是并行 fuzzing ，调用 fix_up_sync() 设置同步</li>
<li>根据环境变量设置运行全局变量，检测可能存在的模式冲突</li>
<li>调用 save_cmdline 保存命令行；调用 fix_up_banner 设置运行时窗口；调用 check_if_tty 测试终端；调用 get_core_count 获取 CPU 核心数，如果开启了 CPU 亲和性，调用 bind_to_free_cpu() 找到空闲核心；调用 check_crash_handling() 查看core pattern 是否设置为 core；调用 setup_post() 设置收尾处理函数；调用 setup_shm() 设置最关键的路径记录向量；调用 init_count_class16() 构建 count_class_lookup16[65536] 阶梯数组；调用 setup_dirs_fds() 设置好输出文件夹；调用 read_testcases() 把输入文件夹的测试用例加入测试 queue；调用 load_auto() 读取输出文件夹中自动生成的字典；<strong>啥时候生成的</strong>？调用 pivot_inputs() 在输出目录中为输入测试用例建立硬链接；<strong>目的是什么？</strong>如果使用 -x 参数设置了 extras_dir，就调用 load_extras 加载字典；如果没有设置 timeout_given，调用 find_timeout() 尝试从先前的运行中读取 exec_tmout（如果设置了 resuming_fuzz）； 调用 detect_file_args(argv + optind + 1) 对参数中的 @@ 进行替换；如果没有设置 out_file，调用 setup_stdio_file() 删除可能的遗留并新建 out_dir&#x2F;.cur_input；<strong>将来谁往里面写</strong>？调 check_binary(argv[optind]) 进行二进制文件检测。</li>
<li>记录当前时间戳，写入 start_time</li>
<li>如果是 qemu 模式，调用 get_qemu_argv(argv[0], argv + optind, argc - optind) 重新设置参数</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li><p>setup_shm 设置的几个关键变量</p>
<ul>
<li>virgin_bits	没有触碰到的路径，在 in_bitmap 为空，也即没有外来引入 bitmap 情况下，初始化为 0xFF</li>
<li>virgin_tmout  没有超时的路径，初始化为 0xFF，<strong>逻辑不通</strong></li>
<li>virgin_crash   没有 crash 的路径，初始化为0xFF</li>
<li>trace_bits       申请匿名共享内存，并加载到 fuzzer 进程空间，用 trace_bits 指向这个地址，将共享内存 id 放到环境变量 __AFL_SHM_ID 中。<strong>为什么要以字符串形式放进去？</strong></li>
</ul>
</li>
<li><p>timeout_given </p>
<ul>
<li>-t 选项参数中 exec_tmout 有 + 后缀，timeout_given &#x3D; 2，否则为 1</li>
<li>没设置 -t，则 timeout_given 为 0</li>
<li>in_place_resume 模式下，超时时间来自于上次运行 out_dir&#x2F;fuzzer_stats 文件中的 exec_timeout 字段，则设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>resuming_fuzz</p>
<ul>
<li>一旦从 queue 读到名称为 id:%06u,orig:%s 测试用例的测试用例，将 resuming_fuzz 设为 1，其余情况皆为 0</li>
</ul>
</li>
<li><p>in_place_resume</p>
<ul>
<li>如果 -i 的参数是 -，则将 in_place_resume 设置为 1。<strong>除了 in_place_resume 还有什么恢复形式</strong>？</li>
</ul>
</li>
<li><p>static u32 find_start_position(void)</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，找到继续 fuzz 的起始点</li>
<li>具体过程：<ul>
<li>找到 out_dir&#x2F;fuzzer_stats，读出其中的 cur_path</li>
<li>如果 cur_path 大于 queued_paths，则返回 0，否则返回 cur_path。</li>
</ul>
</li>
</ul>
</li>
<li><p>static void find_timeout(void) 函数</p>
<ul>
<li>函数作用：当本次模糊测试是 resuming_fuzz 时，设置 exec_tmout 和   timeout_given</li>
<li>具体过程：</li>
<li>如果是 in_place_resume，读取 out_dir&#x2F;fuzzer_stats 文件，否则读取 in_dir&#x2F;..&#x2F;fuzzer_stats 文件</li>
<li>读取其中的 exec_timeout，都不到，或读到了值小于 4，直接返回没有任何改动</li>
<li>如果读到了并且不小于 4 ，则把 exec_timeout 设置到 exec_tmout，并设置 timeout_given &#x3D; 3</li>
</ul>
</li>
<li><p>EXP_ST void detect_file_args(char** argv) 函数</p>
<ul>
<li>函数作用：把参数中 @@ 替换</li>
<li>具体过程：<ul>
<li>逐个遍历 afl-fuzz 的参数，遇到含有 @@ 则停下来处理</li>
<li>如果通过 -f 指定了 out_file，并且 out_file 是自根目录 &#x2F; 开始，则将 @@ 替换为 out_file，如果不是自根目录开始，则将 @@ 替换为 cwd&#x2F;out_file</li>
<li>如果压根没指定 out_file，把 @@ 替换为 out_dir&#x2F;.cur_input</li>
<li>形如 xxx@@xxx, 也对@@进行相同的替换。</li>
</ul>
</li>
</ul>
</li>
<li><p>EXP_ST void setup_stdio_file(void) 函数</p>
<ul>
<li>函数作用：删除可能的遗留并新建 out_dir&#x2F;.cur_input</li>
</ul>
</li>
<li><p>EXP_ST void check_binary(u8* fname) 函数</p>
<ul>
<li>函数作用：确保测试目标存在且是正常的二进制可执行文件，测试是否插桩匹配当前运行模式，</li>
<li>函数过程：<ul>
<li>如果 fname 含有 &#x2F; ，或者 fname 不含 &#x2F;  但 PATH 环境变量是空的，直接拿着 fname 做检测，假如不是常规文件，或者不具备执行权限，或者 size 小于 4，视为不合格 target_path，<strong>报错退出</strong>。</li>
<li>fname 不含 &#x2F;，且 PATH 环境变量不空，就遍历 path 中的路径，并在每个路径下搜索 fname 文件，满足：是常规文件，具备执行权限， size 大于 4，视为合格 target_path，结束遍历。如果遍历所有路径，没找到满足这三个条件的 fname，视为没有合格 target_path，将 target_path 置 0，<strong>报错退出</strong>。</li>
<li>找到合格 target_path 时候，检查 AFL_SKIP_BIN_CHECK 是否被设置，设置则返回，否则观察如果二进制文件在 &#x2F;tmp&#x2F; 或 &#x2F;var&#x2F;tmp&#x2F; 文件夹中，<strong>报错退出</strong>。</li>
<li>将二进制文件直接用 mmap 映射到进程地址空间<ul>
<li>检测到是 shell 脚本，则<strong>报错退出</strong>。</li>
<li>检测到不是 ELF 文件，则<strong>报错退出</strong>。</li>
<li>在非 qemu_mode 且非 dumb_mode 下检测是否插桩，memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1)) 检测方式是在二进制文件中搜索共享内存 id，检测到代表已经完成插桩。</li>
<li>qemu_mode 下，如果也进行了插桩，则<strong>报错退出</strong>。</li>
<li>在二进制文件中搜索到 libasan.so 或 __msan_init，则设置 uses_asan &#x3D; 1</li>
<li>如果在二进制中搜索到 ##SIG_AFL_PERSISTENT## ，则把环境变量 __AFL_PERSISTENT 设为 1，把 persistent_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_PERSISTENT 却被设置了，矛盾，输出报警信息。</li>
<li>如果在二进制中搜索到 ##SIG_AFL_DEFER_FORKSRV## ，则把环境变量 __AFL_DEFER_FORKSRV 设为 1，把 deferred_mode &#x3D; 1；假如在二进制中没搜到 ##SIG_AFL_PERSISTENT##，但是环境变量 AFL_DEFER_FORKSRV 却被设置了，矛盾，输出报警信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static char** get_qemu_argv(u8* own_loc, char** argv, int argc)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>申请大小为 argc + 4 的 char 指针数组 new_argv</li>
<li>把 argv[1] 开始的 argc 项拷贝到 new_argv[3] 开始的位置</li>
<li>填充 argv[1-2], new_argv[2] &#x3D; target_path, new_argv[1] &#x3D; “–”</li>
<li>填充 argv[0]，<ul>
<li>先考虑 AFL_PATH&#x2F;afl-qemu-trace 文件，存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>再看 own_loc&#x2F;afl-qemu-trace （own_loc 如果含有 &#x2F; 的话），存在则 target_path &#x3D; new_argv[0] &#x3D; cp，返回 new_argv</li>
<li>前两个路径都没找到，看 BIN_PATH “&#x2F;afl-qemu-trace”，其中 BIN_PATH 在根 makefile 中定义，存在则操作同上</li>
<li>前面都寻找失败，则报错退出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static void perform_dry_run(char** argv)</p>
<ul>
<li>函数作用：</li>
<li>具体过程：<ul>
<li>cal_failures 初始化为 0，用于，获取环境变量 AFL_SKIP_CRASHES 写进 skip_crashes</li>
<li>遍历测试用例队列 queue，做如下事情<ul>
<li>将测试用例内容读入新开辟内存 use_mem 上，<strong>为什么多此一举</strong>？执行 res &#x3D; calibrate_case(argv, q, use_mem, 0, 1)</li>
<li>此时若 stop_soon 不为 0，<strong>函数返回</strong></li>
<li>如果 res &#x3D;&#x3D; crash_mode 或者 res &#x3D;&#x3D; FAULT_NOBITS，打印一下当前元素的 q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us 三个信息</li>
<li>然后根据 res 的值分类处理<ul>
<li>FAULT_NONE：如果当前处理的是队列首元素，也即 q &#x3D;&#x3D; queue，调 check_map_coverage()；如果 crash_mode 被设置，<strong>报错退出</strong>。</li>
<li>FAULT_TMOUT：依据 timeout_given 是否为 0 分别处理<ul>
<li>timeout_given 为 0，报错退出。</li>
<li>timeout_given 不为 0，且为 2 或 3（2代表 -t 参数有 + 号，3代表 in_place_resume 且上次执行设置了 exec_tmout），报警并 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++;</li>
</ul>
</li>
<li>FAULT_CRASH：</li>
<li>如果 crash_mode 被设置，跳过不处理，结束 switch</li>
<li>如果 skip_crashes 被设置，执行 q-&gt;cal_failed &#x3D; CAL_CHANCES; cal_failures++，结束 switch</li>
<li>如果前面两个都没设置，而 mem_limit 被设置，打印出可能出错的原因</li>
<li>FAULT_ERROR：代表文件不能执行，结束 switch</li>
<li>FAULT_NOINST：文件没有被插桩，结束 switch</li>
<li>FAULT_NOBITS：useless_at_start++，如果 in_bitmap 和 shuffle_queue 都为 0，报警，结束 switch</li>
</ul>
</li>
<li>如果 q-&gt;var_behavior 被设置，报警 Instrumentation output varies across runs，<strong>什么意思</strong></li>
</ul>
</li>
<li>遍历完成之后，如果 cal_failures 不为 0，根据 cal_failures 和 queued_paths 的相对数据处理<ul>
<li>cal_failures &#x3D;&#x3D; queued_paths，所有测试用例都失败，报错退出</li>
<li>al_failures * 5 &gt; queued_paths，超过 20% 测试用例失败，报警。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) 函数</p>
<ul>
<li>函数作用：</li>
<li><h2 id="具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration"><a href="#具体过程：-局部变量-static-u8-first-trace-MAP-SIZE-first-run-q-exec-cksum-0-use-tmout-exec-tmout-old-sn-stage-name-如果-from-queue-为-0-或者-resuming-fuzz-被置位，use-tmout-适当放大-无条件-q-cal-failed-stage-name-“calibration”-stage-max-fast-cal-3-CAL-CYCLES-在没有开启-dumb-mode，且没有开启-no-forkserver，且-forksrv-pid-为-0-的情况下，调-init-forkserver-argv-初始化-forksever-如果-q-exec-cksum-不空，将-trace-bits-拷贝到-first-trace-开始计时，写入-start-us-根据前面设置的-stage-max，执行-stage-max-轮次，做如下动作：-如果不是-first-run-，并且当前轮次-stage-cur-是-stats-update-freq-的整倍数，调-show-stats-刷新仪表盘-调-write-to-testcase-use-mem-q-len-把-测试用例-q-的数据写到输入文件-out-file-或-默认的-out-dir-cur-input（根据是否有-f-设置了-out-file）。-调-run-target-argv-use-tmout-跑起来，返回错误类型写入-fault，-如果-stop-soon-被置位，或者-fault-crash-mode，跳转到-abort-calibration-暗含以上否定，如果不是-dumb-mode，不是-stage-cur-0（第一次运行），且-count-bytes-trace-bits-0，设置-fault-FAULT-NOINST，跳转到-abort-calibration-暗含以上否定，计算-cksum-hash32-trace-bits-MAP-SIZE-HASH-CONST-，看-cksum-和-q-exec-cksum-是否相等-相等，没有操作，往下流-不等，调-as-new-bits-virgin-bits-看此次运行的收获，写入-hnb-看-q-exec-cksum-是否有值-没值，把计算出的-cksum-赋给-q-exec-cksum，把-trace-bits-拷贝到-first-trace，开始下一轮-有值，逐字节对比-first-trace-和-trace-bits-向量，如果遇到二者不同的位点，并且对应的-var-bytes-i-为-0，则将-var-bytes-i-置-1，并将-stage-max-放大到-CAL-CYCLES-LONG，开始下一轮-结束计时，写入-stop-us，计算总时间-total-cal-us-stop-us-start-us，总圈数-total-cal-cycles-stage-max-统计种子-q-的-q-exec-us，q-bitmap-size，同时更新全局-total-bitmap-size-q-bitmap-size-total-bitmap-entries-调-update-bitmap-score-q-更新-q-能到达路径的最优种子-abort-calibration" class="headerlink" title="具体过程：- 局部变量  - static u8 first_trace[MAP_SIZE]  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)  - use_tmout &#x3D; exec_tmout  - old_sn &#x3D; stage_name- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace- 开始计时，写入 start_us- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 abort_calibration    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 abort_calibration    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等      - 相等，没有操作，往下流      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb      - 看 q-&gt;exec_cksum 是否有值        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子- abort_calibration"></a>具体过程：<br>- 局部变量<br>  - static u8 first_trace[MAP_SIZE]<br>  - first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0)<br>  - use_tmout &#x3D; exec_tmout<br>  - old_sn &#x3D; stage_name<br>- 如果 from_queue 为 0 或者 resuming_fuzz 被置位，use_tmout 适当放大<br>- 无条件 q-&gt;cal_failed++; stage_name &#x3D; “calibration”; stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;<br>- 在没有开启 dumb_mode，且没有开启 no_forkserver，且 forksrv_pid 为 0 的情况下，调 init_forkserver(argv) 初始化 forksever<br>- 如果 q-&gt;exec_cksum 不空，将 trace_bits 拷贝到 first_trace<br>- 开始计时，写入 start_us<br>- 根据前面设置的 stage_max，执行 stage_max 轮次，做如下动作：<br>  - 如果不是 first_run ，并且当前轮次 stage_cur 是 stats_update_freq 的整倍数，调 show_stats() 刷新仪表盘<br>  - 调 write_to_testcase(use_mem, q-&gt;len) 把 测试用例 q 的数据写到输入文件 out_file 或 默认的 out_dir&#x2F;.cur_input（根据是否有 -f 设置了 out_file）。<br>  - 调 run_target(argv, use_tmout)  跑起来，返回错误类型写入 fault，<br>    - 如果 stop_soon 被置位，或者 fault !&#x3D; crash_mode，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，如果不是 dumb_mode，不是 stage_cur&#x3D;0（第一次运行），且 count_bytes(trace_bits)&#x3D;0，设置 fault &#x3D; FAULT_NOINST，跳转到 <strong>abort_calibration</strong><br>    - 暗含以上否定，计算 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST)，看 cksum 和 q-&gt;exec_cksum  是否相等<br>      - 相等，没有操作，往下流<br>      - 不等，调 as_new_bits(virgin_bits) 看此次运行的收获，写入 hnb<br>      - 看 q-&gt;exec_cksum 是否有值<br>        - 没值，把计算出的 cksum 赋给 q-&gt;exec_cksum，把 trace_bits 拷贝到 first_trace，开始下一轮<br>        - 有值，逐字节对比 first_trace 和 trace_bits 向量，如果遇到二者不同的位点，并且对应的 var_bytes[i] 为 0，则将 var_bytes[i] 置 1，并将 stage_max 放大到 CAL_CYCLES_LONG，开始下一轮<br>- 结束计时，写入 stop_us，计算总时间 total_cal_us +&#x3D; stop_us - start_us，总圈数 total_cal_cycles +&#x3D; stage_max<br>- 统计种子 q 的 q-&gt;exec_us，q-&gt;bitmap_size，同时更新全局 total_bitmap_size +&#x3D; q-&gt;bitmap_size; total_bitmap_entries++;<br>- 调 update_bitmap_score(q) 更新 q 能到达路径的最优种子<br>- <strong>abort_calibration</strong></h2></li>
</ul>
</li>
<li><p>static void write_to_testcase(void* mem, u32 len) 函数</p>
<ul>
<li>函数作用：把 mem 开始的 len 字节作为测试用例写默认的或特指的文件中去。</li>
<li>具体过程：<ul>
<li>如果 out_file 指定了，删除原文件，把 mem 开始的 len 字节作为测试用例写进去。如果 out_file 没指定，则写到 out_fd 里</li>
<li>如果是通过 out_fd 写，则需要截断文件，并移动文件光标。</li>
</ul>
</li>
</ul>
</li>
<li><p>has_new_bits 函数</p>
<ul>
<li>返回 2，发现新 tuples</li>
<li>返回 1，没发现新 tuples，但是命中数量增加</li>
<li>返回 0，没有任何发现</li>
</ul>
</li>
<li><p>persistent_mode</p>
<ul>
<li>“Persistent Mode”（持久模式）允许模糊测试工具在目标程序中更高效地探索执行路径。</li>
<li>可以通过以下方式启用持久模式：<ul>
<li>使用 <code>__AFL_LOOP()</code> 宏来指示循环的开始和结束。</li>
<li>使用 <code>__AFL_INIT()</code> 宏来执行一次性的初始化。</li>
<li>使用 <code>__AFL_FUZZ_TESTCASE_BUF</code> 和 <code>__AFL_FUZZ_TESTCASE_LEN</code> 宏来访问当前的测试用例数据和长度。</li>
</ul>
</li>
</ul>
</li>
<li><p>deferred_mode</p>
</li>
<li><p>afl-qemu-trace</p>
<ul>
<li><a href="https://blog.csdn.net/song_lee/article/details/105082092">https://blog.csdn.net/song_lee/article/details/105082092</a></li>
<li><a href="https://blog.csdn.net/qysh123/article/details/114792891">https://blog.csdn.net/qysh123/article/details/114792891</a></li>
<li><a href="https://airbus-seclab.github.io/AFLplusplus-blogpost/">https://airbus-seclab.github.io/AFLplusplus-blogpost/</a></li>
<li><a href="https://aflplus.plus/docs/env_variables/">https://aflplus.plus/docs/env_variables/</a></li>
<li><a href="https://afl-1.readthedocs.io/en/latest/user_guide.html">https://afl-1.readthedocs.io/en/latest/user_guide.html</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://www.haoyep.com/posts/afl-install/">https://www.haoyep.com/posts/afl-install/</a></li>
<li><a href="https://github.com/nccgroup/TriforceAFL">https://github.com/nccgroup/TriforceAFL</a></li>
<li><a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md">https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md</a></li>
</ul>
</li>
<li><p>crash_mode</p>
<ul>
<li>-C 选项代表 crash_mode &#x3D; FAULT_CRASH，仅此设置</li>
</ul>
</li>
<li><p>dumb_mode</p>
<ul>
<li>默认为 0，在有 -n 选项的情况下，如果设置了 AFL_DUMB_FORKSRV 环境变量，dumb_mode &#x3D; 2，否则 dumb_mode &#x3D; 1</li>
</ul>
</li>
<li><p>out_file</p>
<ul>
<li>-f 指定，是等待 fuzz 的测试用例</li>
</ul>
</li>
<li><p>out_fd</p>
<ul>
<li>setup_stdio_file 中被设置为指向 out_dir&#x2F;.cur_input</li>
<li>out_fd 是指向 out_file 的文件描述符？可能的机制是，out_fd 默认指向 out_dir&#x2F;.cur_input，但是当用户指定了 out_file，则 out_file 顶替了默认的 out_dir&#x2F;.cur_input 的作用。</li>
</ul>
</li>
<li><p>var_bytes[i]</p>
</li>
</ul>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL调试准备</title>
    <url>/2023/09/06/AFL%E8%B0%83%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>调试 AFL </p>
<span id="more"></span>

<ul>
<li><p>在vscode+mingw64的条件下试图调试AFL,发现缺少头文件</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906163736865.png" alt="image-20230906163736865"></p>
<p>考虑安装VS再尝试</p>
</li>
<li><p>安装vs之后仍然报头文件缺失，然后全局搜索 shm.h 文件，发现本机并没有这个文件。此时恍然大悟，AFL 可能本来就不能再win上运行，<a href="https://www.51cto.com/article/753518.html">查证</a>后果然，为此还有人开发了 win 上的 AFL 工具<a href="https://github.com/ivanfratric/winafl">WinAFL</a>。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906171407166.png" alt="image-20230906171407166"></p>
</li>
<li><p>那么现在的方案有两个</p>
<ul>
<li>在 mac 上调试</li>
<li>在 linux 上直接 gdb 调试。或者 gdb + vscode 可视化调试</li>
</ul>
</li>
</ul>
<p>首先尝试第二种方案：</p>
<ul>
<li><p>读懂 Makefile 文件，给出 -g 编译选项，方便调试。</p>
</li>
<li><p>研究之后发现本来的 Makefile 中编译选项已经包含了 -g 所以都可以直接调试。</p>
</li>
<li><p>下一步思考怎么搭建一个双机调试环境？</p>
</li>
<li><p>退一步学习一下怎么样使用gdb调试。</p>
</li>
<li><p>先进行一个小的实验：<a href="https://xz.aliyun.com/t/4314">初探AFL-Fuzz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插桩编译</span></span><br><span class="line">afl-gcc -g -o test test.c</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模糊测试</span></span><br><span class="line">afl-fuzz -i input_dir -o output_dir program</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始使用GDB调试AFL</p>
<ul>
<li><a href="https://www.cnblogs.com/suphgcm/p/15498577.html">GDB cheetsheet</a></li>
<li><a href="https://wenku.baidu.com/view/30c4cfbfcf22bcd126fff705cc17552707225e0f.html?_wkts_=1694057567582&bdQuery=gdb+cheetsheet">cheet sheet</a></li>
<li><a href="https://blog.csdn.net/wxh0000mm/article/details/108582238">gdb速查表</a></li>
<li><a href="https://github.com/yimaginer/awesome-cheatsheets/blob/master/tools/gdb.txt">awesome-cheetsheet</a></li>
</ul>
</li>
</ul>
<p>记录调试过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动调试</span></span><br><span class="line">gdb --args afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GDB 前端</span></span><br><span class="line">ctrl-x ctrl-a 更换 CLI/TUI</span><br></pre></td></tr></table></figure>

<p>遇到的问题：<br><a href="http://www.taodudu.cc/news/show-5082273.html?action=onClick">GDB调试显示＜ optimized_out ＞</a></p>
]]></content>
      <tags>
        <tag>AFL</tag>
        <tag>Fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>STL详细梳理</title>
    <url>/2024/09/05/STL%E8%AF%A6%E7%BB%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="STL-container"><a href="#STL-container" class="headerlink" title="STL-container"></a>STL-container</h1><span id="more"></span>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,5&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>,5&gt; <span class="title">c</span><span class="params">(c2)</span></span>;		<span class="comment">// 必须类型大小都一样</span></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = c2;</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = initlist</span><br><span class="line"></span><br><span class="line">array&lt;<span class="type">int</span>,<span class="number">5</span>&gt; <span class="built_in">c</span>(rv);</span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; c = rv;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Int 可以扩充为：</p>
<ol>
<li>float bool ull struct class string 等基础类型</li>
<li>vector array deque list forward_list set map 等容器</li>
</ol>
</blockquote>
<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();</span><br><span class="line">c1 == c2		<span class="comment">// 只有类型大小相同才有比较的资格,数据全相同才为 true</span></span><br><span class="line">c1 != c2</span><br><span class="line">c1 &lt; c2			<span class="comment">// 字典序比较</span></span><br></pre></td></tr></table></figure>

<p>  赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">fill</span>(val)</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2)	<span class="comment">// 置换c1和c2</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2)	<span class="comment">// 类型大小相同才可以swap</span></span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);</span><br><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.back;</span><br></pre></td></tr></table></figure>

<p>八大迭代器：</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; c </span>= c2;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;			<span class="comment">// 开一个 size 为 n 的 vector，使用默认构造填充每个元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,val)</span></span>;	<span class="comment">// 以 n 个 val 填充 c</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c<span class="number">2.</span>beg,c<span class="number">2.</span>end)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">capacity</span>();</span><br><span class="line">c.<span class="built_in">reserve</span>(num);		<span class="comment">// 针对 c 的 capacity 属性</span></span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>()	<span class="comment">// 针对 c 的 capacity 属性,执行后不一定 c.size() == c.capacity()</span></span><br><span class="line">c.<span class="built_in">max_size</span>();	<span class="comment">// 系统的属性</span></span><br><span class="line">c.<span class="built_in">date</span>();	<span class="comment">// 数组起始位置</span></span><br><span class="line">== != &lt; &gt; &lt;= &gt;= 	<span class="comment">// 六种比较全支持，先比 size，再按字符串比较方法比元素</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有赋值都是将新元素赋值给 vector 并将旧元素删除</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);	<span class="comment">// 二者管理的内容（data,size,cap）交换，相当于二者交换名字，也相当于相互借壳上市</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.<span class="built_in">at</span>(idx);	<span class="comment">// 四个中只有 at 具有安全性检查，其余访问前要手动保证位置可访问</span></span><br><span class="line">c.<span class="built_in">front</span>();	</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">beg，end，cbeg，cend，rbeg，rend，crbeg，crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();	<span class="comment">// 程序员手动保证容器不空</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);	<span class="comment">// pos 之前插入 elem， 并返回新元素位置</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos, initlist);</span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...)	<span class="comment">// 在 pos 之前插入以 arg 为初值的元素,返回第一个新元素位置</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...)	<span class="comment">// 末尾插入以 arg 为初值的元素，无返回值</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);	<span class="comment">// 删除 [beg end) 区间内元素</span></span><br><span class="line">c.<span class="built_in">clear</span>();	<span class="comment">// 清空</span></span><br><span class="line">c.<span class="built_in">resize</span>(num);	<span class="comment">// 如果 size 变大，多出来的元素用默认构造填充</span></span><br><span class="line">c.<span class="built_in">resize</span>(num,elem);	<span class="comment">// 如果 size 变大，多出来的用 elem 拷贝填充</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove</span>(beg,end,val)	<span class="comment">// 	实质是把非 val 元素前移，size 并未改变</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有了 insert， vector 不局限于在尾部增加元素，可以在任意位置添加任意个数的元素，但是可以是一回事，并不擅长，因为复杂度原因。</li>
<li>insert emplace 的所有 pos，都需要是迭代器，而不能是 int 值（这很好理解，迭代器要么是pointer，要么是类，无论哪种都不是一个 int 可以替代的）</li>
<li>pos 的值可以由算法计算出，结合 insert 可以实现很多功能：<ol>
<li>vector 没有提供删除指定值功能，但是可以搭配算法实现这个功能：c.erase(remove(c.begin(),c.end(),val),c.end());</li>
<li>在 val1 前插入val2 c.insert(find(c.begin(),c.end(),val1),val2)</li>
</ol>
</li>
<li>删除第一个值为 val 的元素：auto pos &#x3D; find(c.begin(),c.end(),val); if(pos !&#x3D; c.end()) v.erase(pos);</li>
</ol>
</blockquote>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><blockquote>
<p>几乎和 vector 一模一样，除了</p>
<ol>
<li>不支持容量操作，reserve(), capcity()</li>
<li>安插和移除可以在头部进行</li>
</ol>
</blockquote>
<p>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dequeue&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(deg,end)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;	<span class="comment">// 以下所有接口都是整体赋值，所以大多数情况适用于算法开始前初始化</span></span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem); </span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);	<span class="comment">// 交换内容</span></span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c[idx];</span><br><span class="line">c.at(idx);</span><br><span class="line">c.front();</span><br><span class="line">c.back();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beg,end,cbeg,cend,rbeg,rend,crbeg,crend</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">c.<span class="built_in">resize</span>(n,num);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 原地构建一个 string 类</span></span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &lt; &gt; &lt;= &gt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br><span class="line">c.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b,e,cb,ce,rb,re,crb,cre</span><br><span class="line"><span class="comment">// 经过实验，list 的迭代器支持了 ++ -- 操作，但是不支持直接 + - 操作(包括加减 int， 以及迭代器之间加减)，意味着 list 的诸如 c.insert(pos,elem); 中 pos 的定位只能从 front 或者 end 航行过去，想来也是合理</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_back</span>();</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line">c.<span class="built_in">push_front</span>();</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_back</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的 remove 总是好于算法中提供的 remove</span></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op); <span class="comment">// c.remove([](int i)&#123; return i % 2 == 0;&#125;); 删除偶数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// accumulate(beg,end,0);</span></span><br><span class="line"><span class="comment">// transform(a.beg,a.end,b.beg,negate&lt;int&gt;());</span></span><br></pre></td></tr></table></figure>

<p>List 特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();		<span class="comment">// 相邻而数值相同留一个,所以要想实现真正的单一化，要先排序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2);	<span class="comment">// 整个 c2 放在 pos 之前</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2pos)	<span class="comment">// c2 的 c2pos 位置元素放在 c 的 pos 位置，c和c2可以相同</span></span><br><span class="line">c.<span class="built_in">splice</span>(pos,c2,c2beg,c2end)	<span class="comment">// c2 的 [c2beg,c2end) 区间元素放在 pos 位置，c和c2可以相同</span></span><br><span class="line"> </span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前题是 c 和 c2 均有序</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure>

<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n,elem)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = initlist;</span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">c.<span class="built_in">data</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br><span class="line">  <span class="comment">// 没有 size，可行的方案是 distance(c.begin(),c.end())</span></span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c.<span class="built_in">assign</span>(n.elem);</span><br><span class="line">c.<span class="built_in">assign</span>(beg,end);</span><br><span class="line">c.<span class="built_in">assign</span>(initlist);</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">四个正向迭代器：b,e,cb,ce</span><br><span class="line">额外两个： <span class="built_in">before_begin</span>(),<span class="built_in">before_end</span>(); <span class="comment">// 不要试图解引用这两个迭代器，仅限于后缀为 after 的借口使用</span></span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">push_front</span>(elem);</span><br><span class="line">c.<span class="built_in">pop_front</span>();</span><br><span class="line">  </span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,n,elem);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,beg,end);</span><br><span class="line">c.<span class="built_in">insert_after</span>(pos,initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace_after</span>(pos,args...);</span><br><span class="line">c.<span class="built_in">emplace_front</span>(args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase_after</span>(pos);</span><br><span class="line">c.<span class="built_in">erase_after</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">r.<span class="built_in">resize</span>(num);</span><br><span class="line">r.<span class="built_in">resize</span>(num,elem);</span><br></pre></td></tr></table></figure>

<p>list特殊更易性操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">unique</span>();	<span class="comment">// 前提是有序</span></span><br><span class="line">c.<span class="built_in">unique</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2pos);</span><br><span class="line">c.<span class="built_in">splice_after</span>(pos,c2,c2beg,c2end);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">sort</span>();</span><br><span class="line">c.<span class="built_in">sort</span>(op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">merge</span>(c2);	<span class="comment">// 前提是有序，c2 归入 c</span></span><br><span class="line">c.<span class="built_in">merge</span>(c2,op);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">remove</span>(val);</span><br><span class="line">c.<span class="built_in">remove_if</span>(op);</span><br><span class="line">c.<span class="built_in">reverse</span>();</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;	<span class="comment">// set&lt;int,greater&lt;int&gt;&gt; coll;</span></span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(c2)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = c2;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = rv;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;	<span class="comment">// 可接受不同类型容器元素</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; c = initlist;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">不支持随机，通常使用 range-base <span class="keyword">for</span> 或 迭代器</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器(关联式容器都是)</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>();</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>set 特殊查找函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val);</span><br><span class="line">c.<span class="built_in">find</span>(val);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">lower_bound</span>(val);</span><br><span class="line">c.<span class="built_in">upper_bound</span>(val);</span><br><span class="line">c.<span class="built_in">equal_bound</span>(val);</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; c;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = initlist;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = <span class="built_in">c</span>(c2);</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = c2;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(beg,end,op)</span></span>;</span><br><span class="line"><span class="function">map&lt;string,<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; c = rv;</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key];</span><br><span class="line">c.<span class="built_in">at</span>(key);</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器</span><br></pre></td></tr></table></figure>

<p>安插和移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(key);</span><br><span class="line">c.<span class="built_in">erase</span>(pos);</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end);</span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 	由于元素是 key/val pair 因此元素插入略显复杂</span></span><br><span class="line">	c.<span class="built_in">insert</span>(&#123;<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>&#125;);</span><br><span class="line">	c.<span class="built_in">insert</span>(map&lt;string,<span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>))</span><br><span class="line">  c.<span class="built_in">insert</span>(<span class="keyword">decltype</span>(c)::<span class="built_in">value_type</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">const</span> string,<span class="type">int</span>&gt;(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line">	c.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;onto&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// for_each(beg,end,op)</span></span><br><span class="line"><span class="comment">// find_if(beg,end,op)</span></span><br></pre></td></tr></table></figure>

<p>map特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(key)</span><br><span class="line">c.<span class="built_in">find</span>(key)</span><br><span class="line">c.<span class="built_in">lower_bound</span>(key)</span><br><span class="line">c.<span class="built_in">upper_bound</span>(key)</span><br><span class="line">c.<span class="built_in">equal_bound</span>(key)</span><br></pre></td></tr></table></figure>

<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Unord c;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(initlist)</span></span>;</span><br><span class="line">Unord c = initlist;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf)</span></span>;</span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(beg,end,bnum,hf,cmp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Unord <span class="title">c</span><span class="params">(rv)</span></span>;</span><br><span class="line">Unord c = rv;</span><br></pre></td></tr></table></figure>

<p>布局操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">hash_function</span>();</span><br><span class="line">c.<span class="built_in">key_eq</span>();</span><br><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_bucket_count</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>();</span><br><span class="line">c.<span class="built_in">max_load_factor</span>(val);</span><br><span class="line">c.<span class="built_in">rehash</span>(bnum);</span><br><span class="line">c.<span class="built_in">reserve</span>(bnum);</span><br></pre></td></tr></table></figure>

<p>非更易操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();</span><br><span class="line"></span><br><span class="line">c1 == c2;</span><br><span class="line">c1 != c2;</span><br></pre></td></tr></table></figure>

<p>赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = c2;</span><br><span class="line">c = rv;</span><br><span class="line">c = initlist;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line"><span class="built_in">swap</span>(c1,c2);</span><br></pre></td></tr></table></figure>

<p>元素访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c[key]</span><br><span class="line">c.<span class="built_in">at</span>(key)</span><br></pre></td></tr></table></figure>

<p>迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">八大迭代器，但是只支持 forward interator，不支持 bidirection interator 或 random-access interator</span><br></pre></td></tr></table></figure>

<p>安插和移除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>(val);</span><br><span class="line">c.<span class="built_in">insert</span>(pos,val);</span><br><span class="line">c.<span class="built_in">insert</span>(beg,end);</span><br><span class="line">c.<span class="built_in">insert</span>(initlist);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace</span>(args...);</span><br><span class="line">c.<span class="built_in">emplace_hint</span>(pos,args...);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(val);		<span class="comment">// 移除所有 与val相等 的元素，返回移除个数</span></span><br><span class="line">c.<span class="built_in">erase</span>(pos);		<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">erase</span>(beg,end)<span class="comment">// 无返回值</span></span><br><span class="line">c.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>无序容器特殊查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">count</span>(val)</span><br><span class="line">c.<span class="built_in">find</span>(val)	<span class="comment">// 若想指定 pred 只能用 find_if()</span></span><br><span class="line">c.<span class="built_in">equal_bound</span>(val)</span><br></pre></td></tr></table></figure>

<p>bucket 接口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">bucket_count</span>();</span><br><span class="line">c.<span class="built_in">bucket</span>();</span><br><span class="line">c.<span class="built_in">bucket_size</span>();</span><br><span class="line">c.<span class="built_in">begin</span>(buckidx);</span><br><span class="line">c.<span class="built_in">end</span>(buckidx);</span><br><span class="line">c.<span class="built_in">cbegin</span>(bucketidx);</span><br><span class="line">c.<span class="built_in">cend</span>(bucketidx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform()</span></span><br></pre></td></tr></table></figure>

<p>STL延伸</p>
<ul>
<li>以上介绍皆为标准容器，可以利用容器思想扩充类，一般有以下扩充方向<ul>
<li>Intrusive, 侵入式。直接提供STL所需接口，如begin，end。典型的如 string 类</li>
<li>nonintrusive，非侵入式。提供特殊迭代器，作为算法和容器接口。如 array 中，begin(val) 获得其迭代器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>LibAFL入门</title>
    <url>/2024/06/15/LibAFL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>原文地址：<a href="https://www.atredis.com/blog/2023/12/4/a-libafl-introductory-workshop">LibAFL Introductory workshop — Atredis Partners</a></p>
<p>来自一家很酷的公司：<a href="https://www.atredis.com/careers">Careers — Atredis Partners</a></p>
<hr>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么选择-LibAFL"><a href="#为什么选择-LibAFL" class="headerlink" title="为什么选择 LibAFL"></a>为什么选择 LibAFL</h2><p>Fuzzing（模糊测试）非常棒！在正确的设置下，快速地向目标投掷随机输入可以产生不合理的效果。当开始一个新的目标时，模糊测试的框架可以与你的逆向工程&#x2F;审计工作一起迭代，你可以安心地睡觉，知道你的核心在夜间值班。在寻找漏洞时，我们的时间通常是有限的；任何花在工具上的努力都需要是值得的。LibAFL 是一个很棒的库，可以让我们快速地将模糊测试器适应我们的特定目标。并不是每个目标都适合“解析文件的命令行程序”类别，因此 LibAFL 让我们为特定情况制作模糊测试器。这种适应性为更广泛的目标打开了模糊测试的力量。</p>
<h2 id="为什么举办研讨会"><a href="#为什么举办研讨会" class="headerlink" title="为什么举办研讨会"></a>为什么举办研讨会</h2><p>以下材料来自一个内部研讨会，用作对 LibAFL 的介绍。这篇文章是对研讨会的总结，并包括一个练习和示例的仓库，供你在家跟随。它期望你已经有一些 Rust 和模糊测试概念的理解。（如果你需要复习 Rust：Google 的全面 Rust 是很棒的。）</p>
<p>已经有一些很好的资源可以学习 LibAFL。</p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>这个研讨会旨在增加用 LibAFL 构建的示例模糊测试器的现有语料库，重点是将模糊测试器定制到我们的目标。你还会找到一些入门问题，以便你亲手体验 LibAFL。在整个研讨会中，我们尝试突出库的多功能性和力量，让你看看你可以在哪里将模糊测试器融入你的流程。</p>
<h2 id="课程预告"><a href="#课程预告" class="headerlink" title="课程预告"></a>课程预告</h2><p>顺便说一句，如果你对这类事情（安全工具、漏洞、模糊测试）感兴趣，你可能会对我们的符号执行课程感兴趣。我们计划在 2024 年 2 月与 ringzer0 举行一次虚拟会议。本文末尾有更多信息。</p>
<h2 id="模糊测试器"><a href="#模糊测试器" class="headerlink" title="模糊测试器"></a>模糊测试器</h2><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在整个研讨会中，我们一直在测试一个在 Linux 上运行的简单目标。这个目标本身并不是很有趣，但作为我们模糊测试器的一个很好的示例目标。它逐行接收一些文本，并替换某些标识符（如 <code>&#123;&#123;XXd3sMRBIGGGz5b2&#125;&#125;</code>）为名称。为此，它包含一个具有非常大查找树的函数。在这个函数中，许多查找情况可能导致段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">uid_to_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* uid)</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span> <span class="comment">// 大量的嵌套 switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (nbuf[<span class="number">14</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="comment">// 常规情况，没有段错误</span></span><br><span class="line">        addr = &amp;names[<span class="number">0x4b9</span>];</span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">        <span class="comment">// 一个坏情况</span></span><br><span class="line">        addr = ((<span class="type">const</span> <span class="type">char</span>**)<span class="number">0x68c2</span>);</span><br><span class="line">        <span class="comment">// 这里 SEGFAULT</span></span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>

<p>这为我们提供了一个目标，它有许多不同的代码路径，并且有许多可达到的“漏洞”可以发现。随着我们的进展，我们将适应我们的模糊测试器到这个目标，展示一些常见的方法，我们可以使用 LibAFL 将模糊测试器塑造成一个目标。</p>
<p>你可以在这里找到我们的目标，并且仓库包括一些稍后示例中有用的变体。<a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target.c">.&#x2F;fuzz_target&#x2F;target.c</a></p>
<h2 id="模糊测试器的组成部分"><a href="#模糊测试器的组成部分" class="headerlink" title="模糊测试器的组成部分"></a>模糊测试器的组成部分</h2><p>在我们深入示例之前，让我们快速了解一下现代模糊测试器的内部结构。LibAFL 将模糊测试器分解为可以互换或更改的部分。LibAFL 充分利用了 <a href="https://google.github.io/comprehensive-rust/methods-and-traits/traits.html">Rust 的特性系统</a>来做到这一点。下面我们有一个非常简单的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器的脚本可能像下面这样简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ! [ -f ./core.* ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">head</span> -c 900 /dev/urandom &gt; ./testfile</span><br><span class="line">    <span class="built_in">cat</span> ./testfile | ./target</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上面的简单模糊测试器遵循三个核心步骤。</p>
<ol>
<li>生成一个随机输入</li>
<li>使用新输入运行目标</li>
<li>如果创建的输入导致“胜利”（在这种情况下，胜利是产生核心文件的崩溃），则保留该输入</li>
</ol>
<p>如果你错过了上述任何部分，你将不会有一个非常好的模糊测试器。我们都听说过研究人员将随机输入管道到他们的目标，得到了一个令人兴奋的崩溃，但因为他们没有保存测试用例，所以再也无法重现该漏洞的悲惨故事。</p>
<p>即使有了上述部分，那个简单的模糊测试器也会在发现漏洞方面挣扎。它甚至没有进展的概念！下面我们有一个更现代的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器基于一组现有的输入，这些输入被随机变异以创建新的测试用例。“变异”只是一组可以快速应用于输入的简单修改，以生成新的有趣的输入。重要的是，这个模糊测试器还使用执行目标的观察结果来知道输入是否“有趣”。与仅关心崩溃的模糊测试器不同，具有反馈的模糊测试器可以将变异的测试用例重新路由到要变异的输入集中。这允许模糊测试器通过迭代输入，跟踪目标中有趣的功能来取得进展。</p>
<p>LibAFL 为这些“部分”中的每一个提供了工具。</p>
<ul>
<li>实现 <code>Executor</code> 特性的将使用给定的测试用例运行目标。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html">https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html</a></li>
</ul>
</li>
<li><code>Corpus</code> 特性是用于保存一组测试用例的项目，通常用于输入或解决方案。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html">https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html</a></li>
</ul>
</li>
<li>实现 <code>Scheduler</code> 特性的东西负责从语料库中选择输入以制作下一个测试用例。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html">https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html</a></li>
</ul>
</li>
<li>实现 <code>Mutator</code> 特性的提供在运行前更改输入的修改。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html">https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html</a></li>
</ul>
</li>
<li><code>Feedback</code> 和 <code>Observer</code> 特性提供了有用的工具，用于决定输入是否有用。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html">https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html</a></li>
<li><a href="https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html">https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html</a></li>
</ul>
</li>
</ul>
<p>我们还将看到其他重要的特性。一定要查看特性文档中的“实现者”部分，看看库提供的有用实现。</p>
<h2 id="Exec-模糊测试器"><a href="#Exec-模糊测试器" class="headerlink" title="Exec 模糊测试器"></a>Exec 模糊测试器</h2><p>这就带我们来到了我们的第一个示例！让我们通过使用 LibAFL 的一个基本模糊测试器来逐步了解。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer/src/main.rs">.&#x2F;exec_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>源代码有详细的注释，你应该仔细阅读。这里我们只突出一些关键部分。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = CommandExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = StdState::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            StdRand::<span class="title function_ invoke__">with_seed</span>(<span class="title function_ invoke__">current_nanos</span>()),</span><br><span class="line">            InMemoryCorpus::&lt;BytesInput&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            OnDiskCorpus::<span class="title function_ invoke__">new</span>(PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;./solutions&quot;</span>)).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            &amp;<span class="keyword">mut</span> feedback,</span><br><span class="line">            &amp;<span class="keyword">mut</span> objective,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>我们的模糊测试器使用一个“状态”对象，该对象跟踪输入测试用例的集合、任何解决方案测试用例以及其他元数据。注意我们选择将输入保存在内存中，但将解决方案测试用例保存到磁盘上。</p>
<p>我们使用 <code>CommandExecutor</code> 来执行我们的目标程序，它将运行目标进程并传入测试用例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            <span class="title function_ invoke__">havoc_mutations</span>(),</span><br><span class="line">            <span class="number">9</span>,                 <span class="comment">// 最大变异迭代次数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stages</span> = tuple_list!(StdMutationalStage::<span class="title function_ invoke__">new</span>(mutator));</span><br></pre></td></tr></table></figure>

<p>我们为输入构建了一个非常简单的管道。这个管道只有一个阶段，它将为每个测试用例随机选择一组变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">scheduler</span> = RandScheduler::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fuzzer</span> = StdFuzzer::<span class="title function_ invoke__">new</span>(scheduler, feedback, objective);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载我们状态中的初始语料库</span></span><br><span class="line">        <span class="comment">// 由于我们在这个模糊测试器中缺乏反馈，我们必须强制执行</span></span><br><span class="line">        state.<span class="title function_ invoke__">load_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> mgr, &amp;[PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;../fuzz_target/corpus/&quot;</span>)]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊测试</span></span><br><span class="line">        fuzzer.<span class="title function_ invoke__">fuzz_loop</span>(&amp;<span class="keyword">mut</span> stages, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> state, &amp;<span class="keyword">mut</span> mgr).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error in fuzz loop&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过一个调度器和一些反馈（这里我们使用 <code>ConstFeedback::False</code> 来没有任何反馈，除了目标反馈，这是一个 <code>CrashFeedback</code>），我们可以加载我们的初始条目并开始模糊测试。我们使用创建的阶段、选择的执行器、状态和一个事件管理器来开始模糊测试。我们的事件管理器将让我们知道当我们开始获得“胜利”时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan exec_fuzzer]$ ./target/release/exec_fuzzer/</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 3, objectives: 0, executions: 3, exec/sec: 0.000</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 3, objectives: 1, executions: 3, exec/sec: 2.932</span><br><span class="line">[Stats #0] run time: 0h-0m-15s, clients: 1, corpus: 3, objectives: 1, executions: 38863, exec/sec: 2.590k</span><br><span class="line">[Objective #0] run time: 0h-0m-20s, clients: 1, corpus: 3, objectives: 2, executions: 38863, exec/sec: 1.885k</span><br></pre></td></tr></table></figure>

<p>我们脆弱的目标很快就开始给我们崩溃，即使没有反馈。从一组有用的输入开始有助于我们的变异能够找到崩溃的输入。</p>
<p>这个简单的执行模糊测试器为我们提供了一个良好的基础，我们可以在此基础上添加更多功能。</p>
<h2 id="带自定义反馈的-Exec-模糊测试器"><a href="#带自定义反馈的-Exec-模糊测试器" class="headerlink" title="带自定义反馈的 Exec 模糊测试器"></a>带自定义反馈的 Exec 模糊测试器</h2><p>没有反馈，我们就不能有效地迭代有趣的输入。目前我们的随机变异必须一次性生成一个崩溃的案例。如果我们能向模糊测试器添加反馈，那么我们就可以识别出做了一些有趣事情的测试用例。我们将这些有趣的测试用例循环回我们的测试用例集中，进行进一步的变异。</p>
<p>我们可以从许多不同的来源获取这些信息。对于这个示例，让我们使用 <code>fuzz_target/target_dbg</code> 二进制文件，这是我们目标的调试输出版本。通过查看这个调试输出，我们可以开始识别有趣的案例。如果一个测试用例让我们得到了我们之前没有见过的调试输出，那么我们可以认为它是有趣的，值得进一步迭代。</p>
<p>LibAFL 库中没有这种反馈的现有实现，所以我们必须自己制作！如果你想自己尝试，我们在仓库中提供了一个模板文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/exec_fuzzer_stderr_template">.&#x2F;exec_fuzzer_stderr_template&#x2F;</a></p>
<p>LibAFL 仓库提供了一个 <code>StdErrObserver</code> 结构，我们可以将其与我们的 <code>CommandExecutor</code> 一起使用。这个观察者将允许我们的自定义反馈结构接收我们运行的 <code>stderr</code> 输出。我们所要做的就是创建一个实现 <code>Feedback</code> 特性的 <code>is_interesting</code> 方法的结构，我们就应该可以开始了。在该方法中，我们提供了状态、变异输入、观察者。我们只需要从 StdErrObserver 获取调试输出，并确定我们是否到达了新的位置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Feedback&lt;S&gt; <span class="keyword">for</span> <span class="title class_">NewOutputFeedback</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: UsesInput + HasClientPerfMonitor,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">        _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">        _input: &amp;S::Input,</span><br><span class="line">        observers: &amp;OT,</span><br><span class="line">        _exit_kind: &amp;ExitKind</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">        OT: ObserversTuple&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 Ok(false) 对于不有趣的输入</span></span><br><span class="line">        <span class="comment">// 返回 Ok(true) 对于有趣的输入</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我鼓励你自己尝试实现这个反馈。你可能想要找到一些启发式方法来忽略无帮助的调试消息。我们希望避免报告太多的输入作为有用的，这样我们就不会过度填充我们的输入语料库。输入语料库是我们用于生成新测试用例的输入集。如果语料库中有太多实际上并没有帮助我们挖掘胜利的输入，我们将浪费大量时间。理想情况下，我们希望这些输入尽可能小且运行速度快，同时在我们的目标中执行独特的路径。</p>
<p>在我们的解决方案中，我们简单地保持一组已看到的哈希。如果我们看到它导致了一个独特的哈希，我们就会报告输入是有趣的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer_stderr/src/main.rs">.&#x2F;exec_fuzzer_stderr&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">            _input: &amp;S::Input,</span><br><span class="line">            observers: &amp;OT,</span><br><span class="line">            _exit_kind: &amp;ExitKind</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">           <span class="keyword">where</span> EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">                 OT: ObserversTuple&lt;S&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">observer</span> = observers.match_name::&lt;StdErrObserver&gt;(&amp;<span class="keyword">self</span>.observer_name)</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;A NewOutputFeedback needs a StdErrObserver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            hasher.<span class="title function_ invoke__">write</span>(&amp;observer.stderr.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">contains</span>(&amp;hash) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">insert</span>(hash);</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这最终非常快地找到了“有趣”的输入，并迅速增加了我们的输入语料库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 308, objectives: 0, executions: 4388, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 0, executions: 4423, exec/sec: 2.520k</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 1, executions: 4423, exec/sec: 2.497k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 310, objectives: 1, executions: 4532, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 311, objectives: 1, executions: 4629, exec/sec: 2.521k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率反馈"><a href="#代码覆盖率反馈" class="headerlink" title="代码覆盖率反馈"></a>代码覆盖率反馈</h2><p>依赖程序的正常副作用（如调试输出、系统交互等）并不是深入探索目标的可靠方法。使用这种反馈，我们可能会错过许多有趣的特性。许多现代模糊测试器的首选反馈是“代码覆盖率”。通过观察哪些代码块正在被执行，我们可以了解哪些输入暴露了有趣的逻辑。</p>
<p>然而，收集这些信息并不总是直接的。如果你可以访问源代码，你可能可以使用编译器来为代码添加这些信息。如果没有，你可能必须通过二进制修改、仿真或其他来源动态地为你的目标添加工具。</p>
<p>AFL++ 提供了一个版本的 clang，用于编译器级别的工具，提供代码覆盖率反馈。LibAFL 可以观察这种工具生成的信息，我们可以使用它作为反馈。我们有一个使用 <code>afl-clang-fast</code> 构建的目标。有了这个构建（ <code>target_instrumented</code>），我们可以使用 LibAFL 的 <code>ForkserverExecutor</code> 与我们的工具目标进行通信。<code>HitcountsMapObserver</code> 可以使用共享内存来接收每次运行的覆盖率信息。</p>
<p>你可以在这里看到我们模糊测试器的代码。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_fuzzer/src/main.rs">.&#x2F;aflcc_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem_provider</span> = UnixShMemProvider::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem</span> = shmem_provider.<span class="title function_ invoke__">new_shmem</span>(MAP_SIZE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// 将 id 写入环境变量以供 forkserver 使用</span></span><br><span class="line">        shmem.<span class="title function_ invoke__">write_to_env</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shmembuf</span> = shmem.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line">        <span class="comment">// 基于该缓冲区构建观察者，与目标共享</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">edges_observer</span> = <span class="keyword">unsafe</span> &#123;HitcountsMapObserver::<span class="title function_ invoke__">new</span>(StdMapObserver::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shared_mem&quot;</span>, shmembuf))&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用观察到的覆盖率来反馈基于获得最大覆盖率</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">feedback</span> = MaxMapFeedback::<span class="title function_ invoke__">tracking</span>(&amp;edges_observer, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 这次我们可以使用 fork 服务器执行器，它使用 instrumented in fork server</span></span><br><span class="line">    <span class="comment">// 它通过分叉部分实例化的过程而不是每次从头开始，从而获得更多的每秒执行次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_instrumented&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">        .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>编译的 fork 服务器还应该减少我们需要实例化运行的时间，通过分叉部分实例化的过程而不是从头开始。这应该抵消我们工具的一些成本。</p>
<p>执行时，我们的模糊测试器迅速找到了新的过程路径，建立了我们有趣的案例语料库，并指导我们的模糊测试器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan aflcc_fuzzer]$ ./target/release/aflcc_fuzzer</span><br><span class="line"></span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 0, executions: 19152, exec/sec: 1.823k</span><br><span class="line">[Objective #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.762k</span><br><span class="line">[Stats #0] run time: 0h-0m-11s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.723k</span><br><span class="line">[Testcase #0] run time: 0h-0m-11s, clients: 1, corpus: 101, objectives: 1, executions: 20250, exec/sec: 1.821k</span><br></pre></td></tr></table></figure>

<h2 id="自定义变异"><a href="#自定义变异" class="headerlink" title="自定义变异"></a>自定义变异</h2><p>到目前为止，我们一直在使用 <code>havoc_mutations</code>，你可以看到这里是一组对许多目标都非常好的变异。</p>
<p><a href="https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296">https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296</a></p>
<p>这些变异中的许多对我们的目标来说是浪费的。为了到达易受攻击的 <code>uid_to_name</code> 函数，输入首先必须通过 <code>valid_uid</code> 检查。在这个检查中，范围之外的字符 <code>A-Za-z0-9\-_</code> 被拒绝。许多 <code>havoc_mutations</code>，例如 <code>BytesRandInsertMutator</code>，将引入不在该范围内的字符。这导致许多测试用例被浪费。</p>
<p>有了关于我们目标的这些知识，我们可以使用一个自定义变异器，它只会在所需的范围内插入新的字节。实现 <code>Mutator</code> 特性很简单，我们只需要提供一个 <code>mutate</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;I, S&gt; Mutator&lt;I, S&gt; <span class="keyword">for</span> <span class="title class_">AlphaByteSwapMutator</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        I: HasBytesVec,</span><br><span class="line">        S: HasRand,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                return Ok(MutationResult::Mutated) when you mutate the input</span></span><br><span class="line"><span class="comment">                or Ok(MutationResult::Skipped) when you don&#x27;t</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想自己尝试这个，欢迎使用 <code>aflcc_custom_mut_template</code> 作为起点。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_mut_template/">.&#x2F;aflcc_custom_mut_template&#x2F;</a></p>
<p>在我们的解决方案中，我们使用一组变异器，包括我们的新 <code>AlphaByteSwapMutator</code> 和一些现有的变异器。这个集合应该会产生更多的有效测试用例，使其到达 <code>uid_to_name</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们将指定我们的自定义变异器，以及另外两个有助于增长或缩小的变异器</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            tuple_list!(</span><br><span class="line">                AlphaByteSwapMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesDeleteMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesInsertMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            ),</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>然后在我们的变异器中，我们使用状态的随机源来选择位置，并从一组有效字符中选择一个新的字节。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里我们应用我们的随机变异</span></span><br><span class="line">            <span class="comment">// 对于我们的目标，简单地交换一个字节应该是有效的</span></span><br><span class="line">            <span class="comment">// 只要我们的新字节是 0-9A-Za-z 或 &#x27;-&#x27; 或 &#x27;_&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空输入</span></span><br><span class="line">            <span class="keyword">if</span> input.<span class="title function_ invoke__">bytes</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择一个随机字节</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte</span>: &amp;<span class="keyword">mut</span> <span class="type">u8</span> = state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(input.<span class="title function_ invoke__">bytes_mut</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不要替换标签字符 &#x27;&#123;&#123;&#125;&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> *byte == <span class="string">b&#x27;&#123;&#x27;</span> || *byte == <span class="string">b&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在我们可以将该字节替换为一个已知好的字节</span></span><br><span class="line">            *byte = *state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(&amp;<span class="keyword">self</span>.good_bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 技术上我们应该说“跳过”如果我们用它自己替换一个字节，但这现在没问题</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Mutated)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>就是这样！自定义变异器与系统的其余部分无缝协作。能够像这样快速调整模糊测试器是适应目标的好方法。结合性能测量，这样的实验可以帮助我们快速迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 76, objectives: 1, executions: 2339, exec/sec: 1.895k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.933k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.928k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 78, objectives: 1, executions: 2392, exec/sec: 1.933k</span><br></pre></td></tr></table></figure>

<h2 id="示例问题"><a href="#示例问题" class="headerlink" title="示例问题"></a>示例问题</h2><p>到这一点，我们有一个单独的目标，你可能想要尝试！它是一个包含一个小迷宫的程序，并给你一个机会创建一个模糊测试器，使用一些自定义反馈或变异来更好地遍历迷宫并发现崩溃。尝试我们在这里介绍的一些概念，并看看你的模糊测试器有多快可以解决迷宫。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/maze_target/">.&#x2F;maze_target&#x2F;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[jordan maze_target]$ ./maze -p</span><br><span class="line"></span><br><span class="line">██████████████</span><br><span class="line">█.██......█ ██</span><br><span class="line">█....██ █.☺  █</span><br><span class="line">██████  █ ██ █</span><br><span class="line">██   ██████  █</span><br><span class="line">█  █  █     ██</span><br><span class="line">█ ███   ██████</span><br><span class="line">█  ███ ██   ██</span><br><span class="line">██   ███  █  █</span><br><span class="line">████ ██  ███ █</span><br><span class="line">█    █  ██ █ █</span><br><span class="line">█ ████ ███ █ █</span><br><span class="line">█          █  </span><br><span class="line">████████████</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### #### #</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #...@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-2s, clients: 1, corpus: 49, objectives: 0, executions: 5745, exec/sec: 2.585k</span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### ####@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #....#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-3s, clients: 1, corpus: 50, objectives: 0, executions: 8892, exec/sec: 2.587k</span><br></pre></td></tr></table></figure>

<h2 id="更快地进行模糊测试"><a href="#更快地进行模糊测试" class="headerlink" title="更快地进行模糊测试"></a>更快地进行模糊测试</h2><h2 id="持久模糊测试器"><a href="#持久模糊测试器" class="headerlink" title="持久模糊测试器"></a>持久模糊测试器</h2><p>在前面的示例中，我们使用了 <code>ForkserverExecutor</code>，它与 <code>afl-clang-fast</code> 插入到我们目标中的 fork 服务器一起工作。虽然 fork 服务器通过减少每个目标进程的启动时间给了我们很大的速度提升，但我们仍然需要为每个测试用例创建一个新进程。如果我们可以在一个进程中运行多个测试用例，我们可以大大加快我们的模糊测试。在一个目标进程中运行多个测试用例通常被称为“持久模式”模糊测试。</p>
<p>正如 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/61e27c6b54f7641a168b6acc6ecffb1754c10918/docs/fuzzing_in_depth.md?plain=1#L371">AFL++ 文档</a>中所说：</p>
<blockquote>
<p>基本上，如果你不以持久模式对目标进行模糊测试，那么你就是在业余地进行模糊测试，而不是专业地进行模糊测试。</p>
</blockquote>
<p>一些目标与持久模式不兼容。每次运行都会改变大量全局状态的任何内容都可能遇到麻烦，因为我们希望每个测试用例尽可能独立运行。即使对于适合持久模式的目标，我们通常也需要为目标代码创建一个框架。这个框架只是我们编写的一些代码，用于调用目标进行模糊测试。<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md">AFL++ 文档中关于 LLVM 的持久模式</a>是编写这些类型框架的一个很好的参考。</p>
<p>当我们创建了这样的框架时，插入的 fork 服务器将检测到持久的能力，甚至可以使用共享内存来提供测试用例。LibAFL 的 <code>ForkserverExecutor</code> 可以让我们利用这些持久框架。</p>
<p>使用持久框架的模糊测试器与我们之前的模糊测试器没有太大变化。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/persistent_fuzzer/src/main.rs">.&#x2F;persistent_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>主要变化在于告诉我们的 <code>ForkServerExecutor</code> 它 <code>is_persistent(true)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_persistent&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">is_persistent</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">            .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><code>ForkserverExecutor</code> 负责使这一切发生。我们的大部分工作都投入到实际创建一个有效的框架中！如果你想尝试自己制作，我们已经为你准备了一些模板，让你开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent_template.c">.&#x2F;fuzz_target&#x2F;target_persistent_template.c</a></p>
<p>在我们的框架中，我们要注意每次运行后重置状态，以便我们尽可能接近原始状态。任何修改的全局变量、堆分配或运行的副作用，可能会改变未来运行的行为，需要被撤销。未能清除程序状态可能导致误报或不稳定。如果我们希望这个模糊测试器的成功测试用例也能使原始目标崩溃，那么我们需要尽可能地模拟原始目标的行为。</p>
<p>有时，模拟原始目标并不值得，而是使用我们的框架来针对更深层次的表面。例如，在我们的目标中，我们可以直接针对 <code>uid_to_name</code> 函数，然后在以后将解决方案转换为原始目标的解决方案。我们还会希望在我们的框架中调用 <code>valid_uid</code>，以确保我们不会报告永远不会对我们的原始目标起作用的误报。</p>
<p>你可以在这里检查我们的持久框架；我们选择为每行反复调用 <code>process_line</code> 并注意清理我们自己。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent.c">.&#x2F;fuzz_target&#x2F;target_persistent.c</a></p>
<p>在那里之前，我们看到了大约每秒 2k 次执行的模糊测试器，使用代码覆盖率反馈，现在我们看到大约每秒 5k 或 6k，仍然只有一个客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 171, objectives: 4, executions: 95677, exec/sec: 5.826k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.860k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.821k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.863k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.798k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.866k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.855k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.867k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.853k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 176, objectives: 4, executions: 98488, exec/sec: 5.866k</span><br></pre></td></tr></table></figure>

<h2 id="进程内模糊测试器"><a href="#进程内模糊测试器" class="headerlink" title="进程内模糊测试器"></a>进程内模糊测试器</h2><p>使用 AFL++ 的编译器和 fork 服务器并不是实现一个进程中多个测试用例的唯一方法。LibAFL 是一个极其灵活的库，支持各种场景。<code>InProcessExecutor</code> 允许我们在与我们的模糊测试逻辑相同的进程中直接运行测试用例。这意味着如果我们能以某种方式与我们的目标链接，我们就可以在同一进程中进行模糊测试。</p>
<p>LibAFL 的多功能性意味着我们可以将我们的整个模糊测试器构建为库，我们可以将其链接到我们的目标中，甚至可以动态地预加载到我们的目标中。LibAFL 甚至支持 <code>nostd</code>（不依赖于操作系统或标准库的编译），因此我们可以将我们的整个模糊测试器视为一个 blob 注入到我们目标的环境。</p>
<p>在我们的示例中，我们将我们的模糊测试器与我们的目标构建为静态库，并使用 Rust 的 FFI 直接调用 C 代码。</p>
<p>通过提供一个 <code>build.rs</code> 文件来构建我们的模糊测试器并使其与我们的目标链接，Rust 编译将使用该文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/inproc_fuzzer/build.rs">.&#x2F;inproc_fuzzer&#x2F;build.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_dir</span> = <span class="string">&quot;../fuzz_target&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_lib</span> = <span class="string">&quot;target_libfuzzer&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制我们链接文件 &#x27;libtarget_libfuzzer.a&#x27;</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;</span>, &amp;target_dir);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=static:+whole-archive=&#123;&#125;&quot;</span>, &amp;target_lib);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=build.rs&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了工具来包装 clang 编译器，如果你希望创建一个编译器，它将自动将你的模糊测试器注入到目标中。你可以在 LibAFL 示例中看到这一点。</p>
<p>我们还需要一个框架来处理这个目标，这样我们就可以将测试用例作为缓冲区传递，而不是让目标从 <code>stdin</code> 读取行。我们将使用 <code>libfuzzer</code> 使用的公共接口，这让我们创建一个名为 <code>LLVMFuzzerTestOneInput</code> 的函数。LibAFL 甚至有一些助手函数可以为我们执行 FFI 调用。</p>
<p>我们的框架可以与我们为持久模式模糊测试创建的框架非常相似。我们还要注意与持久模式模糊测试中相同的全局状态或内存泄漏，这些可能会使我们的模糊测试不稳定。同样，如果你想要自己制作框架，我们有一个模板供你参考。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_libfuzzer_template.c">.&#x2F;fuzz_target&#x2F;target_libfuzzer_template.c</a></p>
<p>在目标中定义了 <code>LLVMFuzzerTestOneInput</code> 并制作了静态库后，我们的模糊测试器可以直接调用框架进行每个测试用例。我们定义了一个 <code>harness</code> 函数，我们的执行器将使用测试用例数据调用该函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架</span></span><br><span class="line">        <span class="comment">// 调用 libfuzzer 风格的框架</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="comment">// 这只是一些不错的调用 libfuzzer C 函数的调用</span></span><br><span class="line">            <span class="comment">// 但我们不需要使用 libfuzzer 框架来进行进程内模糊测试</span></span><br><span class="line">            <span class="comment">// 我们可以调用任何链接的函数，只要它是一个框架</span></span><br><span class="line">            <span class="title function_ invoke__">libfuzzer_test_one_input</span>(buf);</span><br><span class="line">            <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = InProcessExecutor::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> harness,</span><br><span class="line">            tuple_list!(edges_observer),</span><br><span class="line">            &amp;<span class="keyword">mut</span> fuzzer,</span><br><span class="line">            &amp;<span class="keyword">mut</span> state,</span><br><span class="line">            &amp;<span class="keyword">mut</span> restarting_mgr,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这种与 libfuzzer 框架的轻松互操作性很好，我们再次看到比我们之前的模糊测试器有巨大的速度提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan inproc_fuzzer]$ ./target/release/inproc_fuzzer</span><br><span class="line"></span><br><span class="line">启动中</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-16s, clients: 2, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">                  (CLIENT) corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000, edges: 0/37494 (0%)</span><br><span class="line">...</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k, edges: 136/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k, edges: 137/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k</span><br><span class="line">                  (CLIENT) corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k, edges: 137/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-20s, clients: 2, corpus: 103, objectives: 6, executions: 106626, exec/sec: 28.32k</span><br></pre></td></tr></table></figure>

<p>在这个模糊测试器中，我们还在利用 LibAFL 提供的一个非常重要的工具：低级消息传递（LLMP）。这提供了多个客户端之间的快速通信，并让我们有效地将模糊测试扩展到多个核心甚至多台机器。<code>setup_restarting_mgr_std</code> 辅助函数创建了一个事件管理器，该管理器将管理客户端，并在它们遇到崩溃时重新启动它们。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">monitor</span> = MultiMonitor::<span class="title function_ invoke__">new</span>(|s| <span class="built_in">println!</span>(<span class="string">&quot; &#123;s&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们使用一个重新启动管理器，每次崩溃时都会重新启动</span></span><br><span class="line">        <span class="comment">// 我们的进程</span></span><br><span class="line">        <span class="comment">// 这将设置一个主机管理器，我们将不得不启动其他进程</span></span><br><span class="line">        <span class="keyword">let</span> (state, <span class="keyword">mut</span> restarting_mgr) = <span class="title function_ invoke__">setup_restarting_mgr_std</span>(monitor, <span class="number">1337</span>, EventConfig::<span class="title function_ invoke__">from_name</span>(<span class="string">&quot;default&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法设置重启器！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有客户端将从上面的调用中返回</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;我们是客户端！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种速度提升很重要，可以使你找到重要的漏洞或找不到。另外，在冬天让你的房间变暖一些感觉很好。</p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>当然，并不是所有的目标都很容易与链接或使用编译器进行工具化。在这些情况下，LibAFL 提供了一些有趣的工具，如 <code>libafl_frida</code> 或 <code>libafl_nyx</code>。在下一个示例中，我们将使用 LibAFL 的修改版 QEMU 为我们没有内置工具化的二进制文件提供代码覆盖率反馈。修改版的 QEMU 将向我们的模糊测试器公开代码覆盖率信息以进行反馈。</p>
<p>设置将类似于我们的进程内模糊测试器，但现在我们的框架将负责在目标中运行仿真器。默认情况下，仿真器状态不会为你重置，你将希望重置每次运行之间更改的任何全局状态。</p>
<p>如果你想自己尝试，请参阅<a href="https://docs.rs/libafl_qemu/0.10.1/libafl_qemu/emu/struct.Emulator.html">仿真器文档</a>，并随时从我们的模板开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/qemu_fuzzer_template">.&#x2F;qemu_fuzzer_template&#x2F;</a></p>
<p>在我们的解决方案中，我们首先执行一些初始化，直到一个断点，然后保存堆栈和返回地址。我们将不得不每次运行重置堆栈，并在返回地址上放置一个断点，以便我们可以在调用后停止。我们还在目标中映射一个区域，可以放置我们的输入。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(mainptr);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pc</span>: GuestReg = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Pc).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">remove_breakpoint</span>(mainptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 ret 地址，以便我们可以使用它并停止</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">retaddr</span>: GuestAddr = emu.<span class="title function_ invoke__">read_return_address</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(retaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">savedsp</span>: GuestAddr = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Sp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在让我们在目标中映射一个区域，我们将用于输入。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inputaddr</span> = emu.<span class="title function_ invoke__">map_private</span>(<span class="number">0</span>, <span class="number">0x1000</span>, MmapPerms::ReadWrite).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Input page @ &#123;inputaddr:#x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在在框架本身中，我们将输入并将其写入目标，然后开始在目标函数中执行。这次我们直接执行 <code>uid_to_name</code> 函数，并使用一个变异器，该变异器不会添加任何 <code>valid_uid</code> 会停止的无效字符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">len</span> = buf.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制我们的输入大小</span></span><br><span class="line">            <span class="keyword">if</span> len &gt; <span class="number">1024</span> &#123;</span><br><span class="line">                buf = &amp;buf[<span class="number">0</span>..<span class="number">1024</span>];</span><br><span class="line">                len = <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将我们的测试用例写入内存，以 null 终止</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr, buf);</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr + (len <span class="keyword">as</span> <span class="type">u64</span>), <span class="string">b&quot;\0\0\0\0&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 根据需要重置寄存器</span></span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Pc, parseptr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Sp, savedsp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_return_address</span>(retaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Rdi, inputaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行直到我们的返回地址断点</span></span><br><span class="line">            <span class="comment">// 或崩溃</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果我们没有崩溃，我们很好</span></span><br><span class="line">            ExitKind::<span class="literal">Ok</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这种仿真可以非常快，特别是如果我们可以在每次运行之间不必重置大量状态。通过在这里针对更深层的函数，我们可能会很快达到崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 54, objectives: 0, executions: 33349, exec/sec: 31.56k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 32.85k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 31.59k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 0, executions: 36124, exec/sec: 32.87k</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 1, executions: 36124, exec/sec: 28.73k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了一些有用的助手，如 <code>QemuAsanHelper</code> 和 <code>QemuSnapshotHelper</code>。甚至还有支持全系统仿真，而不是用户模式仿真。能够有效地使用仿真器进行模糊测试可以打开一个全新的目标世界。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>我们从一些初始输入开始，然后简单地变异它们的方法对于某些目标来说可能非常有效，但对于更复杂的输入则不那么有效。如果我们从一个像这样的 javascript 输入开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现有的变异可能会产生以下结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>\<span class="title function_">x00</span> (a &lt;\u003c b) &#123;</span><br><span class="line">    <span class="title function_">somefu</span>(a;;;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能会在解析器中发现一些漏洞，但不太可能在任何 javascript 引擎中发现更深层次的漏洞。如果我们想要锻炼引擎本身，我们将希望主要产生有效的 javascript。这是生成的一个很好的用例！通过定义一个语法，描述有效的 javascript 看起来像什么，我们可以生成大量的测试用例来对抗引擎。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"></p>
<p>正如你在上面的图表中看到的，仅靠生成我们就不再使用变异+反馈循环。有许多成功的模糊测试器仅靠生成就获得了胜利（<a href="https://github.com/googleprojectzero/domato">domato</a>、<a href="https://boofuzz.readthedocs.io/en/stable/">boofuzz</a>、<a href="https://www.atredis.com/blog/2022/03/29/veni-midi-vici-conquering-cve-2022-22657-and-cve-2022-22664">一堆奇怪的 midi 文件</a>），但我们希望在我们的模糊测试中有一些形式的反馈和进展。</p>
<p>为了在我们的生成中利用反馈，我们可以创建一个生成数据的中间表示（IR）。然后我们可以将有趣的案例反馈到我们的输入中，以便进一步变异。</p>
<p>所以我们之前的 javascript 可以像这样表达为令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (var a), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func,</span><br><span class="line">            (arg_list (var a))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们对这种标记版本的变异可以做的事情包括用其他有效的令牌替换令牌或向树添加更多节点，创建一个稍微不同的输入。然后我们可以像以前一样使用这些 IR 输入和变异，结合代码覆盖率反馈。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
<p>现在对 IR 的变异可能会产生像这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (const 0), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func</span><br><span class="line">            (arg_list</span><br><span class="line">                (func_call some_func,</span><br><span class="line">                    (arg_list ((var a), (var a)))</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这将呈现为有效的 javascript，并且如果它产生有趣的反馈，可以进一步变异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(<span class="title function_">somefunc</span>(a,a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 提供了一些很棒的工具，帮助你拥有一个带有反馈的生成模糊测试器。LibAFL 中包含了一个 <a href="https://github.com/nautilus-fuzz/nautilus">Nautilus 模糊测试器</a>的版本。为了使用它与我们的例子，我们首先定义一个语法，描述我们目标的有效输入是什么样的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/grammar.json">.&#x2F;aflcc_custom_gen&#x2F;grammar.json</a></p>
<p>有了 LibAFL，我们可以将这个语法加载到一个 <code>NautilusContext</code> 中，我们可以使用它进行生成。我们使用 <code>InProcessExecutor</code>，在我们的框架中，我们接受一个 <code>NautilusInput</code>，我们将其呈现为字节并传递给我们的 <code>LLVMFuzzerTestOneInput</code>。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/src/main.rs">.&#x2F;aflcc_custom_gen&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不能使用普通的字节变异，所以我们使用在我们生成器树上工作的变异</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">        tuple_list!(</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRecursionMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>我们还需要生成一些初始 IR 输入并指定要使用的变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">must_load_initial_inputs</span>() &#123;</span><br><span class="line">        <span class="comment">// 与从初始语料库加载不同，我们将生成 9 个 NautilusInputs 的初始语料库</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">generator</span> = NautilusGenerator::<span class="title function_ invoke__">new</span>(&amp;genctx);</span><br><span class="line">        state.<span class="title function_ invoke__">generate_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> generator, &amp;<span class="keyword">mut</span> restarting_mgr, <span class="number">9</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Created initial inputs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>有了这一切，我们可以运行并获得生成、代码覆盖率和进程内执行的结合优势。为了进一步改进这一点，我们可以随着对我们目标的更好理解而改进我们的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                  (CLIENT) corpus: 145, objectives: 2, executions: 40968, exec/sec: 1.800k, edges: 167/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k, edges: 167/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k, edges: 167/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-27s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.755k</span><br></pre></td></tr></table></figure>

<p>注意，我们保存的解决方案只是序列化的 <code>NautilusInputs</code>，并且在原始目标上使用时将不起作用。我们创建了一个单独的项目，将这些解决方案呈现为字节。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/gen_solution_render/src/main.rs">.&#x2F;gen_solution_render&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: NautilusInput = NautilusInput::<span class="title function_ invoke__">from_file</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tree_depth</span> = <span class="number">0x45</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">genctx</span> = NautilusContext::<span class="title function_ invoke__">from_file</span>(tree_depth, grammarpath);</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;PLvkLizOcGccywcS&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">&#123;&#123;EGgkWs-PxeqpwBZK&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;hlNeoKiwMTNfqO_h&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0 | ../fuzz_target/target</span><br><span class="line"></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="示例问题-2"><a href="#示例问题-2" class="headerlink" title="示例问题 2"></a>示例问题 2</h2><p>这给我们带来了第二个带回家的问题！我们有一个聊天客户端，它容易受到许多问题的影响。通过好好利用生成和&#x2F;或仿真，可以使对二进制文件的模糊测试变得更容易。在你发现一些嘈杂的漏洞时，你可能希望在你的模糊测试器中避免这些路径，或者在你的目标中修补这些漏洞。漏洞经常会掩盖其他漏洞。你可以在这里找到目标。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/chat_target">.&#x2F;chat_target&#x2F;</a></p>
<p>以及一个可以模糊测试聊天客户端的示例解决方案。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/chat_solution/src/main.rs">.&#x2F;chat_solution&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Ping from    16937944: DDAAAATt&#x27;AAAAPt&#x27;%222%%%%%%%9999&#x27;pRR9&amp;&amp;%%%%%%2Tt&#123;&#x27;&#x27;pRt&#x27;%99999999&#x27;pRR9&amp;&amp;&amp;%%%%%%999AATt&#x27;%&amp;&#x27;pRt&#x27;%TTTTTTTTTTTTTT9999999&#x27;a%&#x27;AAATTt&#x27;% --</span><br><span class="line">-- Error sending message: Bad file descriptor --</span><br><span class="line">[Stats #0] run time: 0h-0m-5s, clients: 1, corpus: 531, objectives: 13, executions: 26752, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-5s, clients: 1, corpus: 532, objectives: 13, executions: 26760, exec/sec: 0.000</span><br><span class="line">-- Ping from    16937944: DDAAAATT&#x27;%&#x27;aRt&#x27;%9999&#x27;pRRT&#x27;%&#x27;LLLLLLLLLLLa%&#x27;nnnnnmnnnT&#x27;AA&#x27;&#x27;&#x27;</span><br><span class="line">A&#x27;&#x27;p%&#x27;&#x27;A9999&#x27;pRRT&#x27;pRR -- </span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个研讨会的目标是展示 LibAFL 的多功能性，并鼓励它的使用。希望这些示例能激发你一些关于如何将自定义模糊测试器整合到你的一些目标中的想法。如果你有任何问题或发现我们示例中的任何问题，请让我们知道。或者，如果你有一个有趣的目标，并希望我们为你找到漏洞，请与我们联系。</p>
<h2 id="课程推广"><a href="#课程推广" class="headerlink" title="课程推广"></a>课程推广</h2><p>再次感谢你的阅读！如果你喜欢这类内容，你可能会对我们的课程“Practical Symbolic Execution for VR and RE”感兴趣，你将学习如何为以下内容创建你自己的符号执行框架：逆向工程、去混淆、漏洞检测、漏洞开发等。下一次公开课程将在 2024 年 2 月作为 ringzer0 的 BOOTSTRAP24 的一部分。我们也可以根据要求提供私人课程。</p>
<p>更多信息在这里。<br><a href="https://ringzer0.training/trainings/practical-symbolic-execution.html">https://ringzer0.training/trainings/practical-symbolic-execution.html</a></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1566943528908-J56DPCZRQ9SVG4TFPP27/WhiskeyBirdTextOverlayWhite.png?format=1500w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1701794251926-ZA8KEPB15YFCJ0QRW122/johannes-weber-wcspluM_Iqw-unsplash.jpg?format=1000w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
        <category>翻译文章</category>
      </categories>
      <tags>
        <tag>LibAFL</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC奖学金体系</title>
    <url>/2023/09/04/UESTC%E5%A5%96%E5%AD%A6%E9%87%91%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>学习一下成电的奖学金体系</p>
<span id="more"></span>

<ul>
<li><h1 id="奖学金体系"><a href="#奖学金体系" class="headerlink" title="奖学金体系"></a>奖学金体系</h1><ul>
<li>学业<ul>
<li>金额：10000&#x2F;8000&#x2F;4000</li>
<li>评定时间：9月中上旬</li>
<li>申请制：需要提交佐证材料</li>
</ul>
</li>
<li>国家<ul>
<li>金额：硕2万，博3万</li>
<li>评定时间：9月中下旬，学业奖学金之后</li>
<li>申请制：大约也是按照学业奖学金的那套细则</li>
</ul>
</li>
<li>专项<ul>
<li>小米<ul>
<li>金额：2万，10个名额</li>
<li>时间：1月上旬</li>
<li>可与国奖兼得</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ul>
<li>国奖与专项不可兼得，专项有特殊说明的除外</li>
</ul>
</li>
<li><h1 id="评定办法"><a href="#评定办法" class="headerlink" title="评定办法"></a>评定办法</h1><ul>
<li>研二：综合素质得分&#x3D;学业成绩得分+科研成果得分+素质发展得分+导师评价得分</li>
<li>研三：综合素质得分&#x3D;科研成果得分+素质发展得分+导师评价得分</li>
</ul>
</li>
<li><h1 id="综合素质得分细则"><a href="#综合素质得分细则" class="headerlink" title="综合素质得分细则"></a>综合素质得分细则</h1><ul>
<li><h2 id="科研成果"><a href="#科研成果" class="headerlink" title="科研成果"></a>科研成果</h2><ul>
<li><h3 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904093901825.png" alt="image-20230904093901825"></p>
</li>
<li><h3 id="专利软著"><a href="#专利软著" class="headerlink" title="专利软著"></a>专利软著</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094106297.png" alt="image-20230904094106297"></p>
</li>
<li><h3 id="教材或专著"><a href="#教材或专著" class="headerlink" title="教材或专著"></a>教材或专著</h3><p>学生参与编写教材或专著的（须在作者列表中），提交相关材料，由评审委员会认定加分，上限 8 分。</p>
</li>
<li><h3 id="科技获奖"><a href="#科技获奖" class="headerlink" title="科技获奖"></a>科技获奖</h3><ul>
<li>获得国家科技奖励，省部级科技一等奖，可直接定为学业奖学金一等奖</li>
<li>省部级科技二等奖、三等奖在原有奖学金基础上提升一等级</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="素质发展"><a href="#素质发展" class="headerlink" title="素质发展"></a>素质发展</h2><ul>
<li><h3 id="科技竞赛"><a href="#科技竞赛" class="headerlink" title="科技竞赛"></a>科技竞赛</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904094921145.png" alt="image-20230904094921145"></p>
<ul>
<li>A类竞赛包括<ul>
<li>中国“互联网+”大学生创新创业大赛</li>
<li>“挑战杯”全国大学生课外学术科技作品竞赛</li>
<li>“挑战杯”中国大学生创业计划大赛</li>
<li><a href="https://cpipc.acge.org.cn/">中国研究生创新实践系列大赛</a><ul>
<li>中国研究生智慧城市技术与创意设计赛</li>
<li>中国研究生未来飞行器创新赛</li>
<li>中国研究生数学建模竞赛</li>
<li>中国研究生电子设计竞赛</li>
<li>中国研究生创“芯”大赛</li>
<li>中国研究生人工智能创新大赛</li>
<li>中国研究生机器人创新设计大赛</li>
<li>中国能源装备创新设计大赛</li>
<li>中国研究生公共管理案例大赛</li>
<li>中国研究生乡村振兴科技强农+创新大赛</li>
<li>中国研究生网络安全创新大赛</li>
<li>中国研究生“双碳”创新与创意大赛</li>
<li>中国研究生金融科技创新大赛</li>
</ul>
</li>
</ul>
</li>
<li>B类竞赛<ul>
<li>纳入研究生院研究生科技创新支持计划的其他竞赛<ul>
<li>全国大学生FPGA 创新设计竞赛</li>
<li>中兴捧月大赛</li>
<li>IEEEXtreme 极限编程大赛</li>
<li>全国大学生集成电路创新创业大赛</li>
<li>全国大学生嵌入式芯片与系统设计大赛</li>
<li>全国大学生集成电路EDA设计精英挑战赛</li>
<li>BOE 创新挑战赛</li>
<li>华为软件精英挑战赛</li>
<li>中国研究生电子设计竞赛商业计划书专项赛</li>
</ul>
</li>
<li>由我国政府教育行政主管部门、专业教学指导委员会，专业学术组织，主办的学术科技类比赛</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="学生骨干"><a href="#学生骨干" class="headerlink" title="学生骨干"></a>学生骨干</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904095600951.png" alt="image-20230904095600951"></p>
<ul>
<li>研究生会、研究生党建委员会若本年度获得学校表彰，成员可根据所在组织考评结果增加 1 分</li>
<li>党支部若获得本年度校级以上“先进党支部”称号，根据党支部评议结果，排名前 50%的党支部成员（以党支部正式党员、预备党员人数为基数）增加 1 分，院级减半</li>
</ul>
</li>
<li><h3 id="公益事业"><a href="#公益事业" class="headerlink" title="公益事业"></a>公益事业</h3><ul>
<li>参与志愿者等有突出表现，加 1 分，获得奖励的追加0.5分。可累加，上限为2 分</li>
</ul>
</li>
<li><h3 id="社会实践"><a href="#社会实践" class="headerlink" title="社会实践"></a>社会实践</h3><ul>
<li>参加扶贫、支教、国际组织实习、基层挂职锻炼项目等加 2 分，获得奖励的追加 1 分。可累加，上限 6 分。</li>
</ul>
</li>
<li><h3 id="综合素质比赛"><a href="#综合素质比赛" class="headerlink" title="综合素质比赛"></a>综合素质比赛</h3><ul>
<li>参加由我国政府教育行政主管部门、专业教学指导委员会、专业学术组织和学校学院主办的综合素质类比赛并获奖的，国家级加3分，省市级加 2 分，校级院级加 1 分，上限为 3 分。</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="导师评价"><a href="#导师评价" class="headerlink" title="导师评价"></a>导师评价</h2><ul>
<li><p>评分采取“<strong>科研团队（或导师）总分</strong>+<strong>内部分级</strong>”的方式</p>
</li>
<li><p>每个科研团队（或导师）拥有一个总评分，即该团队（或导师）门下具有参评奖学金资格的<strong>学生人数</strong>×<strong>学生人均分 15 分</strong>＝总评分</p>
</li>
<li><p>评分区间为5—20分，最后学生个人得分的加总不能超过团队（或导师）拥有的总评分。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230904100133437.png" alt="image-20230904100133437"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>综合分析：</strong></p>
<p>其实比赛啊，支部啊，意义不大。做真科研，才是真正有长远发展的事情。</p>
]]></content>
      <tags>
        <tag>研究生</tag>
      </tags>
  </entry>
  <entry>
    <title>docker环境</title>
    <url>/2023/09/07/docker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>docker环境</p>
<span id="more"></span>

<ol>
<li>在linux环境安装docker：<a href="https://docs.docker.com/desktop/install/linux-install/">https://docs.docker.com/desktop/install/linux-install/</a></li>
<li>docker权限问题：<a href="https://blog.csdn.net/AS_TS/article/details/131184815">https://blog.csdn.net/AS_TS/article/details/131184815</a></li>
</ol>
<h2 id="exercise1"><a href="#exercise1" class="headerlink" title="exercise1"></a>exercise1</h2><p>在docker环境中作一份代码的fuzzing</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本机下载问题代码</span></span><br><span class="line">git clone https://github.com/alex-maleno/Fuzzing-Module.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 AFL++ 的 docker 容器</span></span><br><span class="line">docker run --rm -it -v /home/tiger/fuzz/Fuzzing-Module://home/Fuzzing-Module 6612ffca640e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake 编译示例代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成seeds</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始fuzzing</span></span><br><span class="line">/AFLplusplus/afl-fuzz -i /home/Fuzzing-Module/exercise1/seeds -o out -m none -d -- /home/Fuzzing-Module/exercise1/build/simple_crash</span><br><span class="line"></span><br><span class="line">docker run --rm -it -v &quot;/home/tiger&quot;:&quot;/home/tiger&quot; 6612ffca640e</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+typora图片路径设置</title>
    <url>/2023/09/15/hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="目前的问题："><a href="#目前的问题：" class="headerlink" title="目前的问题："></a>目前的问题：</h4><ol>
<li>用 hexo n 命令新增博文全部在 _post 文件夹下，博文多了之后很乱，需要按主题分文件夹。</li>
<li>之前的云对象存储到期以后想把图片直接放在 github 里面</li>
</ol>
<p>第一个问题在研究了 hexo 的官方文档之后，可以在新建文章时候用 -p 命令指定文件夹，且 -p 默认相对位置就是 _post 文件夹。</p>
<p>第二个问题：</p>
<ul>
<li>首先在网站配置 <code>_config.yml</code> 中，设置<code>post_asset_folder: true</code>，则会在 <code>hexo n</code> 的时候同时在同路径下生成同名文件夹。</li>
<li>意味着写作过程中可以将图片放在该文件夹中，但问题是，typora 中对图片路径的引用格式和 hexo 要求的不一致，于是需要在写完文章，编译之前把所有引用路径处理成 hexo 格式。</li>
</ul>
<p>下面是一张新闻图片：<br><img src="/2023/09/15/hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155128595.png" alt="image-20240915155128595"></p>
<p>上面的图片直接在typora 中浏览是正常的，可以正常进行路径解析，但是用 hexo 部署后是这个样子：</p>
<p><img src="/2023/09/15/hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155502923.png" alt="image-20240915155502923"></p>
<p>加了所谓的路径转换插件后编译出来，index.html 源码是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;下面是一张新闻图片：&lt;br&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155128595.png&quot; alt=&quot;image-20240915155128595&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;上面的图片直接在typora 中浏览是正常的，可以正常进行路径解析，但是用 hexo 部署后是这个样子：&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155502923.png&quot; alt=&quot;image-20240915155502923&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>但是这仍然是不能访问的，现在去掉编译插件试试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;下面是一张新闻图片：&lt;br&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155128595.png&quot; alt=&quot;image-20240915155128595&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;上面的图片直接在typora 中浏览是正常的，可以正常进行路径解析，但是用 hexo 部署后是这个样子：&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155502923.png&quot; alt=&quot;image-20240915155502923&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>一模一样，说明插件根本没起作用，</p>
<p>插件用上之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;下面是一张新闻图片：&lt;br&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155128595.png&quot; alt=&quot;image-20240915155128595&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;上面的图片直接在typora 中浏览是正常的，可以正常进行路径解析，但是用 hexo 部署后是这个样子：&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;img src=&quot;/./hexo+typora%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%AE%BE%E7%BD%AE/image-20240915155502923.png&quot; alt=&quot;image-20240915155502923&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>看到王预选学长博客是所有文章放在post 文件夹，图片放在asserts下面的pic 中，然后图片链接用camo转换，本地markdown还是<a href=""></a> 形式，我的github似乎没有将markdown推上去？</p>
]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>mytest</title>
    <url>/2024/09/15/mytest/</url>
    <content><![CDATA[<img src="/2024/09/15/mytest/image-20240915155128595.png" class="" title="This is an example image">]]></content>
  </entry>
  <entry>
    <title>apue 学习记录</title>
    <url>/2024/06/19/apue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>apue 学习记录</p>
<span id="more"></span>

<ul>
<li><p>环境搭建：<a href="https://zhuanlan.zhihu.com/p/580675705">https://zhuanlan.zhihu.com/p/580675705</a></p>
</li>
<li><p>文件描述符和inode关系：<a href="https://blog.csdn.net/ambitiousssssss/article/details/124001467%EF%BC%8Chttps://blog.csdn.net/weixin_43864567/article/details/124063198">https://blog.csdn.net/ambitiousssssss/article/details/124001467，https://blog.csdn.net/weixin_43864567/article/details/124063198</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/kcloveworld/p/17989014">文件描述符、文件描述符表、文件表项、inode名词释义</a><br><a href="https://blog.csdn.net/kyang_823/article/details/79496362">https://blog.csdn.net/kyang_823/article/details/79496362</a></p>
</li>
<li><p>&#x2F;proc文件系统：<a href="https://blog.51cto.com/u_15127514/4196632">https://blog.51cto.com/u_15127514/4196632</a></p>
</li>
<li><p>虚拟文件系统VFS原理：<a href="https://blog.51cto.com/mingongge/2945174">https://blog.51cto.com/mingongge/2945174</a></p>
</li>
<li><p>重要头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">这个头文件包含了POSIX标准中定义的一些常用函数和类型，比如fork()、exec()系列函数，以及pid_t类型等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">这个头文件包含了系统调用的编号，比如SYS_gettid和SYS_tgkill等。</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">这个头文件定义了一些基本的数据类型，比如pid_t、size_t等。</span><br><span class="line"></span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">这个头文件包含了信号相关的函数和类型，比如SIGHUP信号常量。</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./tools/perf/include/bpf/unistd.h</span><br><span class="line">./tools/arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./tools/arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./tools/include/nolibc/unistd.h</span><br><span class="line">./tools/include/uapi/asm-generic/unistd.h</span><br><span class="line">./arch/alpha/include/asm/unistd.h</span><br><span class="line">./arch/alpha/include/uapi/asm/unistd.h</span><br><span class="line">./arch/ia64/include/asm/unistd.h</span><br><span class="line">./arch/ia64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm64/include/asm/unistd.h</span><br><span class="line">./arch/arm64/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sparc/include/asm/unistd.h</span><br><span class="line">./arch/sparc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/asm/unistd.h</span><br><span class="line">./arch/xtensa/include/uapi/asm/unistd.h</span><br><span class="line">./arch/parisc/include/asm/unistd.h</span><br><span class="line">./arch/parisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/asm/unistd.h</span><br><span class="line">./arch/microblaze/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/riscv/include/asm/unistd.h</span><br><span class="line">./arch/riscv/include/uapi/asm/unistd.h</span><br><span class="line">./arch/s390/include/asm/unistd.h</span><br><span class="line">./arch/s390/include/uapi/asm/unistd.h</span><br><span class="line">./arch/nios2/include/uapi/asm/unistd.h</span><br><span class="line">./arch/x86/include/asm/unistd.h</span><br><span class="line">./arch/x86/include/uapi/asm/unistd.h</span><br><span class="line">./arch/hexagon/include/uapi/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/asm/unistd.h</span><br><span class="line">./arch/powerpc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/asm/unistd.h</span><br><span class="line">./arch/loongarch/include/uapi/asm/unistd.h</span><br><span class="line">./arch/sh/include/asm/unistd.h</span><br><span class="line">./arch/sh/include/uapi/asm/unistd.h</span><br><span class="line">./arch/m68k/include/asm/unistd.h</span><br><span class="line">./arch/m68k/include/uapi/asm/unistd.h</span><br><span class="line">./arch/csky/include/asm/unistd.h</span><br><span class="line">./arch/csky/include/uapi/asm/unistd.h</span><br><span class="line">./arch/arm/include/asm/unistd.h</span><br><span class="line">./arch/arm/include/uapi/asm/unistd.h</span><br><span class="line">./arch/openrisc/include/uapi/asm/unistd.h</span><br><span class="line">./arch/mips/include/asm/unistd.h</span><br><span class="line">./arch/mips/include/uapi/asm/unistd.h</span><br><span class="line">./include/uapi/asm-generic/unistd.h</span><br><span class="line">./include/uapi/linux/unistd.h</span><br><span class="line">arch/mips/include/asm/unistd.h 通常包含了特定于MIPS架构的系统调用号码定义，这些定义是基于MIPS架构的特点定制的。</span><br><span class="line">arch/mips/include/uapi/asm/unistd.h 则包含了用户空间API的系统调用号码定义，这些定义是为了让用户空间程序能够安全地调用内核提供的服务。</span><br><span class="line">简单来说，uapi目录下的头文件通常用于定义用户空间可以使用的接口，而非特定于某个架构的内部细节。这样做的好处是，用户空间程序不必关心底层的硬件架构，只需通过统一的接口与内核通信。而asm目录下的头文件则包含了特定于某一架构的实现细节，这些细节对于用户空间程序是透明的，但对于内核开发者来说非常重要，因为它们涉及到如何在特定的硬件上实现系统调用.</span><br></pre></td></tr></table></figure>

<p>学习 apue 的目的是什么？<br>1.明白 linux 系统级知识，为读 AFL 源码做准备。<br>2.进而熟悉 linux 内核源码，可以对内核进行调试，修改。<br>目前好的 apue 学习素材：<br>1.b站李慧琴的课，相关笔记<a href="https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8">https://kisugitakumi.net/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#6-4-2-%E4%BD%BF%E7%94%A8</a><br>2.apue 书本<br>目前对 apue 的理解以及所能预料到的掌握后的能力：<br>1.熟悉了 linux 平台 进程 文件 信号机制 的原理，接口<br>2.能够在此基础之上进行应用程序开发</p>
<p>对于使用 afl 本身来说，了解平台机制就可以了，想要研究 afl 更重要的就是要对 afl 的原理进行更深入的研究。<br>以上都为计算机的术的话，计算机学习的道应该是什么？</p>
<p>6月20号：<br>1.昨天开始读 AFL 源码，主要是看 makefile ,问题是 makefile 语法还是不太熟悉，又转去看手册。makefile 里有 shell 命令，于是看 bash 手册<br>2.makefile bash 两个手册可以粗略看一下，花费一个半小时，然后开始看 AFL 源码</p>
<p>type command  查看命令类型</p>
]]></content>
      <categories>
        <category>工程开发</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>next 主题基本设置</title>
    <url>/2023/09/03/next%E4%B8%BB%E9%A2%98%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>为博客更换 next 主题，并做基础设置，使其能用。</p>
<span id="more"></span>

<ol>
<li><h2 id="更换next主题"><a href="#更换next主题" class="headerlink" title="更换next主题"></a>更换next主题</h2><ol>
<li><p>从<a href="https://github.com/hexojs/hexo/wiki/Themes#n">hexo主题库</a>中找一款中意的下载到 blog-dir&#x2F;themes 文件夹中</p>
</li>
<li><p>设置 hexo 配置文件 <code>_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Extensions</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Plugins: https://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next  # 这里的主题名字要和themes文件夹中下载的主题文件夹名字一致</span><br></pre></td></tr></table></figure>

<p>将这里改为你下载的主题，顺便选 next 的原因是维护比较好，界面简约</p>
</li>
<li><p>然后 <code>hexo g</code> <code>hexo d</code> 就完成主题更换。</p>
</li>
</ol>
</li>
<li><h2 id="next-主题优化"><a href="#next-主题优化" class="headerlink" title="next 主题优化"></a>next 主题优化</h2><p>现在有两个关键配置文件，</p>
<ul>
<li>一个是 <code>site-dir\themes\next</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>另一个是<code>site-dir</code> 文件夹下的 <code>_config.yml</code>，</li>
<li>两个文件同名，但是前者是关于 next 主题的配置，后者是关于 hexo 博客的配置。</li>
</ul>
<ol>
<li><h3 id="站点基本配置信息"><a href="#站点基本配置信息" class="headerlink" title="站点基本配置信息"></a>站点基本配置信息</h3><p>更改 hexo 配置文件为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Site</span></span><br><span class="line">title: Focus2flow</span><br><span class="line">subtitle: &#x27;less is more&#x27;</span><br><span class="line">description: &#x27;技术，人生，思考，自我&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: sky</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="更改-next-的-scheme"><a href="#更改-next-的-scheme" class="headerlink" title="更改 next 的 scheme"></a>更改 next 的 scheme</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Schemes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Muse</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Mist</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>添加标签，分类关于三个页面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先在 next 配置文件中打开这三个开关</span></span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 hexo 命令在 <span class="built_in">source</span> 目录下创建三个文件夹</span></span><br><span class="line">hexo n page about</span><br><span class="line">hexo n page tags</span><br><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure>

<p>此时在四个文件夹中自动生成了对应页面的 md 文档，hexo s 运行博客也可以在首页访问到对应页面，问题是这四个功能页面跟普通的post中的内容页面是有区别的，具体来讲：</p>
<ul>
<li>about 页暂不清楚</li>
<li>tags 页要根据 post 中博文在文件头部设置的标签对文章进行分类</li>
<li>categories 页要根据类别进行分类，类似于文件夹</li>
<li>archives 页对本博客所有文章按时间轴列出</li>
</ul>
<p>因此需要对这这些功能文件在文件头部用 type 字段进行说明，next 识别到类型说明才能启动对应的算法从 post 里的博文里统计并呈现对应信息。</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903215225417.png" alt="image-20230903215225417"></p>
<p>那么写博文时候怎样设置 tags catagories 呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置标签</span></span><br><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置分类</span></span><br><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种设置方法</span></span><br><span class="line">tags: [&quot;tag1&quot;,&quot;tag2&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h3><p>在你认为合适的地方添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><ol>
<li><p>安装 <a href="https://links.jianshu.com/go?to=https://github.com/flashlab/hexo-generator-search">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开站点配置文件找到 <code>Extensions</code> 在下面添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3、打开主题配置文件找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
</li>
</ol>
</li>
</ol>
<p>至此就是一个打开可以用起来的博客了，那么梳理一下写新文章的合理步骤：</p>
<ol>
<li><code>hexo n name </code> 在 post 中生成一个带文件头的 md 文档</li>
<li>typora 接管文档，写博客</li>
<li>写完之后 hexo 生成，部署</li>
</ol>
<p><strong>参考文章：</strong></p>
<p><a href="https://hexo.io/">hexo 官方文档</a></p>
<p><a href="https://theme-next.js.org/">next 官方文档</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&mid=2247488750&idx=1&sn=bddb76b8e85d04b303b3d10024b8a56b&chksm=eb47150adc309c1cfe5f847acaf6a3eb7de3efb3c7f2a87e708a686a740aa364c33c80ea3000&token=1693393167&lang=zh_CN#rd">博客的意义</a></p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">基础优化</a></p>
<p><strong>未来优化方向：</strong></p>
<p><a href="https://www.lovebykin.com/4288776826/">鉴于分类页太丑</a></p>
<p><a href="https://blog.juanertu.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一个系列博客有机会再优化</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 系统数据结构</title>
    <url>/2024/09/05/linux%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>linux 系统中常见的数据结构</p>
<span id="more"></span>

<h1 id="struct-itimerval"><a href="#struct-itimerval" class="headerlink" title="struct itimerval"></a>struct itimerval</h1><p><code>struct itimerval</code>是一个用于设置定时器的结构体。它包含了两个成员变量，分别是<code>it_interval</code>和<code>it_value</code>。</p>
<p><code>it_interval</code>用于设置定时器的间隔时间，即每隔多少时间触发一次定时器。<code>it_value</code>用于设置定时器的初始值，即第一次触发定时器的时间。</p>
<p>这个结构体可以在C语言中使用，用于设置定时器以及处理定时器信号。例如，可以使用<code>setitimer()</code>函数来设置定时器并启动定时器信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="type">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">and gives the number of seconds and microseconds since the <span class="title function_">Epoch</span> <span class="params">(see time(<span class="number">2</span>))</span>.</span><br><span class="line"></span><br><span class="line">The tz argument is a <span class="keyword">struct</span> timezone:</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timezone &#123;</span><br><span class="line">	<span class="type">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">	<span class="type">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br><span class="line">Describes times in seconds and nanoseconds.</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">	<span class="type">time_t</span>  tv_sec;  <span class="comment">/* Seconds */</span></span><br><span class="line">	<span class="type">long</span>    tv_nsec; <span class="comment">/* Nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="文件系统-stat"><a href="#文件系统-stat" class="headerlink" title="文件系统 stat"></a>文件系统 stat</h1><ul>
<li>在<code>E:\Ubuntushare\linux-6.0\arch\x86\include\uapi\asm\stat.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ino;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_nlink;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_uid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> st_gid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_rdev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blksize;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_atime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_mtime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  st_ctime_nsec;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused4;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __unused5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> S_ISREG(m)  is it a regular file?</p>
<pre><code>       S_ISDIR(m)  directory?

       S_ISCHR(m)  character device?

       S_ISBLK(m)  block device?

       S_ISFIFO(m) FIFO (named pipe)?

       S_ISLNK(m)  symbolic link?  (Not in POSIX.1-1996.)

       S_ISSOCK(m) socket?  (Not in POSIX.1-1996.)
</code></pre>
<p>成员变量的含义：</p>
<ul>
<li>st_dev：文件所在设备的设备号</li>
<li>st_ino：文件的i-node号</li>
<li>st_mode：文件的类型和访问权限</li>
<li>st_nlink：文件的硬链接数</li>
<li>st_uid：文件的所有者的用户ID</li>
<li>st_gid：文件的所有者的组ID</li>
<li>st_rdev：如果文件是设备文件，则该成员保存了设备的设备号</li>
<li>st_size：文件的大小（以字节为单位）</li>
<li>st_blksize：文件系统I&#x2F;O操作的最佳块大小</li>
<li>st_blocks：文件所占用的磁盘块数</li>
<li>st_atime：文件的最后访问时间</li>
<li>st_atime_nsec：文件的最后访问时间的纳秒部分</li>
<li>st_mtime：文件的最后修改时间</li>
<li>st_mtime_nsec：文件的最后修改时间的纳秒部分</li>
<li>st_ctime：文件的最后状态改变时间</li>
<li>st_ctime_nsec：文件的最后状态改变时间的纳秒部分</li>
<li>__unused4和__unused5：未使用的保留字段</li>
</ul>
<p>这个结构体是用于在C语言中对文件的状态进行描述和操作的一个重要数据结构。在C语言中，可以使用stat()函数来获取一个文件的状态，然后通过访问结构体的成员变量来获取文件的各种属性。</p>
<ul>
<li><p>本地化数据格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lconv</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Numeric (nonmonetary) information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *decimal_point;     <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *thousands_sep;     <span class="comment">/* Separator for digit groups to left</span></span><br><span class="line"><span class="comment">								of radix character */</span></span><br><span class="line">	<span class="type">char</span> *grouping;     <span class="comment">/* Each element is the number of digits in</span></span><br><span class="line"><span class="comment">							a group; elements with higher indices</span></span><br><span class="line"><span class="comment">							are further left.  An element with value</span></span><br><span class="line"><span class="comment">							CHAR_MAX means that no further grouping</span></span><br><span class="line"><span class="comment">							is done.  An element with value 0 means</span></span><br><span class="line"><span class="comment">							that the previous element is used for</span></span><br><span class="line"><span class="comment">							all groups further left. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remaining fields are for monetary information */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *int_curr_symbol;   <span class="comment">/* First three chars are a currency</span></span><br><span class="line"><span class="comment">								symbol from ISO 4217.  Fourth char</span></span><br><span class="line"><span class="comment">								is the separator.  Fifth char</span></span><br><span class="line"><span class="comment">								is &#x27;\0&#x27;. */</span></span><br><span class="line">	<span class="type">char</span> *currency_symbol;   <span class="comment">/* Local currency symbol */</span></span><br><span class="line">	<span class="type">char</span> *mon_decimal_point; <span class="comment">/* Radix character */</span></span><br><span class="line">	<span class="type">char</span> *mon_thousands_sep; <span class="comment">/* Like thousands_sep above */</span></span><br><span class="line">	<span class="type">char</span> *mon_grouping;      <span class="comment">/* Like grouping above */</span></span><br><span class="line">	<span class="type">char</span> *positive_sign;     <span class="comment">/* Sign for positive values */</span></span><br><span class="line">	<span class="type">char</span> *negative_sign;     <span class="comment">/* Sign for negative values */</span></span><br><span class="line">	<span class="type">char</span>  int_frac_digits;   <span class="comment">/* International fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  frac_digits;       <span class="comment">/* Local fractional digits */</span></span><br><span class="line">	<span class="type">char</span>  p_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								positive value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  p_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a positive</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="type">char</span>  n_cs_precedes;     <span class="comment">/* 1 if currency_symbol precedes a</span></span><br><span class="line"><span class="comment">								negative value, 0 if succeeds */</span></span><br><span class="line">	<span class="type">char</span>  n_sep_by_space;    <span class="comment">/* 1 if a space separates</span></span><br><span class="line"><span class="comment">								currency_symbol from a negative</span></span><br><span class="line"><span class="comment">								value */</span></span><br><span class="line">	<span class="comment">/* Positive and negative sign positions:</span></span><br><span class="line"><span class="comment">		0 Parentheses surround the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		1 The sign string precedes the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		2 The sign string succeeds the quantity and currency_symbol.</span></span><br><span class="line"><span class="comment">		3 The sign string immediately precedes the currency_symbol.</span></span><br><span class="line"><span class="comment">		4 The sign string immediately succeeds the currency_symbol. */</span></span><br><span class="line">	<span class="type">char</span>  p_sign_posn;</span><br><span class="line">	<span class="type">char</span>  n_sign_posn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>密码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">	<span class="type">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">	<span class="type">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">	<span class="type">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">	<span class="type">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">	<span class="type">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">	<span class="type">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">/* Ownership and permissions */</span></span><br><span class="line">	<span class="type">size_t</span>          shm_segsz;   <span class="comment">/* Size of segment (bytes) */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_atime;   <span class="comment">/* Last attach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_dtime;   <span class="comment">/* Last detach time */</span></span><br><span class="line">	<span class="type">time_t</span>          shm_ctime;   <span class="comment">/* Creation time/time of last</span></span><br><span class="line"><span class="comment">									modification via shmctl() */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_cpid;    <span class="comment">/* PID of creator */</span></span><br><span class="line">	<span class="type">pid_t</span>           shm_lpid;    <span class="comment">/* PID of last shmat(2)/shmdt(2) */</span> <span class="comment">//不关注最后一次detach的进程ID</span></span><br><span class="line">	<span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">/* No. of current attaches */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中的 ipc_perm 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">	<span class="type">key_t</span>          __key;    <span class="comment">/* Key supplied to shmget(2) */</span></span><br><span class="line">	<span class="type">uid_t</span>          uid;      <span class="comment">/* Effective UID of owner */</span></span><br><span class="line">	<span class="type">gid_t</span>          gid;      <span class="comment">/* Effective GID of owner */</span></span><br><span class="line">	<span class="type">uid_t</span>          cuid;     <span class="comment">/* Effective UID of creator */</span></span><br><span class="line">	<span class="type">gid_t</span>          cgid;     <span class="comment">/* Effective GID of creator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">/* Permissions + SHM_DEST and</span></span><br><span class="line"><span class="comment">								SHM_LOCKED flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">/* Sequence number */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源限制</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">	<span class="type">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows  环境下利用 Github page 搭建博客环境</title>
    <url>/2023/09/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Github + hexo 搭建个人博客</p>
<span id="more"></span>

<ol>
<li><h2 id="本地环境准备"><a href="#本地环境准备" class="headerlink" title="本地环境准备"></a>本地环境准备</h2><ol>
<li><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><blockquote>
<p>目的是为了利用 git 和 Github 仓库进行交互</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/download/win">下载官方 git</a>，选择合适版本，</li>
<li>将 git 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>git version</code>,检查是否安装并设置成功。</li>
</ul>
</li>
<li><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><blockquote>
<p>目的是使用其包管理软件 npm 安装 hexo ，也可能与 hexo s 命令有关</p>
</blockquote>
<ul>
<li><a href="https://nodejs.org/en/download">下载官方 nodejs</a>，选择合适版本</li>
<li>将 node 可执行文件路径添加到全局环境变量。</li>
<li>在 PowerShell 中执行 <code>node -v</code>,检查是否安装并设置成功</li>
</ul>
</li>
<li><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><blockquote>
<p>hexo 是一款优秀的博客管理软件？这样定位不知道是否合适</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install hexo -g</code> 安装</li>
<li>在 git-bash 中使用命令 <code>hexo -v</code> 验证安装</li>
</ul>
</li>
<li><h3 id="安装-hexo-developer-git"><a href="#安装-hexo-developer-git" class="headerlink" title="安装 hexo-developer-git"></a>安装 hexo-developer-git</h3><blockquote>
<p>这个是 <code>hexo d</code> 命令中将本地编译好的博客部署到 github 仓库时，hexo 和 git 交互的软件</p>
</blockquote>
<ul>
<li>在 git-bash 中使用命令 <code>npm install --save hexo-deployer-git</code> 安装</li>
</ul>
</li>
</ol>
</li>
<li><h2 id="Github-仓库设置"><a href="#Github-仓库设置" class="headerlink" title="Github 仓库设置"></a>Github 仓库设置</h2><ol>
<li><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><blockquote>
<p>默认情况下 github 允许每一个用户建立一个博客仓库</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903131724407.png" alt="image-20230903131724407"></p>
<p>这里似乎并不能看出这个仓库是专用于搭建博客用的，有待将来研究 Github Pages 的说明。</p>
</li>
</ol>
</li>
<li><h2 id="Git-与-Github-交互设置"><a href="#Git-与-Github-交互设置" class="headerlink" title="Git 与 Github 交互设置"></a>Git 与 Github 交互设置</h2><ol>
<li><h3 id="Git-客户端生成-ssh-公钥"><a href="#Git-客户端生成-ssh-公钥" class="headerlink" title="Git 客户端生成 ssh 公钥"></a>Git 客户端生成 ssh 公钥</h3><ol>
<li><p>在 git-bash 中使用 <code>ssh-keygen -t rsa -C &quot;example@email.com&quot;</code>生成密钥对</p>
</li>
<li><p><code>cd ~/.ssh</code> 进入到 ssh 本地秘钥文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">README.md  config  id_rsa  id_rsa.pub  known_hosts  known_hosts.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>将其中的公钥 <code>id_rsa.pub</code> 的内容复制出来</p>
</li>
</ol>
</li>
<li><h3 id="Github-添加-Git-产生的公钥"><a href="#Github-添加-Git-产生的公钥" class="headerlink" title="Github 添加 Git 产生的公钥"></a>Github 添加 Git 产生的公钥</h3><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903134218399.png" alt="image-20230903134218399"></p>
</li>
<li><h3 id="使用-ssh-T-git-github-com-命令测试是否成功"><a href="#使用-ssh-T-git-github-com-命令测试是否成功" class="headerlink" title="使用 ssh -T git@github.com 命令测试是否成功"></a>使用 <code>ssh -T git@github.com</code> 命令测试是否成功</h3></li>
<li><h3 id="设置-Git-用户名和邮箱"><a href="#设置-Git-用户名和邮箱" class="headerlink" title="设置 Git 用户名和邮箱"></a>设置 Git 用户名和邮箱</h3><ul>
<li>设置用户名：<code>git config --global user.name &quot;ColorMao&quot;</code></li>
<li>设置邮箱：<code>git config --global user.email &quot;zhangyumao@petalmail.com&quot;</code></li>
</ul>
</li>
</ol>
</li>
<li><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><ol>
<li><p>在本机合适的位置建立一个存放本地博客文件的文件夹，如我的：<code>E:\Blogs\Focus2flow</code>，git-bash 进入该空文件夹</p>
</li>
<li><p>使用 hexo 本地部署博客</p>
<ol>
<li><code>hexo init</code> 初始化博客文件</li>
<li><code>hexo generate</code> 编译生成可部署的 html 文件</li>
<li><code>hexo server</code> 本地部博客用于预览</li>
</ol>
</li>
<li><p>博客部署到仓库</p>
<ol>
<li><p>在博客文件夹根目录找到 hexo 配置文件 <code>_config.yml</code></p>
</li>
<li><p>更改其中的配置选项为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:captain0X01/captain0X01.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo deploy</code> 部署到 GIthub仓库</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142806727.png" alt="image-20230903142806727"></p>
<p>可以观察到文件确实推上去了，那么远程访问一下博客。</p>
</li>
<li><p>访问博客<a href="https://yimaginer.github.io/">https://yimaginer.github.io/</a></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903142952837.png" alt="image-20230903142952837"></p>
<p>访问成功，至此我们在 Github 上搭建了一个幼儿园级的个人博客</p>
</li>
</ol>
</li>
</ol>
</li>
<li><h2 id="新增博文"><a href="#新增博文" class="headerlink" title="新增博文"></a>新增博文</h2><ol>
<li><p>将写好的 markdown 文档放进 site-dir&#x2F;source&#x2F;_posts 文件夹中</p>
</li>
<li><p><code>hexo generate</code> 重新生成</p>
</li>
<li><p><code>hexo deploy</code> 部署，如图</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230903144752739.png" alt="image-20230903144752739"></p>
</li>
<li><p>这样一个幼儿园博客，就实际使用来看还有下面的差距，如图编号</p>
<ol>
<li>博文是全篇展开放在主页，不科学</li>
<li>这个引用文字的格式转换成了这样，是这个默认主题的原因</li>
<li>新上传的文章没有标题，不行</li>
<li>博客的名称还是默认的，要改</li>
<li>顺便这配色不怎么好看</li>
</ol>
</li>
<li><p>接下里通过换一个主题，并进行设置，打造一个可以实际使用的博客。</p>
</li>
</ol>
</li>
</ol>
<p><strong>参考博客</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/550709268">利用Github DIY自己的个人博客</a></li>
<li><a href="https://www.cnblogs.com/Alight/p/4354294.html">这是一个有用的思考</a></li>
<li><a href="https://docs.github.com/zh/pages/quickstart">Github pages 官方文档</a></li>
</ul>
<p><strong>补充内容：hexo 命令的具象化解释</strong></p>
<p>执行完<code>hexo init</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902175759500.png" alt="image-20230902175759500"></p>
<p><code>hexo generate</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902180712442.png" alt="image-20230902180712442"></p>
<p><code>hexo clean</code>是把生成的东西清掉了</p>
<p><code>hexo d</code></p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230902181617668.png" alt="image-20230902181617668"></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>房地产研究</title>
    <url>/2023/09/07/%E6%88%BF%E5%9C%B0%E4%BA%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>房地产行业研究</p>
<span id="more"></span>

<ol>
<li><h1 id="财政危机与飞税制改革"><a href="#财政危机与飞税制改革" class="headerlink" title="财政危机与飞税制改革"></a>财政危机与飞税制改革</h1><ul>
<li>财政包干使得中央财政吃紧，中央财政对国防，教育，医疗投入面临经费匮乏</li>
<li>分税制把税分成三类<ul>
<li>中央税</li>
<li>地方税</li>
<li>共享税</li>
</ul>
</li>
<li>广东谈判<ul>
<li>分税制可以，但要将土地出让收入归地方</li>
</ul>
</li>
<li>分税制使得中央财政中央财政年均增幅超过了10%，1993年958亿，1994年2906亿，2021年9.15万亿。对经济有了足够的调控能力，开始加速对中国经济体制的改革。</li>
</ul>
</li>
<li><h1 id="“98房改”与三驾马车"><a href="#“98房改”与三驾马车" class="headerlink" title="“98房改”与三驾马车"></a>“98房改”与三驾马车</h1><ul>
<li><p>1997东南亚经济危机蔓延，中央消费，投资，出口三驾马车。</p>
</li>
<li><p>怎么构建，谁来拉动没有办法，1997年，京九铁路剪彩，王石做《分税制对企业的影响》，讨论了房地产行业能不能作为经济支柱。</p>
</li>
<li><p>房地产模式</p>
<ul>
<li>士地财政</li>
<li>商品房预售</li>
<li>信贷体系</li>
<li>钱从购房者手中到开发商，再到地方政府。本质是将居民未来几十年的收入提前预支获得天量资金，转换成财政收入，进行基建，招商引资。将地方政府发展过程中的部分债务转移到居民层面。</li>
</ul>
</li>
<li><p>1994年8月30日到9月2日土地使用制度改革工作会议</p>
<ul>
<li>制约我国发展经济和进行现代化建设的最大制约因素是资金不足</li>
<li>土地是我国经济建设和发展的巨大财富成为共识</li>
</ul>
</li>
<li><p>分税制下地方政府对于财政收入的巨大渴望，政府把主地一级市场的所有权逐渐收回。</p>
<ul>
<li>一开始的方式是无偿划拨和土地出让，但一直无法让土地价值最大化</li>
<li>国土资源部规定经营性土地，即用来建设商业、旅游、娱乐金融、服务业、商品房的土地必须执行“招拍挂”</li>
</ul>
</li>
<li><p>土地市场从无偿划拨到土地出让，与之对应的住房制度是福利分房到商品房，1998年国务院《关于进一步深化城镇住房制度政革，加快住房建设的通知》，即著名的<strong>98房改</strong>。<strong>取消福利分房，实现居民住宅货币化、私有化</strong>，住宅商品化拉开序幕。</p>
</li>
<li><p>购房补贴</p>
<ul>
<li>房价收入比&#x3D;本地一套60平经济适用房的平均价格&#x2F;双职工家庭的年平均工资</li>
<li>中央建设部副部长俞正声拍板，房价收入比大于4倍的要建立购房补贴</li>
<li>要想步履蹒跚的中国房地产引领中国经济走出亚洲经济危机，<strong>还缺两个发动机</strong></li>
</ul>
</li>
<li><p>1999年6月16日，原国家计划发展委员会和教育部联合发出紧急通知决定1999年中国高等教育在年初扩招23万人的基础上再扩大招生33.7万，普通高等院校招生总人数达到153万</p>
<ul>
<li>大学扩招成为拉动经济的基操</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212341823.png" alt="image-20230906212341823" style="zoom:67%;" /></li>
<li>人回红利和士地红利开始集中释放，中国经济的三驾马车包经完成其二</li>
</ul>
</li>
<li><p>2001年，中国加入WTO,三家马车最后一架来了，人口红利进一步得到释放</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906212720067.png" alt="image-20230906212720067" style="zoom:67%;" />

<p>评：房地产在那个特定时期发挥了它的经济拉动作用，推动我国的经济实力迅速上升，在房地产刚起步的年代，还是出现了许多在景观、产品细节、建筑风格、设计艺术上追求极致的好楼盘。没有高周转，没有夸张营销。</p>
<blockquote>
<p>美联储降息意味着什么？</p>
</blockquote>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906213751190.png" alt="image-20230906213751190"></p>
</li>
</ul>
</li>
<li><h1 id="“国十条”与第一次狂奔"><a href="#“国十条”与第一次狂奔" class="headerlink" title="“国十条”与第一次狂奔"></a>“国十条”与第一次狂奔</h1><ul>
<li><p>2004-2008年，房价良性增长，政府稳房价出台一系列政策</p>
<ul>
<li><p>2003明确房地产为支柱产业</p>
</li>
<li><p>2004“831大限”，解决协议出让的历史遗留问题</p>
</li>
<li><p>2005年3月，取消房贷优惠，首套房首付比例从20%上调至30%</p>
</li>
<li><p>2005年3月，老“国八条”，稳房价提高到政治高度</p>
</li>
<li><p>2005.10，二手房需缴纳个人所得税</p>
</li>
<li><p>2006年5月，国六条，7月，《关于规范房地产市场外资准入和管理的意见》</p>
</li>
<li><p>2007年，加大炒房客“资金成本”，5次加息。二套房首付比例不低于50%</p>
</li>
<li><p>2007年，王石在万科会议“海螺行动二”中说，中国楼市的拐点即将到来，随后万科率先降价</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906215643008.png" alt="image-20230906215643008"></p>
<p>跟风的房企并不多，但紧接着金融危机到来，消费低靡。房价下调蔓延开来，但是人性都是“买涨不买跌”，越降价越没人买。中国经济有“硬着陆的风险”</p>
</li>
</ul>
</li>
<li><p>2008年11月5日，发布进一步扩大内需，促进经济平稳较快发展的<strong>“国十条</strong>”，具体的方法是：</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906220739549.png" alt="image-20230906220739549"></p>
<p>央行5次降息，连续降息2.16%，大水漫灌。</p>
</li>
<li><p>国十条需要的资金从哪里来？是地方政府通过城投公司用<strong>土地</strong>向银行借贷得来的。所以房价不能降，于是各地开始疯狂救市。</p>
</li>
<li><p>2008救市</p>
<ul>
<li><p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223413007.png" alt="image-20230906223413007"></p>
</li>
<li><p>同时地方政府可以灵活指定特殊政策</p>
<ul>
<li>杭州“救市”24条，规定购买100万以士房产的客户可直接落户</li>
</ul>
</li>
<li><p>于是全国住宅均价平均上涨25.1%，全国一二线城市房价都在那两年翻了一番</p>
<ul>
<li><p>2008年郑州全年均价3960，到2010年12月已经张到了6493</p>
</li>
<li><p>陆家嘴</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906223922564.png" alt="image-20230906223922564"></p>
</li>
</ul>
</li>
<li><p>大量人员开始<strong>恐慌性置业</strong>。</p>
</li>
</ul>
</li>
<li><p>土地金融</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906224301852.png" alt="image-20230906224301852"></p>
<ul>
<li>这里面关键是土地价格不能降</li>
</ul>
</li>
<li><p>刹车</p>
<ul>
<li><p>楼市火热，GDP重回两位数，2010年1月10日中快发布了国十一条”，限购</p>
</li>
<li><p>2010年4月12日：新国十条发布，调控加码</p>
<ul>
<li>首套房且90以上，贷款首付款比例不得低于30%</li>
<li>二套房，首付比例不得低于50%，贷款利率率不得低于基准利率的1.1倍，按当时，二套房利率达到了6.53%</li>
<li>非本地居民暂停贷款，就是只能全款</li>
</ul>
</li>
<li><p>2010年10月开始，四次加息，首套房利率来到7.05%</p>
<blockquote>
<p>何为资产负债率，广义货币M2是什么？</p>
<p>美元加息为什么会让资本回流美国？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>反思：国十条有效拉动了经济复苏，可惜政策没有成熟的监管体系。钱都流向了房市，推高了房价。</p>
</li>
<li><h1 id="第二次狂奔"><a href="#第二次狂奔" class="headerlink" title="第二次狂奔"></a>第二次狂奔</h1><ul>
<li><p>2014加息导致美元资金回流，同时房地产行业供远大于求，导致了房地产低迷</p>
<ul>
<li>呼和浩特等取消<strong>限购</strong>，释放需求，</li>
<li>2014年9月30，央行，银监会下发《关于进一步做好住房金融服务工作的通知》，提出<strong>房贷结清后再购房可算首套</strong>，<strong>限贷</strong>缓和</li>
<li>同时下调贷款利率</li>
<li>相当于从政策端和货币端给房地产松绑。</li>
<li>然而这次的政策松绑并没有起到预期效果<ul>
<li>房价的持续低迷打破了永远涨的预期，不敢投资房产</li>
<li>库存大多是三四线城市，一二线城市扥松绑并不能对整体库存的消化起到明显作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>既然松绑失败，那就只能直接促进需求端的上涨，<strong>棚改货币化</strong></p>
<ul>
<li><p>棚改分为实物安置和货币安置</p>
</li>
<li><p>2014年6月26日，国家开发银行成立住宅金融事业部，针对棚改工作向地方政府发放贷款。</p>
</li>
<li><p>棚改的运作逻辑</p>
<img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230906233801487.png" alt="image-20230906233801487" style="zoom:50%;" />
</li>
<li><p>棚改各阶段分析</p>
<ul>
<li>第一阶段：2007-2012， 大多数居民选择实物安置，因此并没对楼市产生很大影响</li>
<li>第二阶段：2013-2014，住建部选择优先就近实物安置</li>
<li>第三阶段：2015-2018，国务院37号文件，强调提高货币化安置比例，因为要“三去”，货币化安置比例从2014年的9%上升到2016年的48.5%</li>
</ul>
</li>
<li><p>二线拆迁户率先冲入楼市，2016年：合肥、厦门、南京、苏州翻倍涨幅，史称“房价四小龙”</p>
</li>
<li><p>二线楼市上涨促进了三四五线城市拿到接力棒，对楼市发起冲锋。</p>
<ul>
<li>让一直深耕三四线的恒大，碧桂园在2016年完成业绩超车</li>
<li>引起房企下沉</li>
</ul>
</li>
</ul>
</li>
<li><p>2017年<strong>930调控潮</strong>，全国一二线共19个城市发布调控，开始“<strong>五限</strong>”</p>
<ul>
<li>限购</li>
<li>限贷</li>
<li>限售：购房之日起，三年&#x2F;五年&#x2F;十年之内不许上市买卖。直接拉长炒房客资金回收周期</li>
<li>限价：在商品房房价，出地最高拍卖价格两方面设定上限，楼市，土市双限价</li>
<li>限签：房屋备案合同在网上登记备案，叫做“网签”，网签后，这套房的价格信息就会在全国联网的房地产系统中记录在案。国家就可以知道各城市的房价指数，于是各地方政府怕自己房价上涨的太快被中央知道，于是就让高价房源暂缓网签。因此2017年之后的房价指数都是不准确的</li>
<li>结婚离婚如何成为钻制度空子的方法<ul>
<li>以合肥为例<ul>
<li>限购政策为：本市户口住房者至多拥有两套住房，非本市户口购房要满一年社保才能买一套</li>
<li>问题在于本地户口的认定，婚姻持续状态的夫妻按一户只能有两套住房资格，但离了婚就算两户，有四套的购房资格。</li>
<li>合肥楼市新政：离婚不满两年仍按原家庭进行房查</li>
</ul>
</li>
<li>海南<ul>
<li>2017年4月出台：非本省户口只能购买一套，本省户口没限制</li>
<li>于是炒房客与三亚适龄单身女青年假结婚，并将户口迁海南，买够想要的房后离婚。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一二线调控使得一些区位好的三四线成了炒房客的聚集地。如“环沪四县”，昆山、嘉善、启东、太仓</p>
</li>
<li><p>问题所在：</p>
<ul>
<li>健康发展的房地产可以拉动上下游实体经济发展</li>
<li>房价暴涨造成人心理的异化：你有100万准备投资实体，但是你在的城市一年房价翻翻了，那你怎么还会投资实体经济。</li>
<li>原本带动实体经济发展的房地产反倒成了资金吸血鬼，抢走了原本应该投向实体的资金，扩大了房地产的金融化和泡沫化。</li>
<li><strong>最致命</strong>：房地产市场成了不会下跌的股市，不断推高房价，高的房价就是高的生活成本，让年轻人不得不追求高收入的金融互联网，多少人的梦想从小时候的想当科学家艺术价变成想买一套房。实体产业的发展、科技创新、文化创新都成为了楼市发展的代价。</li>
</ul>
</li>
<li><p>2018年全国各地开始收紧货币化安置，失去了货币化安置购买力的房企开始陷入困局</p>
<ul>
<li>2018年9月，万科郁亮开会强调“活下去”</li>
</ul>
</li>
</ul>
<p>总结：棚改是重要的民生工作，房地产去库存是为了防范金融风险。但这个过程中，房价的泡沫让社会思想开始异化：</p>
<ul>
<li>房企为追求利润和扩张开启高周转，高负债，房子质量也十分堪忧</li>
<li>群众被高房价倒逼为了钱累死累活，有房有车作为婚姻门槛越来越遥不可及</li>
</ul>
</li>
<li><h1 id="高周转的血与泪"><a href="#高周转的血与泪" class="headerlink" title="高周转的血与泪"></a>高周转的血与泪</h1><p>- </p>
<ul>
<li><p>现象</p>
<ul>
<li>2020年315晚会首次曝光万科水帘洞问题，房价越来越高，质量越来越差是人民的实感。</li>
<li>2021年起，高负债房企恒大，融创，碧桂园接连爆雷</li>
</ul>
</li>
<li><p>勾地</p>
<ul>
<li><p>早期无偿划拨和协议出让，2002建立土地“招拍挂”制度以后拿地成本很不确定</p>
</li>
<li><p>勾地就是类似于万达，龙湖模式，住宅+商业中心，通常会和政府暗通款曲，量身打造招标条件，同时地价也会比纯住宅低</p>
</li>
<li><p>保证金制度</p>
<ul>
<li>如果想拿地，必须先缴纳一定数额保证金才拥有了报名资格。</li>
<li>拍到了，保证金转成土地款；没拍到，原路退回。</li>
</ul>
</li>
</ul>
</li>
<li><p>工程经济学中的现金流模型</p>
<ul>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912142256305.png" alt="image-20230912142256305"></li>
<li>当土地成本、借款利率、税费建安费都无法下降的时候，将目光转向了时间——<strong>高周转</strong><ul>
<li>拿地后尽快开工，尽快开盘，尽快回款</li>
<li>两件事上放慢<ul>
<li>推迟土地款的支付时间</li>
<li>延期支付施工单位的工程款，延期到开盘之后甚至现金流回正之后，减少了前期融资的需求，降低了资金成本</li>
</ul>
</li>
<li><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912143558648.png" alt="0"></li>
</ul>
</li>
</ul>
</li>
<li><p>现实中高周转如何落地呢？</p>
<ul>
<li>首先是开盘时间的提速，开盘时间越早，曲线上扬越早，偿还贷款，节省资金成本。 </li>
<li>销售速度，销售速度越快，现金流上升的斜率就越陡，</li>
<li>建设速度，这是前两者的必要条件</li>
<li>释放预售监管资金进入公司自有账户</li>
<li>在项目外建立庞大的资金池，和自有资金一起进行投资</li>
</ul>
<blockquote>
<p>容积率：建筑总面积&#x2F;净用地面积</p>
<p>货地比：房产销售额&#x2F;总土地款</p>
<p>预售条件：从拿地到销售，需要满足预售条件，不同地区预售条件不一样</p>
<p>预售资金管理：</p>
</blockquote>
<ul>
<li>万科高周转<ul>
<li>2004年，36岁郁亮（北大经济系）接棒王石，提出“10年时间万科业务翻10倍，销售冲击千亿”</li>
<li>“5986”模式<ul>
<li>拿地后5个月开工，9个月开盘</li>
<li>普通住宅占开盘房源8成，开盘后当月销量达6成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高周转恶性循环</p>
<ul>
<li>规模越大的房企越容易获得额度更大，利息更低的贷款；小规模获得贷款利息更高，甚至申请不下来。</li>
<li>越大的规模意味着更便宜的融资，以为着更低的资金成本，也以为着更能发展更大规模和利润。</li>
<li>房地产沦为了资金游戏，顺便盖个房子</li>
</ul>
</li>
<li><p>美元债</p>
<ul>
<li><p>2016年19城调控前，房企通过上市、信托等渠道筹集资金</p>
</li>
<li><p>2016-2017调控潮之后，房企在国内的融资收紧，于是开始转向美元债</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912153414464.png" alt="image-20230912153414464"></p>
</li>
<li><p>美元债与信用评级挂钩，于是房企在美元债“躺平”就是房企爆雷的标志。</p>
</li>
</ul>
</li>
<li><p>净资产收益率ROE</p>
<ul>
<li><p>调控措施让房企的利润下降，使得ROE这个指标对于房企来说更重要，</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912163753937.png" alt="image-20230912163753937"></p>
</li>
<li><p>从重视净利率到重视ROE反映的是行业玩法的改变，就是将自己手上的每一分钱的赚钱能力发挥到极致。因为做个约分就发现：ROE &#x3D; 净利润&#x2F;总权益资本</p>
</li>
<li><p>导致的结果就是，<strong>加杠杆</strong>，于是奇怪现象：</p>
<ul>
<li><p>想做房企的施工单位，可以，请给一个亿的无息借款</p>
</li>
<li><p>并且我给你的工程支付会一直延后，让我的现金流尽快回正。</p>
<blockquote>
<p>我不成跪着要饭的了？要真这么说，给高周转房企当总包还真就是跪着要饭的，就这，多少人想跪还没这门子呢！</p>
</blockquote>
</li>
<li><p>向员工融资：跟投项目+理财产品</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高负债率</p>
<ul>
<li>在高周转模式下，只要现金流不断，这个模式就可以一直玩下去。</li>
<li>房企高负债逐渐成为中国经济的恶性肿瘤</li>
<li>2017年，十九大报告提出的“三大攻坚战”之首就是防范化解重大风险</li>
<li>2018年开始中央出台一系列政策加大房企融资限制，准备对房企釜底抽薪。</li>
<li>2019年底，2020年初新冠黑天鹅，使得不得不量化宽松扶持微小企业发展，这些钱却被用来炒房，引发<strong>第三次狂奔</strong></li>
</ul>
</li>
</ul>
</li>
<li><h1 id="第三次狂奔与三道红线"><a href="#第三次狂奔与三道红线" class="headerlink" title="第三次狂奔与三道红线"></a>第三次狂奔与三道红线</h1><ul>
<li><p>经营贷炒房</p>
</li>
<li><p>三道红线</p>
<ul>
<li><strong>剔除预收账款的资金负债率</strong>不得大于70%</li>
<li><strong>净负债率</strong>不得大于100%</li>
<li><strong>现金短债比</strong>不得小于1倍</li>
</ul>
</li>
<li><p>剔除预收账款的资产负债率</p>
<ul>
<li>预收款&#x3D;首付+房贷回款</li>
<li>交房前预收款被算作负债，交房后倍算作收入</li>
<li>剔除预收账款的资产负债率&#x3D;（总负债-预收款）&#x2F;（总资产-预收款）</li>
</ul>
</li>
<li><p>净负债</p>
<ul>
<li>净负债 &#x3D; （有息负债-货币资金）&#x2F; 合并权益</li>
</ul>
</li>
<li><p>现金短债</p>
<ul>
<li>现金短债比 &#x3D; 货币资金 &#x2F; 短期有息负债</li>
</ul>
</li>
<li><p><strong>三道红线</strong>和<strong>限跌令</strong>下的房企</p>
<p><img src="https://picgo-buk.oss-cn-chengdu.aliyuncs.com/img/image-20230912203923915.png" alt="image-20230912203923915"></p>
</li>
</ul>
</li>
<li><h1 id="备用"><a href="#备用" class="headerlink" title="备用"></a>备用</h1><ul>
<li></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>房地产</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招笔试真题记录</title>
    <url>/2024/09/05/%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>记录秋招过程中的笔试算法题目</p>
<span id="more"></span>

<h4 id="0905-小米"><a href="#0905-小米" class="headerlink" title="0905 小米"></a>0905 小米</h4><ol>
<li><p>做面包</p>
<p>小明每天早上需要AB两种面包各一个，同时已知小明有 n 个面包机，n 个面包机做 A B 两种面包的时间分别是 a<del>i</del> ，b<del>i</del> 。可以选择用同一台面包机先后制作 A 和 B，这样时间是累加的，也可以选择用不同的面包机并行制作 A B, 这样时间取两块面包制作时间的大者。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表拥有面包机的数量。接下来有两行，每行 n 个数，第一行 n 个数代表 n 台面包机制作 A 面包的时间，第二行 n 个数代表 n 台面包机制作 B 面包的时间。</p>
<p><strong>输出格式：</strong></p>
<p>输出一个数，代表最短制作用时</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">2 6 8</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
<li><p>序列操作</p>
<p>给出一个数字序列，你可以有两种操作，一种是把某个元素加 1，第二种是直接删除某元素，最终期望达到的效果是所有元素之和是 x 的倍数</p>
<p><strong>输入格式：</strong></p>
<p>首行两个数字 n , x。n 代表数组长度， x 为上文描述的意义。</p>
<p><strong>输出格式：</strong></p>
<p>输出最少操作次数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 5 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目前 还没有太成熟的解法，想法是直接根据数据总和，以及数据元素，推算用两种方式各自需要多少次</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x; cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;<span class="type">int</span> t; cin &gt;&gt; t; a.<span class="built_in">push_back</span>(t), sum += t;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sum % x  == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (sum + <span class="number">1</span>) % x == <span class="number">0</span>) </span><br><span class="line">        &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(), sum % x);</span><br><span class="line">        <span class="keyword">if</span>(pos != a.<span class="built_in">end</span>() &amp;&amp; *pos == sum % x) </span><br><span class="line">            &#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pos &gt; sum % x &amp;&amp; pos != a.<span class="built_in">begin</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s1 = </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个题目有点像动态规划，但是似乎常规方法也可以，暂时没有很好的解法</li>
</ul>
</li>
<li><p>总结：</p>
<ol>
<li>其实题目算是很基础了，但一是心态，而是技术，两方面都需要加强<ol>
<li>心态应该更淡定一些</li>
<li>技术就是要多练</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="0908-饿了吗"><a href="#0908-饿了吗" class="headerlink" title="0908 饿了吗"></a>0908 饿了吗</h4><ol>
<li><p>排队时间</p>
<p>给出一个表示任务执行时间的序列，判断是否可以通过交换其中两个任务的位置，使得总等待时间尽可能小，若存在输出两个位置，不存在就输出 -1</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表任务的数量。接下来是 n 个数字，表示各个任务的处理时间</p>
<p><strong>输出格式：</strong></p>
<p>若存在输出两个位置，不存在就输出 -1</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">12131</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>
</li>
<li><p>权益值最小化</p>
<p>对整型数 a, b 来说，你可以有两种操作，分别变换为（a - b, b)  或 （a, b -a), 我们称 abs(a-b) 为 这队数字的权益值，给出一组这样的整数对，<strong>在使得他们的权益值之和最小前提下</strong>，问最小的操作次数。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表整数对数量，接下来 n 行，每行是两个整型数， 代表一个数对</p>
<p><strong>输出格式：</strong></p>
<p>输出分两行，第一行是最小权益值之和，第二行是对应操作次数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">2 6 8</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
<li><p>都市圈</p>
<p>n 个城市按批次规划高铁，每次规划会给出规划时间，联通城市数，对应的联通城市；被联通的城市称之为都市圈，然后询问在某个时间点上某个城市圈的人数总数？如果规划时间和询问时间一致，那么按照先执行规划再询问处理</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, 代表拥有面包机的数量。接下来有两行，每行 n 个数，第一行 n 个数代表 n 台面包机制作 A 面包的时间，第二行 n 个数代表 n 台面包机制作 B 面包的时间。</p>
<p><strong>输出格式：</strong></p>
<p>输出一个数，代表最短制作用时</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 4</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 2 1 3</span><br><span class="line">3 2 3 4</span><br><span class="line">5 2 2 5</span><br><span class="line">1 1</span><br><span class="line">5 5</span><br><span class="line">2 1</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
</ol>
<h4 id="0914-小红书"><a href="#0914-小红书" class="headerlink" title="0914 小红书"></a>0914 小红书</h4><ol>
<li><p>相似笔记（15分）</p>
<p>小红书笔记有点赞数，如果两篇笔记点赞数异或之后等于我们给定的 k 值，称两篇笔记相似。给你一个表示笔记点赞数的数组，判断这些笔记中有多少相似的。</p>
<p><strong>输入格式：</strong></p>
<p>首行 n, k。分别代表笔记数量，上文中的 k 值，接下来是 n 个数字，表示 n 篇笔记点赞数</p>
<p><strong>输出格式：</strong></p>
<p>相似笔记的对数</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：1 ^ 4 &#x3D; 5, 所以相似数量为2，(1,4) 和 (1,4)</p>
<p>n 的范围 1 - 10^5	k 及 点赞数范围 1 - 10^9</p>
</blockquote>
<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>桌子最大摆放方式</p>
<p>小红书有一个阅览室长宽高分别为 x y z, 这个阅览室是无重力的，因此里面的桌子可以随意漂浮，给你一个体积为 V 的桌子，桌子的边长可以是任意整数，只要保证体积是 v ,让桌子各边平行于阅览室各轴，并且各个角都位于整数坐标。问桌子可能的最大可摆放的位置数量</p>
<p><strong>输入格式：</strong></p>
<p>首行T, 代表接下来的数据组数。每组数构成为 x y z v，四个数的意义与上面一致</p>
<p><strong>输出格式：</strong></p>
<p>每组情况下桌子的最大摆放方式</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 2 2</span><br><span class="line">1 2 3 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>完全没有思路！</p>
</li>
<li><p>树上距离</p>
<p>小红有一棵 n 个节点， n - 1条变构成的树，边的权重为 w<del>i</del>, 定义树的两个点(u,v)权值为，从 u 到 v 的简单路径上全部边的异或和，特别的当 u 和 v 是同一个点，权值为 0，小红会进行 q 次询问，询问有多少个点到 u 的路径和恰好为 k</p>
<p><strong>输入格式：</strong></p>
<p>首行 n,q,分别代表树的节点数和询问次数，此后 n -  1 行，每行三个整数 u v w，表示 u v 之间有边，权值为 w, 数据保证树联通，没有重边，此后 q 行，每行 u k, 分别表示询问的节点和限定</p>
<p><strong>输出格式：</strong></p>
<p>每个询问输出一个整数，代表到 u 节点距离为 k 的节点数量</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">1 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>n q 范围 1 - 10^5,  u &lt;&#x3D; n, k 范围 0 - 2^60</p>
</blockquote>
<p>答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure>

<p>这个想对简单只需要把各自AB两种面包最小值算出来即可。略</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/07/08/%E5%BE%85%E5%A4%84%E7%90%86/0708%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li>围绕简历自我介绍5min</li>
<li>拷问<ul>
<li>多路复用IO</li>
<li>c++ const static 关键字特性</li>
<li>智能指针</li>
<li>虚函数机制</li>
<li>面向对象三大特性</li>
</ul>
</li>
<li>智力题<ul>
<li>100层楼，两个球</li>
</ul>
</li>
<li>算法<ul>
<li>深拷贝随机链表</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2024/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>问题描述： n 个物体，每个物体重量价值分别为 w v , 在此基础上用承重为 W 的包去装物体，以使所装物体价值最大化。</p>
<ul>
<li>0-1 背包 ：每件物品最多用一次</li>
<li>完全背包：每件物品有无限个</li>
<li>多重背包：每个物品设置一个上限 s</li>
<li>分组背包：物品之间分成组，组内物品互斥选择</li>
<li>分析方法：  <ul>
<li><strong>状态表示</strong>：什么集合的什么属性</li>
<li><strong>状态计算</strong>：当前状态怎么由前置状态转移过来</li>
</ul>
</li>
</ul>
<h4 id="0-1-背包："><a href="#0-1-背包：" class="headerlink" title="0-1 背包："></a>0-1 背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 朴素方法</span></span><br><span class="line"><span class="type">int</span> v[N];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[M];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[N][M];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i])  </span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line"><span class="comment">// 一维</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)  </span><br><span class="line">    	f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);	<span class="comment">// 选和不选，从上层转移过来，所以逆序</span></span><br><span class="line"><span class="comment">// 边输入边处理</span></span><br><span class="line">cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">    f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br></pre></td></tr></table></figure>

<p>解：<a href="https://www.acwing.com/solution/content/1374/">https://www.acwing.com/solution/content/1374/</a></p>
<p>分析方法：<a href="https://www.acwing.com/problem/content/discussion/content/2807/">https://www.acwing.com/problem/content/discussion/content/2807/</a></p>
<h4 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 朴素版本：o(nm*m)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);</span><br><span class="line">    <span class="comment">//  为何括号中第一个是 f[i][j] 而不是 f[i-1][j]</span></span><br><span class="line">    <span class="comment">//  由于 k=0 必执行，这次执行确定性把 f[i][j] 赋值为 f[i-1][j]</span></span><br><span class="line"><span class="comment">// 观察现象：</span></span><br><span class="line">    <span class="comment">//  f[i][j] = max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,)</span></span><br><span class="line">    <span class="comment">//  f[i][j-v] = max(       ,f[i-1][j-v],  f[i-1][j-2v]+w ,f[i-1][j-3v]+2v,)</span></span><br><span class="line">    <span class="comment">//  f[i][j] = max(f[i-1][j],f[i][j-v]+w)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 由此，改进版本 O(nm)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][j];<span class="comment">//v[i] 之前，第 i 个物品放不进去，直接搬下来就行</span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;=v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">        <span class="comment">// 这次优化可以从上面的max计算的规律去想，也可以从f[i][j]依赖f[i][j-v[i]]去理解</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 至此，对比 0-1 背包和完全背包的转移方程</span></span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-v[i]] + w[i])  <span class="comment">// 都是从上一行转移过来</span></span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-v[i]] + w[i])	<span class="comment">// 从上一行和同行的前置位过来，这里依赖同行的前置位，故不能倒序</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 3. 改进成一维 O(nm)</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++)</span><br><span class="line">		f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);     <span class="comment">// f[j-v[i]] 和 f[j] 有绝对的 w[i] 差值</span></span><br></pre></td></tr></table></figure>

<h4 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 朴素解法 O(nmm)</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 1 开始，将数据录入和物品编号实际对应，虽然浪费一个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k*v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k * w[i]); </span><br><span class="line"><span class="comment">// 2. 一维解法 O(nmm)</span></span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v]+w,f[i<span class="number">-1</span>][j<span class="number">-2</span>v]<span class="number">+2</span>w,f[i<span class="number">-1</span>][j<span class="number">-3</span>v]<span class="number">+3</span>w,...,f[i<span class="number">-1</span>][j-sv]+sw)</span><br><span class="line">f[i][j-v]=<span class="built_in">max</span>(          f[i<span class="number">-1</span>][j-v],  f[i<span class="number">-1</span>][j<span class="number">-2</span>v]+w, f[i<span class="number">-1</span>][j<span class="number">-3</span>v]<span class="number">+2</span>w,...,f[i<span class="number">-1</span>][j-sv]+(s<span class="number">-1</span>)w,f[i<span class="number">-1</span>][j-(s<span class="number">+1</span>)v]+sw)</span><br><span class="line"><span class="comment">// 遗憾的是得知后面的最大值 f[i][j-v] ，并不能推知其子集f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,...,f[i-1][j-sv]+sw 的最大值，因此不能像完全背包一样依赖前置位。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)</span><br><span class="line">            <span class="keyword">if</span>(k*v[i]&lt;=j) f[j]=<span class="built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);</span><br><span class="line"><span class="comment">// 3. 二进制拆分优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>, M = <span class="number">2010</span>;</span><br><span class="line"><span class="comment">//  25000来历：n,s取值都在2000之内，那么s个同类物品最多被分为log(s)组，也即最多11组，2000种物品算起来最多的组为2000*11</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">//逐一枚举最大是N*logS</span></span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// 体积&lt;M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(k&lt;=s) <span class="comment">// 按2的阶乘分组</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ; </span><br><span class="line">            v[cnt] = a * k ;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k; </span><br><span class="line">            k *= <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a*s; </span><br><span class="line">            w[cnt] = b*s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt ; </span><br><span class="line">    <span class="comment">//01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n ;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m ;j &gt;= v[i];j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分组背包："><a href="#分组背包：" class="headerlink" title="分组背包："></a>分组背包：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N];</span><br><span class="line"><span class="type">int</span> f[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">      </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 采用一维时：数据依赖上一行，则倒序；依赖同一行前置位则正序。</span></span><br></pre></td></tr></table></figure>

<h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><h4 id="数字三角形-acwing-898"><a href="#数字三角形-acwing-898" class="headerlink" title="数字三角形 acwing 898"></a>数字三角形 <a href="https://www.acwing.com/problem/content/description/900/">acwing 898</a></h4><ul>
<li>思路：<ul>
<li>状态表示（集合，属性）：到达任意坐标（i, j) 的路径和的最大值为 f[i][j]</li>
<li>状态转移 ： 这个最大值要么从左边转移过来，要么从右边转移过来，故 f[i][j] &#x3D; max(f[i -  1][j - 1] , f[i -  1][j]) +  a[i][j]</li>
</ul>
</li>
<li>其他注意事项：<ul>
<li>要想让三角形边界选到三角形内的数据，就要把 f 数组中三角形边界设置为负无穷</li>
<li>题目要求是到最底层，结果要在 f 数组的最后一行中找，极端情况下，所有元素都是最小值，累积出来的路径和会很小，因此，用于遍历最后一行的值也要设无穷小。</li>
<li>左右的坐标相对位置要找对</li>
</ul>
</li>
<li>其他解法：倒序遍历，相当于从底部走到顶部<a href="https://www.acwing.com/solution/content/128359/">https://www.acwing.com/solution/content/128359/</a></li>
</ul>
<h4 id="最长上升子序列-acwing-895"><a href="#最长上升子序列-acwing-895" class="headerlink" title="最长上升子序列 acwing 895"></a>最长上升子序列 <a href="https://www.acwing.com/activity/content/problem/content/1003/">acwing 895</a></h4><ul>
<li>思路1<ul>
<li>状态表示（集合，属性）：以 i 结尾的最长单调子序列长度为 f[i]</li>
<li>状态转移：遍历前面 i - 1个 f 数组元素，遇到 w[i] &gt; w[j] 则，f[i] &#x3D; max(f[i], f[j] +  1), 没遇到则 f[i] &#x3D;  1</li>
<li>时间复杂度：状态数(n) * 转移数(n)，O(n^2),</li>
</ul>
</li>
<li>思路2<ul>
<li>维护一个初始为空的递增序列 dp，遍历存储数组中的所有元素，找到其在递增序列中第一个大于等于其值的位置<ul>
<li>如果找到末尾，就在dp 末尾增加当前元素</li>
<li>如果是中间，就替换当前位置元素</li>
</ul>
</li>
<li>复杂度分析：O(nlogn) ，状态数(n) * 转移数(logn)</li>
<li>利用二分的解法： <a href="https://www.acwing.com/solution/content/4807/">https://www.acwing.com/solution/content/4807/</a></li>
</ul>
</li>
</ul>
<h4 id="最长公共子序列-acwing-897"><a href="#最长公共子序列-acwing-897" class="headerlink" title="最长公共子序列 acwing 897"></a>最长公共子序列 <a href="https://www.acwing.com/activity/content/problem/content/1005/">acwing 897</a></h4><ul>
<li>思路<ul>
<li>状态表示：f[i][j] A 的前 i 个字符， B 的前 j 个字符的公共子序列 的最长公共子序列</li>
<li>状态转移：f[i][j] 可以由以下四个状态变换过来：<ul>
<li>a[i],b[j] 均存在于 最长公共子序列中 (前提a[i]&#x3D;&#x3D;b[j])</li>
<li>a[i] 在，b[j] 不在   （无前提），不完全等同于  f[i][j - 1] </li>
<li>a[i],b[j] 均不在     （无前提）</li>
<li>a[i]不在，b[j]在     （无前提）</li>
</ul>
</li>
<li>更详细的分析：<a href="https://www.acwing.com/solution/content/48820/">https://www.acwing.com/solution/content/48820/</a></li>
</ul>
</li>
</ul>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><ul>
<li>思路<ul>
<li>状态表示</li>
<li>状态转移</li>
</ul>
</li>
</ul>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><h2 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h2>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LibAFL入门</title>
    <url>/2024/09/05/%E5%BE%85%E5%A4%84%E7%90%86/LibAFL%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>原文地址：<a href="https://www.atredis.com/blog/2023/12/4/a-libafl-introductory-workshop">LibAFL Introductory workshop — Atredis Partners</a></p>
<p>来自一家很酷的公司：<a href="https://www.atredis.com/careers">Careers — Atredis Partners</a></p>
<hr>
<span id="more"></span>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="为什么选择-LibAFL"><a href="#为什么选择-LibAFL" class="headerlink" title="为什么选择 LibAFL"></a>为什么选择 LibAFL</h2><p>Fuzzing（模糊测试）非常棒！在正确的设置下，快速地向目标投掷随机输入可以产生不合理的效果。当开始一个新的目标时，模糊测试的框架可以与你的逆向工程&#x2F;审计工作一起迭代，你可以安心地睡觉，知道你的核心在夜间值班。在寻找漏洞时，我们的时间通常是有限的；任何花在工具上的努力都需要是值得的。LibAFL 是一个很棒的库，可以让我们快速地将模糊测试器适应我们的特定目标。并不是每个目标都适合“解析文件的命令行程序”类别，因此 LibAFL 让我们为特定情况制作模糊测试器。这种适应性为更广泛的目标打开了模糊测试的力量。</p>
<h2 id="为什么举办研讨会"><a href="#为什么举办研讨会" class="headerlink" title="为什么举办研讨会"></a>为什么举办研讨会</h2><p>以下材料来自一个内部研讨会，用作对 LibAFL 的介绍。这篇文章是对研讨会的总结，并包括一个练习和示例的仓库，供你在家跟随。它期望你已经有一些 Rust 和模糊测试概念的理解。（如果你需要复习 Rust：Google 的全面 Rust 是很棒的。）</p>
<p>已经有一些很好的资源可以学习 LibAFL。</p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>这个研讨会旨在增加用 LibAFL 构建的示例模糊测试器的现有语料库，重点是将模糊测试器定制到我们的目标。你还会找到一些入门问题，以便你亲手体验 LibAFL。在整个研讨会中，我们尝试突出库的多功能性和力量，让你看看你可以在哪里将模糊测试器融入你的流程。</p>
<h2 id="课程预告"><a href="#课程预告" class="headerlink" title="课程预告"></a>课程预告</h2><p>顺便说一句，如果你对这类事情（安全工具、漏洞、模糊测试）感兴趣，你可能会对我们的符号执行课程感兴趣。我们计划在 2024 年 2 月与 ringzer0 举行一次虚拟会议。本文末尾有更多信息。</p>
<h2 id="模糊测试器"><a href="#模糊测试器" class="headerlink" title="模糊测试器"></a>模糊测试器</h2><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在整个研讨会中，我们一直在测试一个在 Linux 上运行的简单目标。这个目标本身并不是很有趣，但作为我们模糊测试器的一个很好的示例目标。它逐行接收一些文本，并替换某些标识符（如 <code>&#123;&#123;XXd3sMRBIGGGz5b2&#125;&#125;</code>）为名称。为此，它包含一个具有非常大查找树的函数。在这个函数中，许多查找情况可能导致段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">uid_to_name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* uid)</span> &#123;</span><br><span class="line">    <span class="comment">/*...*/</span> <span class="comment">// 大量的嵌套 switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (nbuf[<span class="number">14</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="comment">// 常规情况，没有段错误</span></span><br><span class="line">        addr = &amp;names[<span class="number">0x4b9</span>];</span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:</span><br><span class="line">        <span class="comment">// 一个坏情况</span></span><br><span class="line">        addr = ((<span class="type">const</span> <span class="type">char</span>**)<span class="number">0x68c2</span>);</span><br><span class="line">        <span class="comment">// 这里 SEGFAULT</span></span><br><span class="line">        LOG(<span class="string">&quot;UID matches known name at %p&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">return</span> *addr;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>

<p>这为我们提供了一个目标，它有许多不同的代码路径，并且有许多可达到的“漏洞”可以发现。随着我们的进展，我们将适应我们的模糊测试器到这个目标，展示一些常见的方法，我们可以使用 LibAFL 将模糊测试器塑造成一个目标。</p>
<p>你可以在这里找到我们的目标，并且仓库包括一些稍后示例中有用的变体。<a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target.c">.&#x2F;fuzz_target&#x2F;target.c</a></p>
<h2 id="模糊测试器的组成部分"><a href="#模糊测试器的组成部分" class="headerlink" title="模糊测试器的组成部分"></a>模糊测试器的组成部分</h2><p>在我们深入示例之前，让我们快速了解一下现代模糊测试器的内部结构。LibAFL 将模糊测试器分解为可以互换或更改的部分。LibAFL 充分利用了 <a href="https://google.github.io/comprehensive-rust/methods-and-traits/traits.html">Rust 的特性系统</a>来做到这一点。下面我们有一个非常简单的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器的脚本可能像下面这样简单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ! [ -f ./core.* ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">head</span> -c 900 /dev/urandom &gt; ./testfile</span><br><span class="line">    <span class="built_in">cat</span> ./testfile | ./target</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>上面的简单模糊测试器遵循三个核心步骤。</p>
<ol>
<li>生成一个随机输入</li>
<li>使用新输入运行目标</li>
<li>如果创建的输入导致“胜利”（在这种情况下，胜利是产生核心文件的崩溃），则保留该输入</li>
</ol>
<p>如果你错过了上述任何部分，你将不会有一个非常好的模糊测试器。我们都听说过研究人员将随机输入管道到他们的目标，得到了一个令人兴奋的崩溃，但因为他们没有保存测试用例，所以再也无法重现该漏洞的悲惨故事。</p>
<p>即使有了上述部分，那个简单的模糊测试器也会在发现漏洞方面挣扎。它甚至没有进展的概念！下面我们有一个更现代的模糊测试器的图表。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"></p>
<p>这个模糊测试器基于一组现有的输入，这些输入被随机变异以创建新的测试用例。“变异”只是一组可以快速应用于输入的简单修改，以生成新的有趣的输入。重要的是，这个模糊测试器还使用执行目标的观察结果来知道输入是否“有趣”。与仅关心崩溃的模糊测试器不同，具有反馈的模糊测试器可以将变异的测试用例重新路由到要变异的输入集中。这允许模糊测试器通过迭代输入，跟踪目标中有趣的功能来取得进展。</p>
<p>LibAFL 为这些“部分”中的每一个提供了工具。</p>
<ul>
<li>实现 <code>Executor</code> 特性的将使用给定的测试用例运行目标。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html">https://docs.rs/libafl/latest/libafl/executors/trait.Executor.html</a></li>
</ul>
</li>
<li><code>Corpus</code> 特性是用于保存一组测试用例的项目，通常用于输入或解决方案。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html">https://docs.rs/libafl/latest/libafl/corpus/trait.Corpus.html</a></li>
</ul>
</li>
<li>实现 <code>Scheduler</code> 特性的东西负责从语料库中选择输入以制作下一个测试用例。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html">https://docs.rs/libafl/latest/libafl/schedulers/trait.Scheduler.html</a></li>
</ul>
</li>
<li>实现 <code>Mutator</code> 特性的提供在运行前更改输入的修改。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html">https://docs.rs/libafl/latest/libafl/mutators/trait.Mutator.html</a></li>
</ul>
</li>
<li><code>Feedback</code> 和 <code>Observer</code> 特性提供了有用的工具，用于决定输入是否有用。<ul>
<li><a href="https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html">https://docs.rs/libafl/latest/libafl/feedbacks/trait.Feedback.html</a></li>
<li><a href="https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html">https://docs.rs/libafl/latest/libafl/observers/trait.Observer.html</a></li>
</ul>
</li>
</ul>
<p>我们还将看到其他重要的特性。一定要查看特性文档中的“实现者”部分，看看库提供的有用实现。</p>
<h2 id="Exec-模糊测试器"><a href="#Exec-模糊测试器" class="headerlink" title="Exec 模糊测试器"></a>Exec 模糊测试器</h2><p>这就带我们来到了我们的第一个示例！让我们通过使用 LibAFL 的一个基本模糊测试器来逐步了解。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer/src/main.rs">.&#x2F;exec_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>源代码有详细的注释，你应该仔细阅读。这里我们只突出一些关键部分。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = CommandExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!())</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = StdState::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            StdRand::<span class="title function_ invoke__">with_seed</span>(<span class="title function_ invoke__">current_nanos</span>()),</span><br><span class="line">            InMemoryCorpus::&lt;BytesInput&gt;::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            OnDiskCorpus::<span class="title function_ invoke__">new</span>(PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;./solutions&quot;</span>)).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">            &amp;<span class="keyword">mut</span> feedback,</span><br><span class="line">            &amp;<span class="keyword">mut</span> objective,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>我们的模糊测试器使用一个“状态”对象，该对象跟踪输入测试用例的集合、任何解决方案测试用例以及其他元数据。注意我们选择将输入保存在内存中，但将解决方案测试用例保存到磁盘上。</p>
<p>我们使用 <code>CommandExecutor</code> 来执行我们的目标程序，它将运行目标进程并传入测试用例。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            <span class="title function_ invoke__">havoc_mutations</span>(),</span><br><span class="line">            <span class="number">9</span>,                 <span class="comment">// 最大变异迭代次数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stages</span> = tuple_list!(StdMutationalStage::<span class="title function_ invoke__">new</span>(mutator));</span><br></pre></td></tr></table></figure>

<p>我们为输入构建了一个非常简单的管道。这个管道只有一个阶段，它将为每个测试用例随机选择一组变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">scheduler</span> = RandScheduler::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fuzzer</span> = StdFuzzer::<span class="title function_ invoke__">new</span>(scheduler, feedback, objective);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载我们状态中的初始语料库</span></span><br><span class="line">        <span class="comment">// 由于我们在这个模糊测试器中缺乏反馈，我们必须强制执行</span></span><br><span class="line">        state.<span class="title function_ invoke__">load_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> mgr, &amp;[PathBuf::<span class="title function_ invoke__">from</span>(<span class="string">&quot;../fuzz_target/corpus/&quot;</span>)]).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模糊测试</span></span><br><span class="line">        fuzzer.<span class="title function_ invoke__">fuzz_loop</span>(&amp;<span class="keyword">mut</span> stages, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> state, &amp;<span class="keyword">mut</span> mgr).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error in fuzz loop&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过一个调度器和一些反馈（这里我们使用 <code>ConstFeedback::False</code> 来没有任何反馈，除了目标反馈，这是一个 <code>CrashFeedback</code>），我们可以加载我们的初始条目并开始模糊测试。我们使用创建的阶段、选择的执行器、状态和一个事件管理器来开始模糊测试。我们的事件管理器将让我们知道当我们开始获得“胜利”时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan exec_fuzzer]$ ./target/release/exec_fuzzer/</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 3, objectives: 0, executions: 3, exec/sec: 0.000</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 3, objectives: 1, executions: 3, exec/sec: 2.932</span><br><span class="line">[Stats #0] run time: 0h-0m-15s, clients: 1, corpus: 3, objectives: 1, executions: 38863, exec/sec: 2.590k</span><br><span class="line">[Objective #0] run time: 0h-0m-20s, clients: 1, corpus: 3, objectives: 2, executions: 38863, exec/sec: 1.885k</span><br></pre></td></tr></table></figure>

<p>我们脆弱的目标很快就开始给我们崩溃，即使没有反馈。从一组有用的输入开始有助于我们的变异能够找到崩溃的输入。</p>
<p>这个简单的执行模糊测试器为我们提供了一个良好的基础，我们可以在此基础上添加更多功能。</p>
<h2 id="带自定义反馈的-Exec-模糊测试器"><a href="#带自定义反馈的-Exec-模糊测试器" class="headerlink" title="带自定义反馈的 Exec 模糊测试器"></a>带自定义反馈的 Exec 模糊测试器</h2><p>没有反馈，我们就不能有效地迭代有趣的输入。目前我们的随机变异必须一次性生成一个崩溃的案例。如果我们能向模糊测试器添加反馈，那么我们就可以识别出做了一些有趣事情的测试用例。我们将这些有趣的测试用例循环回我们的测试用例集中，进行进一步的变异。</p>
<p>我们可以从许多不同的来源获取这些信息。对于这个示例，让我们使用 <code>fuzz_target/target_dbg</code> 二进制文件，这是我们目标的调试输出版本。通过查看这个调试输出，我们可以开始识别有趣的案例。如果一个测试用例让我们得到了我们之前没有见过的调试输出，那么我们可以认为它是有趣的，值得进一步迭代。</p>
<p>LibAFL 库中没有这种反馈的现有实现，所以我们必须自己制作！如果你想自己尝试，我们在仓库中提供了一个模板文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/exec_fuzzer_stderr_template">.&#x2F;exec_fuzzer_stderr_template&#x2F;</a></p>
<p>LibAFL 仓库提供了一个 <code>StdErrObserver</code> 结构，我们可以将其与我们的 <code>CommandExecutor</code> 一起使用。这个观察者将允许我们的自定义反馈结构接收我们运行的 <code>stderr</code> 输出。我们所要做的就是创建一个实现 <code>Feedback</code> 特性的 <code>is_interesting</code> 方法的结构，我们就应该可以开始了。在该方法中，我们提供了状态、变异输入、观察者。我们只需要从 StdErrObserver 获取调试输出，并确定我们是否到达了新的位置。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S&gt; Feedback&lt;S&gt; <span class="keyword">for</span> <span class="title class_">NewOutputFeedback</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: UsesInput + HasClientPerfMonitor,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">        _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">        _input: &amp;S::Input,</span><br><span class="line">        observers: &amp;OT,</span><br><span class="line">        _exit_kind: &amp;ExitKind</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">        OT: ObserversTuple&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回 Ok(false) 对于不有趣的输入</span></span><br><span class="line">        <span class="comment">// 返回 Ok(true) 对于有趣的输入</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我鼓励你自己尝试实现这个反馈。你可能想要找到一些启发式方法来忽略无帮助的调试消息。我们希望避免报告太多的输入作为有用的，这样我们就不会过度填充我们的输入语料库。输入语料库是我们用于生成新测试用例的输入集。如果语料库中有太多实际上并没有帮助我们挖掘胜利的输入，我们将浪费大量时间。理想情况下，我们希望这些输入尽可能小且运行速度快，同时在我们的目标中执行独特的路径。</p>
<p>在我们的解决方案中，我们简单地保持一组已看到的哈希。如果我们看到它导致了一个独特的哈希，我们就会报告输入是有趣的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/exec_fuzzer_stderr/src/main.rs">.&#x2F;exec_fuzzer_stderr&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">is_interesting</span>&lt;EM, OT&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            _state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            _manager: &amp;<span class="keyword">mut</span> EM,</span><br><span class="line">            _input: &amp;S::Input,</span><br><span class="line">            observers: &amp;OT,</span><br><span class="line">            _exit_kind: &amp;ExitKind</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt;</span><br><span class="line">           <span class="keyword">where</span> EM: EventFirer&lt;State = S&gt;,</span><br><span class="line">                 OT: ObserversTuple&lt;S&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">observer</span> = observers.match_name::&lt;StdErrObserver&gt;(&amp;<span class="keyword">self</span>.observer_name)</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;A NewOutputFeedback needs a StdErrObserver&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = DefaultHasher::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            hasher.<span class="title function_ invoke__">write</span>(&amp;observer.stderr.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">contains</span>(&amp;hash) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">false</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.hash_set.<span class="title function_ invoke__">insert</span>(hash);</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这最终非常快地找到了“有趣”的输入，并迅速增加了我们的输入语料库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 308, objectives: 0, executions: 4388, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 0, executions: 4423, exec/sec: 2.520k</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 309, objectives: 1, executions: 4423, exec/sec: 2.497k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 310, objectives: 1, executions: 4532, exec/sec: 2.520k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 311, objectives: 1, executions: 4629, exec/sec: 2.521k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="代码覆盖率反馈"><a href="#代码覆盖率反馈" class="headerlink" title="代码覆盖率反馈"></a>代码覆盖率反馈</h2><p>依赖程序的正常副作用（如调试输出、系统交互等）并不是深入探索目标的可靠方法。使用这种反馈，我们可能会错过许多有趣的特性。许多现代模糊测试器的首选反馈是“代码覆盖率”。通过观察哪些代码块正在被执行，我们可以了解哪些输入暴露了有趣的逻辑。</p>
<p>然而，收集这些信息并不总是直接的。如果你可以访问源代码，你可能可以使用编译器来为代码添加这些信息。如果没有，你可能必须通过二进制修改、仿真或其他来源动态地为你的目标添加工具。</p>
<p>AFL++ 提供了一个版本的 clang，用于编译器级别的工具，提供代码覆盖率反馈。LibAFL 可以观察这种工具生成的信息，我们可以使用它作为反馈。我们有一个使用 <code>afl-clang-fast</code> 构建的目标。有了这个构建（ <code>target_instrumented</code>），我们可以使用 LibAFL 的 <code>ForkserverExecutor</code> 与我们的工具目标进行通信。<code>HitcountsMapObserver</code> 可以使用共享内存来接收每次运行的覆盖率信息。</p>
<p>你可以在这里看到我们模糊测试器的代码。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_fuzzer/src/main.rs">.&#x2F;aflcc_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem_provider</span> = UnixShMemProvider::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">shmem</span> = shmem_provider.<span class="title function_ invoke__">new_shmem</span>(MAP_SIZE).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="comment">// 将 id 写入环境变量以供 forkserver 使用</span></span><br><span class="line">        shmem.<span class="title function_ invoke__">write_to_env</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shmembuf</span> = shmem.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line">        <span class="comment">// 基于该缓冲区构建观察者，与目标共享</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">edges_observer</span> = <span class="keyword">unsafe</span> &#123;HitcountsMapObserver::<span class="title function_ invoke__">new</span>(StdMapObserver::<span class="title function_ invoke__">new</span>(<span class="string">&quot;shared_mem&quot;</span>, shmembuf))&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用观察到的覆盖率来反馈基于获得最大覆盖率</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">feedback</span> = MaxMapFeedback::<span class="title function_ invoke__">tracking</span>(&amp;edges_observer, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 这次我们可以使用 fork 服务器执行器，它使用 instrumented in fork server</span></span><br><span class="line">    <span class="comment">// 它通过分叉部分实例化的过程而不是每次从头开始，从而获得更多的每秒执行次数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">        .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_instrumented&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">        .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>编译的 fork 服务器还应该减少我们需要实例化运行的时间，通过分叉部分实例化的过程而不是从头开始。这应该抵消我们工具的一些成本。</p>
<p>执行时，我们的模糊测试器迅速找到了新的过程路径，建立了我们有趣的案例语料库，并指导我们的模糊测试器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan aflcc_fuzzer]$ ./target/release/aflcc_fuzzer</span><br><span class="line"></span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 1, objectives: 0, executions: 1, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">[Stats #0] run time: 0h-0m-0s, clients: 1, corpus: 2, objectives: 0, executions: 2, exec/sec: 0.000</span><br><span class="line">...</span><br><span class="line">[Testcase #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 0, executions: 19152, exec/sec: 1.823k</span><br><span class="line">[Objective #0] run time: 0h-0m-10s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.762k</span><br><span class="line">[Stats #0] run time: 0h-0m-11s, clients: 1, corpus: 100, objectives: 1, executions: 19152, exec/sec: 1.723k</span><br><span class="line">[Testcase #0] run time: 0h-0m-11s, clients: 1, corpus: 101, objectives: 1, executions: 20250, exec/sec: 1.821k</span><br></pre></td></tr></table></figure>

<h2 id="自定义变异"><a href="#自定义变异" class="headerlink" title="自定义变异"></a>自定义变异</h2><p>到目前为止，我们一直在使用 <code>havoc_mutations</code>，你可以看到这里是一组对许多目标都非常好的变异。</p>
<p><a href="https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296">https://github.com/AFLplusplus/LibAFL/blob/bd12e060ca263ea650ece0a51a355ac714e7ce75/libafl/src/mutators/scheduled.rs#L296</a></p>
<p>这些变异中的许多对我们的目标来说是浪费的。为了到达易受攻击的 <code>uid_to_name</code> 函数，输入首先必须通过 <code>valid_uid</code> 检查。在这个检查中，范围之外的字符 <code>A-Za-z0-9\-_</code> 被拒绝。许多 <code>havoc_mutations</code>，例如 <code>BytesRandInsertMutator</code>，将引入不在该范围内的字符。这导致许多测试用例被浪费。</p>
<p>有了关于我们目标的这些知识，我们可以使用一个自定义变异器，它只会在所需的范围内插入新的字节。实现 <code>Mutator</code> 特性很简单，我们只需要提供一个 <code>mutate</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">impl</span>&lt;I, S&gt; Mutator&lt;I, S&gt; <span class="keyword">for</span> <span class="title class_">AlphaByteSwapMutator</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        I: HasBytesVec,</span><br><span class="line">        S: HasRand,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                return Ok(MutationResult::Mutated) when you mutate the input</span></span><br><span class="line"><span class="comment">                or Ok(MutationResult::Skipped) when you don&#x27;t</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果你想自己尝试这个，欢迎使用 <code>aflcc_custom_mut_template</code> 作为起点。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_mut_template/">.&#x2F;aflcc_custom_mut_template&#x2F;</a></p>
<p>在我们的解决方案中，我们使用一组变异器，包括我们的新 <code>AlphaByteSwapMutator</code> 和一些现有的变异器。这个集合应该会产生更多的有效测试用例，使其到达 <code>uid_to_name</code> 函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们将指定我们的自定义变异器，以及另外两个有助于增长或缩小的变异器</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">            tuple_list!(</span><br><span class="line">                AlphaByteSwapMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesDeleteMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                BytesInsertMutator::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            ),</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>然后在我们的变异器中，我们使用状态的随机源来选择位置，并从一组有效字符中选择一个新的字节。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">mutate</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">            state: &amp;<span class="keyword">mut</span> S,</span><br><span class="line">            input: &amp;<span class="keyword">mut</span> I,</span><br><span class="line">            _stage_idx: <span class="type">i32</span>,</span><br><span class="line">        ) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;MutationResult, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里我们应用我们的随机变异</span></span><br><span class="line">            <span class="comment">// 对于我们的目标，简单地交换一个字节应该是有效的</span></span><br><span class="line">            <span class="comment">// 只要我们的新字节是 0-9A-Za-z 或 &#x27;-&#x27; 或 &#x27;_&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空输入</span></span><br><span class="line">            <span class="keyword">if</span> input.<span class="title function_ invoke__">bytes</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择一个随机字节</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">byte</span>: &amp;<span class="keyword">mut</span> <span class="type">u8</span> = state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(input.<span class="title function_ invoke__">bytes_mut</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不要替换标签字符 &#x27;&#123;&#123;&#125;&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> *byte == <span class="string">b&#x27;&#123;&#x27;</span> || *byte == <span class="string">b&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(MutationResult::Skipped)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在我们可以将该字节替换为一个已知好的字节</span></span><br><span class="line">            *byte = *state.<span class="title function_ invoke__">rand_mut</span>().<span class="title function_ invoke__">choose</span>(&amp;<span class="keyword">self</span>.good_bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 技术上我们应该说“跳过”如果我们用它自己替换一个字节，但这现在没问题</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(MutationResult::Mutated)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>就是这样！自定义变异器与系统的其余部分无缝协作。能够像这样快速调整模糊测试器是适应目标的好方法。结合性能测量，这样的实验可以帮助我们快速迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 76, objectives: 1, executions: 2339, exec/sec: 1.895k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.933k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 77, objectives: 1, executions: 2386, exec/sec: 1.928k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 78, objectives: 1, executions: 2392, exec/sec: 1.933k</span><br></pre></td></tr></table></figure>

<h2 id="示例问题"><a href="#示例问题" class="headerlink" title="示例问题"></a>示例问题</h2><p>到这一点，我们有一个单独的目标，你可能想要尝试！它是一个包含一个小迷宫的程序，并给你一个机会创建一个模糊测试器，使用一些自定义反馈或变异来更好地遍历迷宫并发现崩溃。尝试我们在这里介绍的一些概念，并看看你的模糊测试器有多快可以解决迷宫。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/maze_target/">.&#x2F;maze_target&#x2F;</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[jordan maze_target]$ ./maze -p</span><br><span class="line"></span><br><span class="line">██████████████</span><br><span class="line">█.██......█ ██</span><br><span class="line">█....██ █.☺  █</span><br><span class="line">██████  █ ██ █</span><br><span class="line">██   ██████  █</span><br><span class="line">█  █  █     ██</span><br><span class="line">█ ███   ██████</span><br><span class="line">█  ███ ██   ██</span><br><span class="line">██   ███  █  █</span><br><span class="line">████ ██  ███ █</span><br><span class="line">█    █  ██ █ █</span><br><span class="line">█ ████ ███ █ █</span><br><span class="line">█          █  </span><br><span class="line">████████████</span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### #### #</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #...@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-2s, clients: 1, corpus: 49, objectives: 0, executions: 5745, exec/sec: 2.585k</span><br><span class="line">Found:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">###########</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">         <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ### ####@#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment"># ##  #....#</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">###  ##.####</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment">#  ###...##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#   ## ###..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####...###.#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#.....#..#..#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">..######...##</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.##.#  <span class="comment">######</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....# <span class="comment">##....#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># #......##.#</span></span></span><br><span class="line">[Testcase #0] run time: 0h-0m-3s, clients: 1, corpus: 50, objectives: 0, executions: 8892, exec/sec: 2.587k</span><br></pre></td></tr></table></figure>

<h2 id="更快地进行模糊测试"><a href="#更快地进行模糊测试" class="headerlink" title="更快地进行模糊测试"></a>更快地进行模糊测试</h2><h2 id="持久模糊测试器"><a href="#持久模糊测试器" class="headerlink" title="持久模糊测试器"></a>持久模糊测试器</h2><p>在前面的示例中，我们使用了 <code>ForkserverExecutor</code>，它与 <code>afl-clang-fast</code> 插入到我们目标中的 fork 服务器一起工作。虽然 fork 服务器通过减少每个目标进程的启动时间给了我们很大的速度提升，但我们仍然需要为每个测试用例创建一个新进程。如果我们可以在一个进程中运行多个测试用例，我们可以大大加快我们的模糊测试。在一个目标进程中运行多个测试用例通常被称为“持久模式”模糊测试。</p>
<p>正如 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/61e27c6b54f7641a168b6acc6ecffb1754c10918/docs/fuzzing_in_depth.md?plain=1#L371">AFL++ 文档</a>中所说：</p>
<blockquote>
<p>基本上，如果你不以持久模式对目标进行模糊测试，那么你就是在业余地进行模糊测试，而不是专业地进行模糊测试。</p>
</blockquote>
<p>一些目标与持久模式不兼容。每次运行都会改变大量全局状态的任何内容都可能遇到麻烦，因为我们希望每个测试用例尽可能独立运行。即使对于适合持久模式的目标，我们通常也需要为目标代码创建一个框架。这个框架只是我们编写的一些代码，用于调用目标进行模糊测试。<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md">AFL++ 文档中关于 LLVM 的持久模式</a>是编写这些类型框架的一个很好的参考。</p>
<p>当我们创建了这样的框架时，插入的 fork 服务器将检测到持久的能力，甚至可以使用共享内存来提供测试用例。LibAFL 的 <code>ForkserverExecutor</code> 可以让我们利用这些持久框架。</p>
<p>使用持久框架的模糊测试器与我们之前的模糊测试器没有太大变化。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/persistent_fuzzer/src/main.rs">.&#x2F;persistent_fuzzer&#x2F;src&#x2F;main.rs</a></p>
<p>主要变化在于告诉我们的 <code>ForkServerExecutor</code> 它 <code>is_persistent(true)</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = ForkserverExecutor::<span class="title function_ invoke__">builder</span>()</span><br><span class="line">            .<span class="title function_ invoke__">program</span>(<span class="string">&quot;../fuzz_target/target_persistent&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">is_persistent</span>(<span class="literal">true</span>)</span><br><span class="line">            .<span class="title function_ invoke__">shmem_provider</span>(&amp;<span class="keyword">mut</span> shmem_provider)</span><br><span class="line">            .<span class="title function_ invoke__">coverage_map_size</span>(MAP_SIZE)</span><br><span class="line">            .<span class="title function_ invoke__">build</span>(tuple_list!(edges_observer))</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><code>ForkserverExecutor</code> 负责使这一切发生。我们的大部分工作都投入到实际创建一个有效的框架中！如果你想尝试自己制作，我们已经为你准备了一些模板，让你开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent_template.c">.&#x2F;fuzz_target&#x2F;target_persistent_template.c</a></p>
<p>在我们的框架中，我们要注意每次运行后重置状态，以便我们尽可能接近原始状态。任何修改的全局变量、堆分配或运行的副作用，可能会改变未来运行的行为，需要被撤销。未能清除程序状态可能导致误报或不稳定。如果我们希望这个模糊测试器的成功测试用例也能使原始目标崩溃，那么我们需要尽可能地模拟原始目标的行为。</p>
<p>有时，模拟原始目标并不值得，而是使用我们的框架来针对更深层次的表面。例如，在我们的目标中，我们可以直接针对 <code>uid_to_name</code> 函数，然后在以后将解决方案转换为原始目标的解决方案。我们还会希望在我们的框架中调用 <code>valid_uid</code>，以确保我们不会报告永远不会对我们的原始目标起作用的误报。</p>
<p>你可以在这里检查我们的持久框架；我们选择为每行反复调用 <code>process_line</code> 并注意清理我们自己。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_persistent.c">.&#x2F;fuzz_target&#x2F;target_persistent.c</a></p>
<p>在那里之前，我们看到了大约每秒 2k 次执行的模糊测试器，使用代码覆盖率反馈，现在我们看到大约每秒 5k 或 6k，仍然只有一个客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 171, objectives: 4, executions: 95677, exec/sec: 5.826k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.860k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 172, objectives: 4, executions: 96236, exec/sec: 5.821k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.863k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 173, objectives: 4, executions: 96933, exec/sec: 5.798k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.866k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 174, objectives: 4, executions: 98077, exec/sec: 5.855k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.867k</span><br><span class="line">[Stats #0] run time: 0h-0m-16s, clients: 1, corpus: 175, objectives: 4, executions: 98283, exec/sec: 5.853k</span><br><span class="line">[Testcase #0] run time: 0h-0m-16s, clients: 1, corpus: 176, objectives: 4, executions: 98488, exec/sec: 5.866k</span><br></pre></td></tr></table></figure>

<h2 id="进程内模糊测试器"><a href="#进程内模糊测试器" class="headerlink" title="进程内模糊测试器"></a>进程内模糊测试器</h2><p>使用 AFL++ 的编译器和 fork 服务器并不是实现一个进程中多个测试用例的唯一方法。LibAFL 是一个极其灵活的库，支持各种场景。<code>InProcessExecutor</code> 允许我们在与我们的模糊测试逻辑相同的进程中直接运行测试用例。这意味着如果我们能以某种方式与我们的目标链接，我们就可以在同一进程中进行模糊测试。</p>
<p>LibAFL 的多功能性意味着我们可以将我们的整个模糊测试器构建为库，我们可以将其链接到我们的目标中，甚至可以动态地预加载到我们的目标中。LibAFL 甚至支持 <code>nostd</code>（不依赖于操作系统或标准库的编译），因此我们可以将我们的整个模糊测试器视为一个 blob 注入到我们目标的环境。</p>
<p>在我们的示例中，我们将我们的模糊测试器与我们的目标构建为静态库，并使用 Rust 的 FFI 直接调用 C 代码。</p>
<p>通过提供一个 <code>build.rs</code> 文件来构建我们的模糊测试器并使其与我们的目标链接，Rust 编译将使用该文件。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/inproc_fuzzer/build.rs">.&#x2F;inproc_fuzzer&#x2F;build.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_dir</span> = <span class="string">&quot;../fuzz_target&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target_lib</span> = <span class="string">&quot;target_libfuzzer&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强制我们链接文件 &#x27;libtarget_libfuzzer.a&#x27;</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-search=native=&#123;&#125;&quot;</span>, &amp;target_dir);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rustc-link-lib=static:+whole-archive=&#123;&#125;&quot;</span>, &amp;target_lib);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=build.rs&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了工具来包装 clang 编译器，如果你希望创建一个编译器，它将自动将你的模糊测试器注入到目标中。你可以在 LibAFL 示例中看到这一点。</p>
<p>我们还需要一个框架来处理这个目标，这样我们就可以将测试用例作为缓冲区传递，而不是让目标从 <code>stdin</code> 读取行。我们将使用 <code>libfuzzer</code> 使用的公共接口，这让我们创建一个名为 <code>LLVMFuzzerTestOneInput</code> 的函数。LibAFL 甚至有一些助手函数可以为我们执行 FFI 调用。</p>
<p>我们的框架可以与我们为持久模式模糊测试创建的框架非常相似。我们还要注意与持久模式模糊测试中相同的全局状态或内存泄漏，这些可能会使我们的模糊测试不稳定。同样，如果你想要自己制作框架，我们有一个模板供你参考。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/fuzz_target/target_libfuzzer_template.c">.&#x2F;fuzz_target&#x2F;target_libfuzzer_template.c</a></p>
<p>在目标中定义了 <code>LLVMFuzzerTestOneInput</code> 并制作了静态库后，我们的模糊测试器可以直接调用框架进行每个测试用例。我们定义了一个 <code>harness</code> 函数，我们的执行器将使用测试用例数据调用该函数。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架</span></span><br><span class="line">        <span class="comment">// 调用 libfuzzer 风格的框架</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="comment">// 这只是一些不错的调用 libfuzzer C 函数的调用</span></span><br><span class="line">            <span class="comment">// 但我们不需要使用 libfuzzer 框架来进行进程内模糊测试</span></span><br><span class="line">            <span class="comment">// 我们可以调用任何链接的函数，只要它是一个框架</span></span><br><span class="line">            <span class="title function_ invoke__">libfuzzer_test_one_input</span>(buf);</span><br><span class="line">            <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">executor</span> = InProcessExecutor::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> harness,</span><br><span class="line">            tuple_list!(edges_observer),</span><br><span class="line">            &amp;<span class="keyword">mut</span> fuzzer,</span><br><span class="line">            &amp;<span class="keyword">mut</span> state,</span><br><span class="line">            &amp;<span class="keyword">mut</span> restarting_mgr,</span><br><span class="line">        ).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这种与 libfuzzer 框架的轻松互操作性很好，我们再次看到比我们之前的模糊测试器有巨大的速度提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan inproc_fuzzer]$ ./target/release/inproc_fuzzer</span><br><span class="line"></span><br><span class="line">启动中</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-16s, clients: 2, corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000</span><br><span class="line">                  (CLIENT) corpus: 0, objectives: 0, executions: 0, exec/sec: 0.000, edges: 0/37494 (0%)</span><br><span class="line">...</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.79k, edges: 136/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k</span><br><span class="line">                  (CLIENT) corpus: 102, objectives: 5, executions: 106146, exec/sec: 30.75k, edges: 137/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-19s, clients: 2, corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k</span><br><span class="line">                  (CLIENT) corpus: 103, objectives: 5, executions: 106626, exec/sec: 30.88k, edges: 137/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-20s, clients: 2, corpus: 103, objectives: 6, executions: 106626, exec/sec: 28.32k</span><br></pre></td></tr></table></figure>

<p>在这个模糊测试器中，我们还在利用 LibAFL 提供的一个非常重要的工具：低级消息传递（LLMP）。这提供了多个客户端之间的快速通信，并让我们有效地将模糊测试扩展到多个核心甚至多台机器。<code>setup_restarting_mgr_std</code> 辅助函数创建了一个事件管理器，该管理器将管理客户端，并在它们遇到崩溃时重新启动它们。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">monitor</span> = MultiMonitor::<span class="title function_ invoke__">new</span>(|s| <span class="built_in">println!</span>(<span class="string">&quot; &#123;s&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;启动中&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们使用一个重新启动管理器，每次崩溃时都会重新启动</span></span><br><span class="line">        <span class="comment">// 我们的进程</span></span><br><span class="line">        <span class="comment">// 这将设置一个主机管理器，我们将不得不启动其他进程</span></span><br><span class="line">        <span class="keyword">let</span> (state, <span class="keyword">mut</span> restarting_mgr) = <span class="title function_ invoke__">setup_restarting_mgr_std</span>(monitor, <span class="number">1337</span>, EventConfig::<span class="title function_ invoke__">from_name</span>(<span class="string">&quot;default&quot;</span>))</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法设置重启器！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有客户端将从上面的调用中返回</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;我们是客户端！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种速度提升很重要，可以使你找到重要的漏洞或找不到。另外，在冬天让你的房间变暖一些感觉很好。</p>
<h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>当然，并不是所有的目标都很容易与链接或使用编译器进行工具化。在这些情况下，LibAFL 提供了一些有趣的工具，如 <code>libafl_frida</code> 或 <code>libafl_nyx</code>。在下一个示例中，我们将使用 LibAFL 的修改版 QEMU 为我们没有内置工具化的二进制文件提供代码覆盖率反馈。修改版的 QEMU 将向我们的模糊测试器公开代码覆盖率信息以进行反馈。</p>
<p>设置将类似于我们的进程内模糊测试器，但现在我们的框架将负责在目标中运行仿真器。默认情况下，仿真器状态不会为你重置，你将希望重置每次运行之间更改的任何全局状态。</p>
<p>如果你想自己尝试，请参阅<a href="https://docs.rs/libafl_qemu/0.10.1/libafl_qemu/emu/struct.Emulator.html">仿真器文档</a>，并随时从我们的模板开始。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/qemu_fuzzer_template">.&#x2F;qemu_fuzzer_template&#x2F;</a></p>
<p>在我们的解决方案中，我们首先执行一些初始化，直到一个断点，然后保存堆栈和返回地址。我们将不得不每次运行重置堆栈，并在返回地址上放置一个断点，以便我们可以在调用后停止。我们还在目标中映射一个区域，可以放置我们的输入。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(mainptr);</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pc</span>: GuestReg = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Pc).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">remove_breakpoint</span>(mainptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 ret 地址，以便我们可以使用它并停止</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">retaddr</span>: GuestAddr = emu.<span class="title function_ invoke__">read_return_address</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        emu.<span class="title function_ invoke__">set_breakpoint</span>(retaddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">savedsp</span>: GuestAddr = emu.<span class="title function_ invoke__">read_reg</span>(Regs::Sp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在让我们在目标中映射一个区域，我们将用于输入。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inputaddr</span> = emu.<span class="title function_ invoke__">map_private</span>(<span class="number">0</span>, <span class="number">0x1000</span>, MmapPerms::ReadWrite).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Input page @ &#123;inputaddr:#x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在在框架本身中，我们将输入并将其写入目标，然后开始在目标函数中执行。这次我们直接执行 <code>uid_to_name</code> 函数，并使用一个变异器，该变异器不会添加任何 <code>valid_uid</code> 会停止的无效字符。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;BytesInput| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = input.<span class="title function_ invoke__">target_bytes</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = target.<span class="title function_ invoke__">as_slice</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">len</span> = buf.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制我们的输入大小</span></span><br><span class="line">            <span class="keyword">if</span> len &gt; <span class="number">1024</span> &#123;</span><br><span class="line">                buf = &amp;buf[<span class="number">0</span>..<span class="number">1024</span>];</span><br><span class="line">                len = <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将我们的测试用例写入内存，以 null 终止</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr, buf);</span><br><span class="line">                emu.<span class="title function_ invoke__">write_mem</span>(inputaddr + (len <span class="keyword">as</span> <span class="type">u64</span>), <span class="string">b&quot;\0\0\0\0&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 根据需要重置寄存器</span></span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Pc, parseptr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Sp, savedsp).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_return_address</span>(retaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            emu.<span class="title function_ invoke__">write_reg</span>(Regs::Rdi, inputaddr).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行直到我们的返回地址断点</span></span><br><span class="line">            <span class="comment">// 或崩溃</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; emu.<span class="title function_ invoke__">run</span>() &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果我们没有崩溃，我们很好</span></span><br><span class="line">            ExitKind::<span class="literal">Ok</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这种仿真可以非常快，特别是如果我们可以在每次运行之间不必重置大量状态。通过在这里针对更深层的函数，我们可能会很快达到崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 54, objectives: 0, executions: 33349, exec/sec: 31.56k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 32.85k</span><br><span class="line">[Stats #0] run time: 0h-0m-1s, clients: 1, corpus: 55, objectives: 0, executions: 34717, exec/sec: 31.59k</span><br><span class="line">[Testcase #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 0, executions: 36124, exec/sec: 32.87k</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T20:24:02Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br><span class="line">[Objective #0] run time: 0h-0m-1s, clients: 1, corpus: 56, objectives: 1, executions: 36124, exec/sec: 28.73k</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>LibAFL 还提供了一些有用的助手，如 <code>QemuAsanHelper</code> 和 <code>QemuSnapshotHelper</code>。甚至还有支持全系统仿真，而不是用户模式仿真。能够有效地使用仿真器进行模糊测试可以打开一个全新的目标世界。</p>
<h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>我们从一些初始输入开始，然后简单地变异它们的方法对于某些目标来说可能非常有效，但对于更复杂的输入则不那么有效。如果我们从一个像这样的 javascript 输入开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现有的变异可能会产生以下结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>\<span class="title function_">x00</span> (a &lt;\u003c b) &#123;</span><br><span class="line">    <span class="title function_">somefu</span>(a;;;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这可能会在解析器中发现一些漏洞，但不太可能在任何 javascript 引擎中发现更深层次的漏洞。如果我们想要锻炼引擎本身，我们将希望主要产生有效的 javascript。这是生成的一个很好的用例！通过定义一个语法，描述有效的 javascript 看起来像什么，我们可以生成大量的测试用例来对抗引擎。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"></p>
<p>正如你在上面的图表中看到的，仅靠生成我们就不再使用变异+反馈循环。有许多成功的模糊测试器仅靠生成就获得了胜利（<a href="https://github.com/googleprojectzero/domato">domato</a>、<a href="https://boofuzz.readthedocs.io/en/stable/">boofuzz</a>、<a href="https://www.atredis.com/blog/2022/03/29/veni-midi-vici-conquering-cve-2022-22657-and-cve-2022-22664">一堆奇怪的 midi 文件</a>），但我们希望在我们的模糊测试中有一些形式的反馈和进展。</p>
<p>为了在我们的生成中利用反馈，我们可以创建一个生成数据的中间表示（IR）。然后我们可以将有趣的案例反馈到我们的输入中，以便进一步变异。</p>
<p>所以我们之前的 javascript 可以像这样表达为令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (var a), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func,</span><br><span class="line">            (arg_list (var a))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们对这种标记版本的变异可以做的事情包括用其他有效的令牌替换令牌或向树添加更多节点，创建一个稍微不同的输入。然后我们可以像以前一样使用这些 IR 输入和变异，结合代码覆盖率反馈。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
<p>现在对 IR 的变异可能会产生像这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(if</span><br><span class="line">    (cond_lt (const 0), (var b)),</span><br><span class="line">    (code_block</span><br><span class="line">        (func_call some_func</span><br><span class="line">            (arg_list</span><br><span class="line">                (func_call some_func,</span><br><span class="line">                    (arg_list ((var a), (var a)))</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这将呈现为有效的 javascript，并且如果它产生有趣的反馈，可以进一步变异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt; b) &#123;</span><br><span class="line">    <span class="title function_">somefunc</span>(<span class="title function_">somefunc</span>(a,a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LibAFL 提供了一些很棒的工具，帮助你拥有一个带有反馈的生成模糊测试器。LibAFL 中包含了一个 <a href="https://github.com/nautilus-fuzz/nautilus">Nautilus 模糊测试器</a>的版本。为了使用它与我们的例子，我们首先定义一个语法，描述我们目标的有效输入是什么样的。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/grammar.json">.&#x2F;aflcc_custom_gen&#x2F;grammar.json</a></p>
<p>有了 LibAFL，我们可以将这个语法加载到一个 <code>NautilusContext</code> 中，我们可以使用它进行生成。我们使用 <code>InProcessExecutor</code>，在我们的框架中，我们接受一个 <code>NautilusInput</code>，我们将其呈现为字节并传递给我们的 <code>LLVMFuzzerTestOneInput</code>。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/aflcc_custom_gen/src/main.rs">.&#x2F;aflcc_custom_gen&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不能使用普通的字节变异，所以我们使用在我们生成器树上工作的变异</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mutator</span> = StdScheduledMutator::<span class="title function_ invoke__">with_max_stack_pow</span>(</span><br><span class="line">        tuple_list!(</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRandomMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusRecursionMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">            NautilusSpliceMutator::<span class="title function_ invoke__">new</span>(&amp;genctx),</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>我们还需要生成一些初始 IR 输入并指定要使用的变异。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">must_load_initial_inputs</span>() &#123;</span><br><span class="line">        <span class="comment">// 与从初始语料库加载不同，我们将生成 9 个 NautilusInputs 的初始语料库</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">generator</span> = NautilusGenerator::<span class="title function_ invoke__">new</span>(&amp;genctx);</span><br><span class="line">        state.<span class="title function_ invoke__">generate_initial_inputs_forced</span>(&amp;<span class="keyword">mut</span> fuzzer, &amp;<span class="keyword">mut</span> executor, &amp;<span class="keyword">mut</span> generator, &amp;<span class="keyword">mut</span> restarting_mgr, <span class="number">9</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Created initial inputs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的执行器将只是一个包装器，围绕一个框架闭包</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">harness</span> = |input: &amp;NautilusInput| &#123;</span><br><span class="line">        <span class="comment">// 我们需要将我们的输入从 nautilus 树</span></span><br><span class="line">        <span class="comment">// 转换为实际的字节</span></span><br><span class="line">        input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;bytes).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Trying:\n&#123;:?&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">buf</span> = bytes.<span class="title function_ invoke__">as_mut_slice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">libfuzzer_test_one_input</span>(&amp;buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ExitKind::<span class="literal">Ok</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>有了这一切，我们可以运行并获得生成、代码覆盖率和进程内执行的结合优势。为了进一步改进这一点，我们可以随着对我们目标的更好理解而改进我们的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">                  (CLIENT) corpus: 145, objectives: 2, executions: 40968, exec/sec: 1.800k, edges: 167/37494 (0%)</span><br><span class="line">[Testcase    #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 2, executions: 41229, exec/sec: 1.811k, edges: 167/37494 (0%)</span><br><span class="line">[Objective   #1]  (GLOBAL) run time: 0h-0m-26s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k</span><br><span class="line">                  (CLIENT) corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.780k, edges: 167/37494 (0%)</span><br><span class="line">[Stats       #1]  (GLOBAL) run time: 0h-0m-27s, clients: 2, corpus: 146, objectives: 3, executions: 41229, exec/sec: 1.755k</span><br></pre></td></tr></table></figure>

<p>注意，我们保存的解决方案只是序列化的 <code>NautilusInputs</code>，并且在原始目标上使用时将不起作用。我们创建了一个单独的项目，将这些解决方案呈现为字节。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/gen_solution_render/src/main.rs">.&#x2F;gen_solution_render&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: NautilusInput = NautilusInput::<span class="title function_ invoke__">from_file</span>(path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tree_depth</span> = <span class="number">0x45</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">genctx</span> = NautilusContext::<span class="title function_ invoke__">from_file</span>(tree_depth, grammarpath);</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">unparse</span>(&amp;genctx, &amp;<span class="keyword">mut</span> b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = std::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;PLvkLizOcGccywcS&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">&#123;&#123;EGgkWs-PxeqpwBZK&#125;&#125;foo</span><br><span class="line"></span><br><span class="line">bar&#123;&#123;hlNeoKiwMTNfqO_h&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[jordan gen_solution_render]$ ./target/release/gen_solution_render ../aflcc_custom_gen/solutions/id:0 | ../fuzz_target/target</span><br><span class="line"></span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="示例问题-2"><a href="#示例问题-2" class="headerlink" title="示例问题 2"></a>示例问题 2</h2><p>这给我们带来了第二个带回家的问题！我们有一个聊天客户端，它容易受到许多问题的影响。通过好好利用生成和&#x2F;或仿真，可以使对二进制文件的模糊测试变得更容易。在你发现一些嘈杂的漏洞时，你可能希望在你的模糊测试器中避免这些路径，或者在你的目标中修补这些漏洞。漏洞经常会掩盖其他漏洞。你可以在这里找到目标。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/tree/main/chat_target">.&#x2F;chat_target&#x2F;</a></p>
<p>以及一个可以模糊测试聊天客户端的示例解决方案。</p>
<p><a href="https://github.com/atredis-jordan/libafl-workshop-blog/blob/main/chat_solution/src/main.rs">.&#x2F;chat_solution&#x2F;src&#x2F;main.rs</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Ping from    16937944: DDAAAATt&#x27;AAAAPt&#x27;%222%%%%%%%9999&#x27;pRR9&amp;&amp;%%%%%%2Tt&#123;&#x27;&#x27;pRt&#x27;%99999999&#x27;pRR9&amp;&amp;&amp;%%%%%%999AATt&#x27;%&amp;&#x27;pRt&#x27;%TTTTTTTTTTTTTT9999999&#x27;a%&#x27;AAATTt&#x27;% --</span><br><span class="line">-- Error sending message: Bad file descriptor --</span><br><span class="line">[Stats #0] run time: 0h-0m-5s, clients: 1, corpus: 531, objectives: 13, executions: 26752, exec/sec: 0.000</span><br><span class="line">[Testcase #0] run time: 0h-0m-5s, clients: 1, corpus: 532, objectives: 13, executions: 26760, exec/sec: 0.000</span><br><span class="line">-- Ping from    16937944: DDAAAATT&#x27;%&#x27;aRt&#x27;%9999&#x27;pRRT&#x27;%&#x27;LLLLLLLLLLLa%&#x27;nnnnnmnnnT&#x27;AA&#x27;&#x27;&#x27;</span><br><span class="line">A&#x27;&#x27;p%&#x27;&#x27;A9999&#x27;pRRT&#x27;pRR -- </span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Crashed with SIGSEGV</span><br><span class="line">[2023-11-25T21:29:19Z ERROR libafl::executors::inprocess::unix_signal_handler] Child crashed!</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个研讨会的目标是展示 LibAFL 的多功能性，并鼓励它的使用。希望这些示例能激发你一些关于如何将自定义模糊测试器整合到你的一些目标中的想法。如果你有任何问题或发现我们示例中的任何问题，请让我们知道。或者，如果你有一个有趣的目标，并希望我们为你找到漏洞，请与我们联系。</p>
<h2 id="课程推广"><a href="#课程推广" class="headerlink" title="课程推广"></a>课程推广</h2><p>再次感谢你的阅读！如果你喜欢这类内容，你可能会对我们的课程“Practical Symbolic Execution for VR and RE”感兴趣，你将学习如何为以下内容创建你自己的符号执行框架：逆向工程、去混淆、漏洞检测、漏洞开发等。下一次公开课程将在 2024 年 2 月作为 ringzer0 的 BOOTSTRAP24 的一部分。我们也可以根据要求提供私人课程。</p>
<p>更多信息在这里。<br><a href="https://ringzer0.training/trainings/practical-symbolic-execution.html">https://ringzer0.training/trainings/practical-symbolic-execution.html</a></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1566943528908-J56DPCZRQ9SVG4TFPP27/WhiskeyBirdTextOverlayWhite.png?format=1500w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1701794251926-ZA8KEPB15YFCJ0QRW122/johannes-weber-wcspluM_Iqw-unsplash.jpg?format=1000w" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/10dad911-d653-4a70-90ec-89539b44eb71/Basic+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/d5fddf24-77fd-44c6-b697-ad5eb48b2d5c/Feedback+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1fcdad34-fd8e-4752-a0ed-8b4843f2237c/Gen+Fuzzer.png" alt="img"><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/4ac10c4e-35bf-497d-bf6e-b7ea747ca6f6/GenMut+Fuzzer.png" alt="img"></p>
]]></content>
      <categories>
        <category>模糊测试</category>
        <category>漏洞挖掘</category>
        <category>翻译文章</category>
      </categories>
      <tags>
        <tag>LibAFL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/XP%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%81%9A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>一个安全网课网站：<a href="http://www.securitytube.net/groups?operation=view&groupId=5">SecurityTube</a>，年久失修，唯一价值可能是参照上面找资源</p>
<p>比如上面的一个在 XP SP3 平台漏洞利用的课在油管上的地址：<a href="https://www.youtube.com/watch?v=f-1zIFb-zpw&list=PL6qa4C74KbMBo0BMM9ZdcFlDLkArwA3SF">Exploit Research Megaprimer</a></p>
<p>比如一个讲linux 汇编的课：<a href="https://www.youtube.com/watch?v=K0g-twyhmQ4&list=PLyqno_bgl3e-zLBZGdi_zsPQYPQUlZYe4">Assembly Primer For Hackers </a></p>
<p>但是这样的课或许不一定非要在这里学</p>
]]></content>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2024/09/01/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>acwing 贪心算法</p>
<span id="more"></span>

<ul>
<li><p>区间问题基础语法问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何存储区间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;<span class="type">int</span> l,r; <span class="type">bool</span> <span class="keyword">operator</span>&lt;()&#123;&#125;&#125;range[N]	<span class="comment">// 结构体数组</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;   vector&lt;PII&gt; <span class="comment">// vector 存 PII</span></span><br><span class="line"><span class="comment">// 如何排序</span></span><br><span class="line"><span class="keyword">operator</span>&lt;	<span class="comment">// 操作符重载</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">()</span>	<span class="comment">// 定义比较器</span></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(a.begin(), a.begin() + n, [](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;)</span></span>; <span class="comment">// lambda 函数</span></span><br><span class="line"><span class="comment">// 如何输入一个区间</span></span><br><span class="line">range[i] = &#123;l,r&#125;; </span><br><span class="line">cin &gt;&gt; range[i].l &gt;&gt; range[i].r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">vc.<span class="built_in">push_back</span>(&#123;l,r&#125;);	<span class="comment">// pair 也算聚合体 可以用花括号作临时 pair 对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort 函数默认对 vector<PII> 进行双关键字排序</p>
</blockquote>
</li>
<li><p>区间选点: 选择尽量少的点，使得每个区间内至少包含一个选出的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> r &lt; W.r; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; range[i].l)</span><br><span class="line">        &#123; res ++ ;ed = range[i].r; &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按右端点排序</li>
<li>依次遍历区间，<ol>
<li>和当前 end 有交集，则跳过</li>
<li>无交集，更新 end</li>
</ol>
</li>
</ol>
<p>为什么按右端点排序？</p>
<p>因为要尽可能少的点，点从左往右选，希望步子尽可能大，但是前提是点穿过所有区间，所以步子限制在无交集区间中最靠左的右端点</p>
<p>为何和最大无交集区间数是一个问题？</p>
<p>最大不相交区间和最多会议安排，都是找尽早结束时间点的区间纳入选择集中，这和区间选点策略是一样的。</p>
</blockquote>
</li>
<li><p>区间分组: 将区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span> &#123; <span class="keyword">return</span> l &lt; W.l; &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= range[i].l)</span><br><span class="line">            heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">        <span class="keyword">else</span> &#123; heap.<span class="built_in">pop</span>(); heap.<span class="built_in">push</span>(range[i].r); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>按左端点排序</li>
<li>遍历区间<ol>
<li>当前区间可以放在某组，放入并更新结束时间</li>
<li>无法放入，开新组</li>
</ol>
</li>
</ol>
<p>为什么这里又变成了左端点排序？</p>
<ol>
<li>其实是按开始时间依次放入，倘若变成按结束时间依次放入</li>
</ol>
<p>另一种新奇的思路：<a href="https://www.acwing.com/solution/content/8902/">https://www.acwing.com/solution/content/8902/</a></p>
</blockquote>
</li>
<li><p>区间覆盖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l&lt;W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st,ed;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i]=&#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range,range+n);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123; r = <span class="built_in">max</span>(r, range[j].r); j ++; &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; st)&#123; cout &lt;&lt; <span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)&#123; cout &lt;&lt; res; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        st = r; i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路总结：</p>
<ol>
<li>区间按左端点排序</li>
<li>遍历区间<ol>
<li>从可以覆盖 st 的区间中找一个右端点最靠右的，最大化覆盖 st ed 区间</li>
<li>更新 st 为这个区间最靠右的值。回到 2-1 循环</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>区间问题总结：</p>
<ul>
<li><p>区间尽管可以将其看做元素，根据需要按左端点或右端点进行排序</p>
</li>
<li><p>哈夫曼树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n ==  <span class="number">1</span>) &#123;cout &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123; <span class="type">int</span> t; cin &gt;&gt; t; q.<span class="built_in">push</span>(t); &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s1 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> s2 = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        res += s1 + s2;</span><br><span class="line">        q.<span class="built_in">push</span>(s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排队打水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="built_in">sort</span>(m,m + n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> wait = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123; res += wait; wait += m[i]; &#125;</span><br><span class="line"><span class="comment">// 方法2 太优美了！</span></span><br><span class="line"><span class="built_in">sort</span>(t, t + n);</span><br><span class="line"><span class="built_in">reverse</span>(t, t + n);</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += t[i] * i;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/libfuzz%E6%8B%93%E8%8D%92/</url>
    <content><![CDATA[<p>libfuzz：</p>
<p>LibAFL github 仓库：<a href="https://github.com/AFLplusplus/LibAFL">https://github.com/AFLplusplus/LibAFL</a></p>
<p><a href="https://www.youtube.com/watch?v=3RWkT1Q5IV0">Fuzzers Like Lego @rC3 - YouTube</a>中讲到：没有最好的 fuzzer,只有针对使用常见特异性改造的 fuzzer 才是好 fuzzer, AFL 作为奠基石，但是在各个环节都是由改进空间的。</p>
<p>另一个pre:<a href="https://www.youtube.com/watch?v=PWB8GIhFAaI">LibAFL: The Advanced Fuzzing Library - Andrea Fioraldi &amp; Dominik Maier @FuzzCon Europe 2021</a></p>
<p>libfuzz 文档介绍：<a href="https://aflplus.plus/libafl-book/getting_started/crates.html">Crates - The LibAFL Fuzzing Library (aflplus.plus)</a></p>
<p>fuzz101实验：<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">fuzz101</a></p>
<ul>
<li>“LibAFL 书籍”是由一些 LibAFL 维护者创建的，是一个很好的资源。<a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a></li>
<li>epi 有一系列很棒的文章，深入探讨了使用 LibAFL 创建一些示例模糊测试器的过程。<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/</a></li>
<li>LibAFL 仓库本身包含许多有用的示例，可以作为你自己模糊测试器的参考。<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers">https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers</a></li>
</ul>
<p>NYX官网：<a href="https://nyx-fuzz.com/">Nyx (nyx-fuzz.com)</a></p>
<p>NYX一个 pre:<a href="https://www.youtube.com/watch?v=f5uhWesvjZ8">Thorsten Holz - Fuzz Testing and Beyond (youtube.com)</a></p>
<p>欠缺的知识图谱：</p>
<p>符号执行</p>
<p>污点分析</p>
<p>qemu模式</p>
<p>asan</p>
<p>frada</p>
<p>实操：</p>
<p>漏洞复现</p>
<p>gdb调试</p>
<p>ida使用</p>
<p>逆向能力</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>来自 dblp 搜索结果，<a href="https://dblp.org/search?q=fuzz%20smart%20contract">https://dblp.org/search?q=fuzz%20smart%20contract</a></p>
<ol>
<li>ContractFuzz<strong>er:</strong> Fuzz<strong>ing</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>Fuse: An Architecture for</strong> Smart Contract Fuzz <strong>Testing Service</strong></li>
<li><strong>Harvey: A Greybox</strong> Fuzz<strong>er for</strong> Smart Contract<strong>s</strong></li>
<li><strong>A</strong> Fuzz <strong>Testing Service for Assuring</strong> Smart Contract<strong>s</strong></li>
<li><strong>SoliAudit:</strong> Smart Contract <strong>Vulnerability Assessment Based on Machine Learning and</strong> Fuzz <strong>Testing</strong></li>
<li><strong>Robot Coalition Formation Based on</strong> Fuzz<strong>y Cooperative Games over Blockchain-Based</strong> Smart Contract<strong>s</strong></li>
<li>Fuzz<strong>y Cooperative Games Usage in</strong> Smart Contract<strong>s for Dynamic Robot Coalition Formation: Approach and Use Case Description</strong></li>
<li><strong>Efficient Funds Allocation System Based on</strong> Fuzz<strong>y Logic and</strong> Smart Contract<strong>s.</strong></li>
<li><strong>Learning to</strong> Fuzz <strong>from Symbolic Execution with Application to</strong> Smart Contract<strong>s.</strong></li>
<li><strong>EOSFuzzer:</strong> Fuzz<strong>ing EOSIO</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>Towards</strong> Smart <strong>Hybrid</strong> Fuzz<strong>ing for</strong> Smart Contract<strong>s</strong></li>
<li><strong>sFuzz: An Efficient Adaptive</strong> Fuzz<strong>er for Solidity</strong> Smart Contract<strong>s</strong></li>
<li><strong>EthPloit: From</strong> Fuzz<strong>ing to Efficient Exploit Generation against</strong> Smart Contract<strong>s.</strong></li>
<li><strong>Testing Ethereum</strong> Smart Contract<strong>s: A Comparison of Symbolic Analysis and</strong> Fuzz <strong>Testing Tools</strong></li>
<li><strong>Echidna: effective, usable, and fast</strong> fuzz<strong>ing for</strong> smart contract<strong>s.</strong></li>
<li><strong>EOSFuzzer:</strong> Fuzz<strong>ing EOSIO</strong> Smart Contract<strong>s for Vulnerability Detection</strong></li>
<li><strong>sFuzz: an efficient adaptive</strong> fuzz<strong>er for solidity</strong> smart contract<strong>s</strong></li>
<li><strong>I Can Get Some Satisfaction:</strong> Fuzz<strong>y Ontologies for Partial Agreements in Blockchain</strong> Smart Contract<strong>s</strong></li>
<li><strong>GasFuzzer:</strong> Fuzz<strong>ing Ethereum</strong> Smart Contract <strong>Binaries to Expose Gas-Oriented Exception Security Vulnerabilities</strong></li>
<li>HFContractFuzzer: Fuzzing Hyperledger Fabric Smart Contracts for Vulnerability Detection. <a href="https://dblp.org/db/conf/ease/ease2021.html#DingLLZ21">EASE 2021</a>: 321-328</li>
<li>ConFuzzius: A Data Dependency-Aware Hybrid Fuzzer for Smart Contracts. <a href="https://dblp.org/db/conf/eurosp/eurosp2021.html#TorresIGS21">EuroS&amp;P 2021</a>: 103-119</li>
<li>echidna-parade: a tool for diverse multicore smart contract fuzzing.<a href="https://dblp.org/db/conf/issta/issta2021.html#GroceG21">ISSTA 2021</a>: 658-661</li>
<li>SMARTIAN: Enhancing Smart Contract Fuzzing with Static and Dynamic Data-Flow Analyses.<a href="https://dblp.org/db/conf/kbse/ase2021.html#0001K0GGC21">ASE 2021</a>: 227-239</li>
<li>Increasing Fuzz Testing Coverage for Smart Contracts with Dynamic Taint Analysis.<a href="https://dblp.org/db/conf/qrs/qrs2021.html#JiDQGWW21">QRS 2021</a>: 243-247</li>
<li>Ambulance Vehicle Routing under Pandemic with Fuzzy Cooperative Game via Smart Contracts. <a href="https://dblp.org/db/conf/vehits/vehits2021.html#SmirnovT21">VEHITS 2021</a>: 538-545</li>
<li><strong>AntFuzzer: A Grey-Box</strong> Fuzz<strong>ing Framework for EOSIO</strong> Smart Contract<strong>s</strong></li>
<li><strong>TokenAuditor: Detecting Manipulation Risk in Token Smart Contract by Fuzzing.</strong> <a href="https://dblp.org/db/conf/qrs/qrs2022.html#CaoZFHZ22">QRS 2022</a>: 651-662</li>
<li><strong>Effectively Generating Vulnerable Transaction Sequences in Smart Contracts with Reinforcement Learning-guided Fuzzing.</strong> <a href="https://dblp.org/db/conf/kbse/ase2022.html#SuDZZL22">ASE 2022</a>: 36:1-36:12</li>
<li><strong>SynTest-Solidity: Automated Test Case Generation and Fuzzing for Smart Contracts.</strong> <a href="https://dblp.org/db/conf/icse/icse2022c.html#OlsthoornSDP22">ICSE-Companion 2022</a>: 202-206</li>
<li><strong>Smart Contract Fuzzing for Enterprises: The Language Agnostic Way.</strong> <a href="https://dblp.org/db/conf/comsnets/comsnets2022.html#PaniNPVMR22">COMSNETS 2022</a>: 1-6</li>
<li><strong>An Empirical Study on the Effects of Entry Function Pairs in Fuzzing Smart Contracts.</strong> <a href="https://dblp.org/db/conf/compsac/compsac2022.html#AshrafC22">COMPSAC 2022</a>: 1716-1721</li>
<li><strong>Grey-box Fuzzing Based on Execution Feedback for EOSIO Smart Contracts.</strong> <a href="https://dblp.org/db/conf/apsec/apsec2022.html#LiWYSFS22">APSEC 2022</a>: 1-10</li>
<li><strong>Privacy-preserving smart contracts for fuzzy WordNet-based document representation and clustering using regularised K-means method.</strong> <a href="https://dblp.org/db/journals/ijahuc/ijahuc40.html#ThathaBH22">Int. J. Ad Hoc Ubiquitous Comput. 40(1&#x2F;2&#x2F;3)</a>: 2-9 (2022)</li>
<li><strong>Are We There Yet? Unraveling the State-of-the-Art Smart Contract Fuzzers.</strong> <a href="https://dblp.org/db/conf/icse/icse2024.html#Wu0YCJWLZ24">ICSE 2024</a>: 127:1-127:13</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p><strong>符号执行：在好情况下做到最好 — Atredis Partners</strong></p>
<p>符号执行有时会被误解。通用的符号执行工具在面对足够复杂的目标时，很难证明其价值。然而，我发现在某些特定的情况下，符号执行可以非常有帮助。其中一种情况是在处理来自模糊测试器的大量崩溃时，尤其是在处理复杂或不透明的目标时。这就是我之前遇到的“好情况”，我的模糊测试器给了我大量的崩溃，这些崩溃抵抗了常规的最小化和去重。通过构建一个小型的符号调试器，我管理了一个从模糊测试案例到完全理解的更快的响应时间。</p>
<p>在这篇文章中，我想分享我为崩溃分类编写符号执行工具的过程，并尝试突出我使用的一些技巧，使工具更有效和灵活。这里的例子都使用了伟大的<a href="https://triton-library.github.io/">Triton</a>库来进行我们的象征执行和求解。所有示例的代码都托管在：<a href="https://github.com/atredis-jordan/SymbolicTriagePost">github.com&#x2F;atredis-jordan&#x2F;SymbolicTriagePost</a></p>
<blockquote>
<p>（顺便说一下，我们有一个课程！）你是否在你的工作流程中进行逆向工程和符号执行，或者想要这样做？</p>
<p>你是否正在使用模糊测试，但希望找到更多机会来改进它，并发现更深入、更有趣的漏洞？</p>
<p>你能否在网络空间与控制台牛仔一起混？</p>
<p>我们开发了一个为期4天的课程，名为“实用符号执行用于VR和RE”，专为这些目标量身定制。它既有趣又实用，有很多演示和实验室，让你练习以创造性的方式应用这些概念。如果你对此感兴趣，可以在本文底部找到更多信息。希望在那里见到你！</p>
</blockquote>
<p>我们将使用_Procmon64.exe_中的一堆崩溃作为我们的示例。Procmon解析PML（进程监视器日志）文件非常容易出错，我们可以在短时间内从模糊测试会话中快速获得大量崩溃。它是一个大型的不透明二进制文件，崩溃具有一些非确定性，因此有用的工具将帮助我们加快逆向工程的努力。请注意，我们并没有尝试在Procmon中找到漏洞；因此，尽管我们将在这里讨论的这些漏洞对攻击者来说似乎并不特别有用，但我也不会在不久的将来打开任何不受信任的PML文件。</p>
<p>我通过制作一些非常小的PML文件并将Jackalope对准目标，收集了一堆崩溃。几个小时后，我们有大约200个奇怪的崩溃可以玩。许多崩溃是不稳定的，偶尔才会重现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">..\\Jackalope\\Release\\fuzzer.exe -iterations_per_round 30 -minimize_samples false -crash_retry 0 -nthreads 32 -in - -resume -out .\\out -t 5000 -file_extension PML -instrument_module procmon64.exe -- procmon64.exe /OpenLog @@ /Quiet /Runtime 1 /NoFilter /NoConnect</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Jackalope对Procmon的PML解析器进行模糊测试</p>
</blockquote>
<h2 id="一个简单的调试器"><a href="#一个简单的调试器" class="headerlink" title="一个简单的调试器"></a>一个简单的调试器</h2><p>在所有这些符号执行的炒作中，我们的第一步是不要使用符号执行！知道何时转向符号执行，何时仅使用仿真或调试器是一个好技能。在这种情况下，我们将编写一个非常简单的调试器，使用Windows调试API。这个调试器可以用来重新运行我们的崩溃输入，找出它们的稳定性，看看它们是否都发生在主线程中，收集堆栈跟踪等。</p>
<p>此外，拥有一个程序化调试器在我们开始符号执行时将非常有用。我们将在稍后讨论这个问题，首先让我们的调试器启动。</p>
<blockquote>
<p>快速旁注。我这里所有的代码示例都是用Python编写的，因为我喜欢在调试器中能够进入IPython。我在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/win_types.py">win_types.py</a>文件中定义了一堆ctypes结构。我建议有一些程序化的方式来生成你需要的类型。可以查看<a href="https://github.com/horsicq/PDBRipper">PDBRipper</a>或<a href="https://github.com/microsoft/microsoft-pdb/blob/master/cvdump/cvdump.exe">cvdump</a>作为一个好的开始。</p>
</blockquote>
<p>好的，所以我们首先想要一个调试器，可以运行进程直到它崩溃并收集异常信息。基本前提是我们开始一个被调试的进程（我们在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L77">triage.py中的_connect_debugger_函数</a>），然后等待它直到我们得到一个未处理的异常。像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handle, main_tid = connect_debugger(cmd)</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;process&quot;</span>, <span class="number">3</span>, <span class="string">f&quot;: -- &quot;</span>)</span><br><span class="line"></span><br><span class="line">event = dbg_wait(handle, <span class="literal">None</span>)</span><br><span class="line">code = event.dwDebugEventCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> code == EXIT_PROCESS_DEBUG_EVENT:</span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; Closed with no crash&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> code == EXCEPTION_DEBUG_EVENT:</span><br><span class="line">    <span class="comment"># 需要调查的异常</span></span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; crashed:&quot;</span>)</span><br><span class="line">    er = event.u.Exception.ExceptionRecord</span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">1</span>, exceptionstr(handle, er, event.dwThreadId))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    log(<span class="string">&quot;process&quot;</span>, <span class="number">1</span>, <span class="string">f&quot; hit unexpected Debug Event &quot;</span>)</span><br><span class="line"></span><br><span class="line">dbg_kill(handle)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>triage.py的handle_case的一部分，运行单个测试案例</p>
</blockquote>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/1325b83b-f8de-419b-b515-2802b291355d/crash.png" alt="img"></p>
<p><em>运行上述代码以获取崩溃的异常信息</em></p>
<p>许多崩溃不会每次都发生，因为某些非确定性。在我们的调试器中多次运行所有测试案例，我们可以构建一个最稳定的崩溃的图景，如果它们保持在主线程中，以及发生了什么类型的异常。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx008_00000xxxxxxxx5AA_1.PML -- 100% (18) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x5aa</span><br><span class="line">        EXCEPTION_STACK_BUFFER_OVERRUN(0xc0000409) @ 0x83c</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx008_00000xxxxxxxx5AA_2.PML -- 100% (34) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x5aa</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx063_00000xxxxxxxx3ED_1.PML -- 100% (34) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x520 read at 0x3ed</span><br><span class="line">...</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx3D4_00000xxxxxxxxED1_2.PML -- 52% (23) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed1</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx234_00000xxxxxxxxED4_3.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx3CA_00000xxxxxxxxED1_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed1</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx5EC_00000xxxxxxxx0A2_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx5EF_00000xxxxxxxxF27_1.PML -- 45% (22) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xecb</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxxB46_00000xxxxxxxxFF4_1.PML -- 44% (18) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xed4</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">.\\crsh\\access_violation_0000xxxxxxxxx25A_00000xxxxxxxxED4_1.PML -- 38% (21) -- main thread</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x649 read at 0xa2</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x87a read at 0xecb</span><br><span class="line">        EXCEPTION_ACCESS_VIOLATION(0xc0000005) @ 0x19d read at 0x184</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从多次运行中收集的信息</p>
</blockquote>
<blockquote>
<p>让我再快速旁注一下。Windows异常很棒，因为它们可以包含额外的信息。异常记录告诉我们访问违规是读取还是写入，以及导致故障的指针。在Linux上，这很难以编程方式获取，因为SEGFAULT只是一个SEGFAULT。在这里，我们可以使用我们的符号执行引擎仅提升出错的指令。引擎将为我们提供有关发生什么加载或存储的缺失信息，让我们区分无聊的NULL读取和令人兴奋的超出页面末尾的写入。</p>
</blockquote>
<h2 id="让我们的符号执行运行起来，以及一些技巧"><a href="#让我们的符号执行运行起来，以及一些技巧" class="headerlink" title="让我们的符号执行运行起来，以及一些技巧"></a>让我们的符号执行运行起来，以及一些技巧</h2><p>现在我们有一个使用Windows调试API（或_ptrace_或任何其他）的简单调试器。现在我们可以将我们的符号引擎混合到其中。计划是使用我们的调试器运行目标，直到我们的输入在某个地方的内存中。然后我们将输入标记为符号，并在我们的符号引擎中跟踪其余的指令。</p>
<blockquote>
<p>将输入标记为“符号”这里意味着我们正在告诉我们的引擎这些值将被跟踪为变量，而不仅仅是数字。这将让我们看到的所有表达式都是以我们的输入变量的形式，比如“rax: (add INPUT_12 0x12)”而不是只是“rax: 0x53”。一个更好的术语可能是“混合的”（具体-符号），因为我们仍然使用这些输入字节的实际值，只是在它们上面添加了符号信息。不过，我在这篇文章中还是使用了符号这个术语。</p>
</blockquote>
<p>我们的调试器会告诉我们何时到达异常。从那里我们可以在崩溃时的状态中检查我们符号输入的信息。对于访问违规，我们希望能够看到被解引用的指针是符号的“_(0xwhatever + INPUT_3c)_”或其他一些符号表达式，显示我们的输入中是什么导致了崩溃。</p>
<p>这些信息对于根本原因分析崩溃（我们将在下一节中看到一些处理这些信息的很酷的技巧）非常有用。我们收集这些符号信息，这样我们就可以利用保持我们在崩溃路径上的约束，以及我们自己的约束，并将这些发送到求解器。使用求解器，我们可以问“什么输入会使这个指针变成X？”这让我们能够快速识别一个Write-What-Where从Read8-AroundHere，或者一个Write-That-ThereGiveOrTake100。我们可以在跟踪的任何点中断我们的象征性调试器，并使用求解器来回答我们的问题。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/41d0f85f-c26e-4c2e-9ae9-ba6e318403c6/check_value.png" alt="img"></p>
<p><em>在断点处停止，并看到什么输入会使RBX等于0x12340000</em></p>
<p>注意：我应该指出，严格来说，使用调试器并不是必需的。我们可以只加载_procmon64.exe_及其库到我们的象征执行引擎中，然后在没有调试器的帮助下模拟指令。如果你看到<a href="https://github.com/JonathanSalwan/Triton/tree/master/src/examples">Triton存储库中的伟大示例</a>，你会注意到它们没有跟随调试器步骤。我喜欢将符号执行引擎与调试器一起使用有几个原因。我将在以下段落中突出其中一些原因。</p>
<p>主要原因可能是为了避免自己被误导。有了调试器或具体执行跟踪，我可以跟随一个我可以跟随的真实情况。没有它，当我在设置我们的执行环境时犯错误时，很容易直到后来才意识到。比如不正确地加载库、处理重定位或在Windows上设置_TEB_和_PEB_。通过使用调试器，我们可以通过从实际进程中拉取内存块来设置我们的执行环境。我们还可以按需加载内存，这样我们可以在非常大的进程上节省时间。在<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L643">我们的示例中</a>，我们使用Triton的_GET&#x2F;SET_CONCRETE_MEMORY_VALUE_回调懒加载内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tri_init</span>(<span class="params">handle, onlyonsym=<span class="literal">False</span>, memarray=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="comment"># 进行TritonContext的基本初始化</span></span><br><span class="line"></span><br><span class="line">    ctx = TritonContext(ARCH.X86_64)</span><br><span class="line">    ctx.setMode(MODE.ONLY_ON_SYMBOLIZED, onlyonsym)</span><br><span class="line">    <span class="keyword">if</span> memarray:</span><br><span class="line">        ctx.setMode(MODE.MEMORY_ARRAY, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ctx.setMode(MODE.ALIGNED_MEMORY, <span class="literal">True</span>)</span><br><span class="line">    ctx.setMode(MODE.AST_OPTIMIZATIONS, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置延迟内存加载</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmemcb</span>(<span class="params">ctx, ma</span>):</span><br><span class="line">        addr = ma.getAddress()</span><br><span class="line">        sz = ma.getSize()</span><br><span class="line">        <span class="comment"># 只会加载之前没有加载过的页面</span></span><br><span class="line">        tri_load_dbg_mem(ctx, handle, addr, sz, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setmemcb</span>(<span class="params">ctx, ma, val</span>):</span><br><span class="line">        addr = ma.getAddress()</span><br><span class="line">        sz = ma.getSize()</span><br><span class="line">        <span class="comment"># 只会加载之前没有加载过的页面</span></span><br><span class="line">        tri_load_dbg_mem(ctx, handle, addr, sz, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    ctx.addCallback(CALLBACK.GET_CONCRETE_MEMORY_VALUE, getmemcb)</span><br><span class="line">    ctx.addCallback(CALLBACK.SET_CONCRETE_MEMORY_VALUE, setmemcb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py中设置Triton</p>
</blockquote>
<p>调试器还让我们处理我们的象征执行引擎不知道的指令。例如，Triton没有定义’<em>rdrand</em>‘指令。通过与我们的调试器单步执行，我们可以在遇到未知指令时简单地修正任何更改的寄存器。这可能会导致如果我们的符号输入与指令一起做某些事情时，符号信息的丢失，但大多数情况下我们可以忽略这些指令。</p>
<p>最后，使用我们的调试器给我们带来了另一个非常好的好处；我们可以跳过整个无关代码的区域！我们必须非常小心地标记什么为无关，因为做错了可能意味着我们失去了很多符号信息。对于procmon，我将大部分绘图代码标记为无关。当从user32或gdi32中击中这些导入之一时，我们放置一个断点并让调试器跨过这些调用，然后恢复与Triton的单步执行。这节省了大量的时间，因为符号执行比实际执行慢了几个数量级。我们可以跨过的任何无关代码都可以产生巨大的差异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跳过绘图代码</span></span><br><span class="line"><span class="keyword">if</span> skip_imports:</span><br><span class="line">    impfuncs = dbg_get_imports_from(handle, base, [<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;gdi32.dll&quot;</span>, <span class="string">&quot;comdlg32.dll&quot;</span>, <span class="string">&quot;comctl32.dll&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> impfuncs:</span><br><span class="line">        addr = impfuncs[name]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不跳过一些user32的</span></span><br><span class="line">        skip = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> ds <span class="keyword">in</span> [<span class="string">&quot;PostMessage&quot;</span>, <span class="string">&quot;DefWindowProc&quot;</span>, <span class="string">&quot;PostQuitMessage&quot;</span>, <span class="string">&quot;GetMessagePos&quot;</span>, <span class="string">&quot;PeekMessage&quot;</span>, <span class="string">&quot;DispatchMessage&quot;</span>, <span class="string">&quot;GetMessage&quot;</span>, <span class="string">&quot;TranslateMessage&quot;</span>, <span class="string">&quot;SendMessage&quot;</span>, <span class="string">&quot;CallWindowProc&quot;</span>, <span class="string">&quot;CallNextHook&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> ds.lower() <span class="keyword">in</span> name.lower():</span><br><span class="line">                skip = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> skip:</span><br><span class="line">            hooks[addr] = (skipfunc_hook, name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py中跳过不需要的导入</p>
</blockquote>
<p>对于我们的目标，跳过导入还不够。我们仍然在procmon二进制文件中的循环中花费大量时间。快速查看确认这些是静态包含的_memset_和_memcpy_。我们不能只是跳过_memcpy_，因为我们会失去正在复制的符号信息。因此对于这两个，我们编写了一个钩子，会在Python中以符号方式处理操作，而不必模拟每条指令。我们确保复制的字节在源数据中获得了符号表达式的副本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    sa = MemoryAccess(src + i, <span class="number">1</span>)</span><br><span class="line">    da = MemoryAccess(dst + i, <span class="number">1</span>)</span><br><span class="line">    cell = ctx.getMemoryAst(sa)</span><br><span class="line">    expr = ctx.newSymbolicExpression(cell, <span class="string">&quot;memcpy byte&quot;</span>)</span><br><span class="line">    ctx.assignSymbolicExpressionToMemory(expr, da)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在我们的memcpy钩子中传输符号信息</p>
</blockquote>
<p>这些类型的钩子不仅节省了我们的时间，而且是一个检查_memcpy_或_memset_中符号参数的绝佳机会。即使当前跟踪不会在_memcpy_中崩溃，我们也有能力查看这些符号参数并询问“这个_memcpy_能否到达未映射的内存？”或者“大小参数是否不合理地大？”。这可以帮助我们找到其他漏洞，或者我们已经跟踪的问题的其他表达方式。以下是一个小检查，试图看看_memcpy_的目的地的结尾是否可以很远。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">astctx = ctx.getAstContext()</span><br><span class="line">cond = ctx.getPathPredicate()</span><br><span class="line"><span class="comment"># dst + size</span></span><br><span class="line">dstendast = ctx.getRegisterAst(ctx.registers.rcx) + ctx.getRegisterAst(ctx.registers.r8)</span><br><span class="line"><span class="comment"># dst + size的具体值</span></span><br><span class="line">dstendcon = dst + size</span><br><span class="line">testpast = <span class="number">0x414141</span></span><br><span class="line">cond = astctx.land([cond, (dstendcon + testpast) &lt;= dstendast])</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;hook&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Trying to solve for a big memcpy&quot;</span>)</span><br><span class="line">model, status, _ = ctx.getModel(cond, <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">if</span> status == SOLVER_STATE.SAT:</span><br><span class="line">    <span class="comment"># 可以走那么远</span></span><br><span class="line">    <span class="comment"># 这可能不是我们崩溃的原因，所以让我们只是报告它，而不是引发它</span></span><br><span class="line">    log(<span class="string">&quot;crash&quot;</span>, <span class="number">2</span>, <span class="string">&quot;Symbolic memcpy could go really far!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在triage.py的memcpy钩子中的一个简单检查</p>
</blockquote>
<p>这些检查的权衡是经常调用求解器可能会增加我们的运行时间，你可能不希望它们一直启用。</p>
<p>到目前为止，我们已经拥有了运行我们的崩溃案例并开始去重和根本原因分析所需的大部分内容。然而，我们的一些访问违规仍然表示错误的解引用不依赖于我们的输入。这对我来说没有意义，因此我怀疑我们在某个地方丢失了符号信息。有时这可能由于指针的具体化而发生，因此打开Triton的新_MEMORY_ARRAY_模式可以帮助我们恢复该信息（以速度为代价）。</p>
<p>在这种情况下，我让我的工具在跟踪过程中打印出所有被调用的导入函数。我想看看路径上的任何系统调用是否会导致符号信息的丢失。或者是否有一个调用重新引入了输入而没有被符号化。我发现还有一个对_MapViewOfFile_的第二个调用，它将我们的输入文件重新映射到内存中的另一个位置。通过<a href="https://github.com/atredis-jordan/SymbolicTriagePost/blob/main/triage.py#L861">添加一个钩子</a>来符号化重新映射的输入，现在所有的崩溃都正确地报告了它们与输入的符号关系！</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/7a06203f-edfd-4b81-816a-99f01c6d8a79/crashast.png" alt="img"></p>
<p><em>我们的工具显示了一个坏解引用的AST</em></p>
<h2 id="使用我们的象征性调试器"><a href="#使用我们的象征性调试器" class="headerlink" title="使用我们的象征性调试器"></a>使用我们的象征性调试器</h2><p>酷！现在我们有了我们崩溃的符号信息。我们用它做什么？</p>
<p>首先，我们可以快速根据它们依赖的输入将我们的崩溃进行分组。这非常有帮助；即使一些问题可能导致多个位置的崩溃，我们仍然可以根据确切的输入缺乏边界检查将它们组合在一起。这可以帮助我们更好地理解一个错误，并看到错误与系统的不同交互方式。</p>
<p>通过分组我们的崩溃，看起来我们的200个左右的崩溃可以归结为四个不同的组：三个被控制的指针被读取和一个调用___fastfail_。</p>
<p>Triton给我们的一个很酷的工具是反向切片！因为Triton在构建它的符号表达式时可以保持与相关指令的引用，我们可以生成一个只包含与我们最终表达式相关的指令的指令跟踪。我使用这个来削减大部分代码作为无关的，并能够只走输入和崩溃之间的相关代码片段。以下是我们收集的有关一个崩溃中被解引用的坏指针的相关指令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backslice_expr</span>(<span class="params">ctx, symbexp, print_expr=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># 按refId排序以按时间顺序</span></span><br><span class="line">    <span class="comment"># 从加载访问中获取符号表达式，可以这样做：</span></span><br><span class="line">    <span class="comment"># symbexp = inst.getLoadAccess()[0][0].getLeaAst().getSymbolicExpression()</span></span><br><span class="line">    items = <span class="built_in">sorted</span>(ctx.sliceExpressions(symbexp).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, expr <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> print_expr:</span><br><span class="line">            <span class="built_in">print</span>(expr)</span><br><span class="line">        da = expr.getDisassembly()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(da) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> <span class="keyword">if</span> print_expr <span class="keyword">else</span> <span class="string">&quot;&quot;</span>, da)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>triage.py中的一个反向切片助手</p>
</blockquote>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/8f5fd529-b03a-4a4a-8527-1d29f63cfa2c/backslice_sm.png" alt="img"></p>
<p><em>使用上述代码进行反向切片</em></p>
<p>能够在跟踪的任何点进入IPython REPL并看到程序状态以我的输入为依据在我的RE过程中非常有帮助。</p>
<p>对于调用___fastfail_（有点像Windows的_abort_），我们这里没有坏解引用来进行反向切片，相反我们有我们的引擎收集的路径约束。这些约束是任何时候引擎看到我们可以在交叉路口象征性地走两条路时捕获的。为了保持与我们的具体路径的联系，引擎记录了我们路径所需的条件。例如：如果我们在将INPUT_5字节与0比较后采取了一个_jne_分支，引擎将添加一个路径约束，说“如果你想继续我们走的路径，请确保INPUT_5不是0”，或者用AST的话说“_(not (&#x3D; INPUT_5 (_ bv0 8))_)”。</p>
<p>这些路径约束非常有用。我们可以使用它们来生成其他输入，这些输入会走未探索的路径。有很多不错的符号执行工具使用这个来帮助模糊测试器生成有趣的新输入。（<a href="https://github.com/eurecom-s3/symcc">SymCC</a>、<a href="http://klee.github.io/">KLEE</a>、<a href="https://github.com/shellphish/driller">Driller</a>，举三个例子）</p>
<p>在我们的情况下，我们可以检查它们来找出为什么我们最终到达了___fastfail_。通过仅查看最近的路径约束，我们可以看到由于我们的输入，我们的路径最近在哪里分叉。</p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/3ce16869-7e3a-4bf6-8aa5-8ed45016f63c/abort_constraint.png" alt="img"></p>
<p><em>导致___fastfail_的最最近的路径约束</em></p>
<p><img src="https://images.squarespace-cdn.com/content/v1/576323cfd482e984e113fe9c/00f6dda5-90e0-4f16-b572-391f25baf398/constraint_path.png" alt="img"></p>
<p><em>最最近的路径约束周围的汇编</em></p>
<p>路径约束告诉我们，上面的汇编中的条件跳转在_0x7FF7A3F43517_是我们的路径由于我们的输入值而最后一次分叉的地方。当我们在分叉后跟踪路径时，我们可以看到它总是直接导致我们的致命条件。为了获取更多关于分叉前的比较失败的信息，我为我们在该连接处进入了一个IPython shell。我们的工具使我们可以轻松地确定我们在分支前解引用的RCX指针的控制。这使这成为另一个由于控制指针读取而导致的崩溃。</p>
<p>显示分支前解引用寄存器的AST</p>
<h2 id="从这里去哪里"><a href="#从这里去哪里" class="headerlink" title="从这里去哪里"></a>从这里去哪里</h2><p>所以从这里我们对_procmon64.exe_中存在的问题有了一个很好的理解。更深入地研究崩溃显示它们可能不适用于制作恶意PML文件。如果我想继续走这条路，我的下一步将包括：</p>
<ul>
<li>根据已知的输入中未检查的区域为我们的模糊测试器生成有趣的测试案例</li>
<li>识别我们利用路径中看起来很有吸引力的函数。有了我们的工具，我们可以收集有关我们在这些函数中拥有的控制的信息。有了这些信息，我们可以开始路径探索或生成遵循我们对看起来有趣的区域的直觉的模糊测试案例。</li>
<li>修补不感兴趣的崩溃位置，并让我们的模糊测试器在不被低挂的果实阻止的情况下找到更好的路径。</li>
<li><a href="https://forum.spacehey.com/topic?id=93101">为了好玩，生成一个非常小的崩溃输入</a>。</li>
</ul>
<p>微软的官方政策是“所有Sysinternals工具都是‘按原样’提供的，没有官方的微软支持。”我们未能找到一个合适的地方来报告这些问题。如果任何与Sysinternals套件有联系的人想要更多信息，请与我们联系。</p>
<h2 id="希望这有所帮助！来参加课程吧！"><a href="#希望这有所帮助！来参加课程吧！" class="headerlink" title="希望这有所帮助！来参加课程吧！"></a>希望这有所帮助！来参加课程吧！</h2><p>我希望这篇文章能帮助你看到创造性的符号执行工具如何帮助他们的工作流程！如果有人有任何问题或想要谈论它，可以通过@jordan9001或<a href="mailto:&#x6a;&#x6f;&#x72;&#x64;&#x61;&#x6e;&#x2e;&#x77;&#104;&#105;&#x74;&#x65;&#x68;&#101;&#97;&#100;&#64;&#x61;&#x74;&#114;&#101;&#100;&#x69;&#115;&#46;&#x63;&#x6f;&#109;">&#x6a;&#x6f;&#x72;&#x64;&#x61;&#x6e;&#x2e;&#x77;&#104;&#105;&#x74;&#x65;&#x68;&#101;&#97;&#100;&#64;&#x61;&#x74;&#114;&#101;&#100;&#x69;&#115;&#46;&#x63;&#x6f;&#109;</a>给我发消息。</p>
<p>如果你读到了这篇文章的最后，你可能会喜欢我们的课程！</p>
<p>“实用符号执行用于VR和RE”是动手的。制作它我有很多乐趣，我们查看了应用这些概念的各种方式。学生们花时间熟悉一些框架，去混淆二进制文件，检测检查时间-使用时间的漏洞，以及其他有趣的事情。</p>
<p>你可以在下面提供你的信息，我们将在下次提供公开课程时通过电子邮件通知你。（没有垃圾邮件或其他任何东西，我保证。）</p>
<p>如果你有一个团队对接受这种培训感兴趣，也可以与我们联系，我们也可以私下提供这种培训！我希望有一天能在课堂上见到你！</p>
<p>谢谢！</p>
<p>我们尊重你的隐私，不会将你的联系信息用于除Atredis培训新闻之外的任何其他用途。</p>
<p>谢谢！</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/%E9%9B%B7%E5%86%9B%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/</url>
    <content><![CDATA[<p>34c: BBA系列入门款</p>
<p>人生值得被奖励，这就是dream car 的意义</p>
<p>订货目标：76000</p>
<p>定价：对标moudle3 21.59</p>
<p>保底10万，立正12万</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/09/06/%E5%BE%85%E5%A4%84%E7%90%86/rust%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>原文地址：<a href="https://kyju.org/blog/rustconf-2018-keynote/">https://kyju.org/blog/rustconf-2018-keynote/</a></p>
<p>这篇文章是关于 RustConf 2018 大会上的闭幕主题演讲的内容。以下是文章的主要内容翻译：</p>
<hr>
<p>我承诺在 RustConf 2018 的闭幕主题演讲中做两件事：</p>
<ol>
<li>我会将演讲的幻灯片放到网上。</li>
<li>我会在我的博客上发布演讲的长篇版本。</li>
</ol>
<p>​	2.a. 我实际上会为此目的创建一个博客。</p>
<p>……我花了该死的时间来做这件事。终于，我做到了我承诺会做的事情！</p>
<p>如果你还没有看到并且想看，你可以在这里看到我做的现场演讲。</p>
<p>演讲的幻灯片（有少量勘误）现在已经托管在这里。</p>
<p>所以，我在演讲中说我会发布一个可能更有趣的长篇版本，包括我无法在大约30分钟的时间槽中放入的内容。下面我包含的是我演讲的原始长篇版本，但我最初的意图并不是像这样发布。最初我想再整理一下，使其不那么像一堵文字墙，但当我开始做这件事时，我意识到我只是在完全重写它，以那种速度我永远不会发布它，而我 <em>承诺</em> 我会及时发布。</p>
<p>我对此并不满意，回想起来，我认为我为大约30分钟的演讲剪掉的很多东西可能是明智的剪掉的。我认为关于控制台开发的部分非常投机，并没有什么帮助，而最后关于语言边界特别困难的部分，虽然是真的，但有点离题。然而，人们似乎非常感兴趣，并且（非常正确地）提醒我我还没有发布这个，所以与其进一步拖延，我会给你我制作的非常轻微编辑的演讲文本版本。请记住，这是在我意识到我永远不会在30分钟内适应之前 :)。这是用非常非正式、对话的风格写的，因为这是为我演讲的素材。</p>
<p>不再赘述了……</p>
<hr>
<h2 id="RustConf-2018-演讲的草稿"><a href="#RustConf-2018-演讲的草稿" class="headerlink" title="RustConf 2018 演讲的草稿"></a>RustConf 2018 演讲的草稿</h2><p>这是我在 RustConf 2018 主题演讲中想要谈论的内容的非常粗略的大纲。</p>
<p>这次演讲假设你除了一些 Rust 的知识外，还知道一些 C++，并且有很多 C++ 代码示例，但我希望它们足够明显，不会分散那些可能不习惯 C++ 的人的注意力。</p>
<h2 id="演讲的基本论点："><a href="#演讲的基本论点：" class="headerlink" title="演讲的基本论点："></a>演讲的基本论点：</h2><p>Rust 通过设计，使某些编程模式比其他模式更痛苦。这是一件好事！事实证明，对于游戏开发来说，在 Rust 中最容易处理的模式与在 <em>任何</em> 语言中最容易处理的游戏开发模式非常相似。</p>
<p>不幸的是，我不得不以艰难的方式学到这一点！</p>
<p>Rust 极大地奖励了数据导向设计，具有简单、易于理解的所有权语义，这对于游戏开发来说是个好消息。我怀疑这通常也是正确的，不仅仅是对游戏开发！（但我能知道什么？）</p>
<h2 id="你为什么要听我说，我是谁？"><a href="#你为什么要听我说，我是谁？" class="headerlink" title="你为什么要听我说，我是谁？"></a>你为什么要听我说，我是谁？</h2><p>我是 Starbound 的首席程序员，我是 Chucklefish 最初的成员之一，当时我们都是通过 IRC 工作。当 Chucklefish 决定我们应该有一个人被称为“技术领导”时，我是技术领导。我仍然与 Chucklefish 有外围合作，但自从我回到美国后，我现在更独立地工作了。</p>
<p>但是，老实说，我不确定你 <em>应该</em> 听我说！我帮助发布了一个（1）完整的商业游戏，这次演讲的一些部分是基于我帮助制作的一个商业游戏的警示故事，关于什么 <em>不</em> 该做。</p>
<p>我绝对觉得你不应该根据我的建议做出任何……真正的 <em>成熟</em> 商业决策。我不能确定 Rust 是否适合你，或者你是否应该或不应该用 Rust 制作你的游戏，当然，可能还有更大的问题，这取决于你是独立开发者，你的个人技能水平和容忍度以及偏好，以及如果你是一家公司，你需要什么工具和引擎，中间件等。</p>
<p>我所能说的是，我个人将在未来可预见的时间内使用 Rust 进行游戏开发（和其他事情！），如果你想知道为什么，或者如果你已经决定你想使用 Rust 并想知道你将要面对什么，那么这次演讲可能很有用。</p>
<p>这次演讲将比我更喜欢的更……模糊。我通常更习惯于给出具体的非常技术性的建议，在那里我可以从第一原理几乎证明我的观点，但像架构建议或一般建议这样的事情可能永远不会那么明确。我确实认为这仍然是 _有用的_，这就是我为什么要做这件事（并且人们似乎感兴趣），但请记住：这都是我个人的看法，伙计。</p>
<h2 id="你-怎么-甚至用-Rust-制作游戏？"><a href="#你-怎么-甚至用-Rust-制作游戏？" class="headerlink" title="你 怎么 甚至用 Rust 制作游戏？"></a>你 <em>怎么</em> 甚至用 Rust 制作游戏？</h2><p>过去一年左右，我收到了很多问题，基本上在问：</p>
<blockquote>
<p>如何从零开始用 Rust 制作游戏？不，说真的……怎么做。我的意思是，我<br>可以看到你 <em>理论上</em> 怎么做，但不知何故当我尝试应用<br>我习惯的其他语言的模式时，我只是遇到很多问题？<br>我听说这被称为“与借用检查器战斗”，但……这似乎并没有真正 <em>帮助</em> 我。我做错了什么？</p>
</blockquote>
<p>或者，也许是像这样的：</p>
<blockquote>
<p>我可以看到如果你喜欢非常严格的控制，Rust 是很棒的，我可以看到它<br>被用于小型实用程序或安全性至关重要的地方，但它<br>看起来非常限制性！我真的看不出你如何在不到处遇到这些限制的情况下制作像游戏这样大的东西。你如何在不需要 Rc<RefCell> 和 Arc<Mutex> 的情况下构建像游戏这样的东西？</p>
</blockquote>
<p>这些问题（稻草人）当然是关于游戏的，但它们也反映了我见过的关于 Rust 的普遍情绪。如果不是很明显，我不同意这种情绪（毕竟我在 RustConf），我认为对我来说最好的方式是谈论为什么我不同意它，是通过谈论我所知道的，所以我将从游戏的角度来谈论这个问题。</p>
<p>这次演讲可以只是我走上讲台说“天啊，没那么难！数据导向设计！如果你在制作游戏，使用 ECS！……谢谢。”然后走下舞台，从某种角度来看，我确实觉得 <em>可以</em> 这么简单，但我认为这里有一个更重要的根本点，这就是这次演讲的内容。这个问题的非常非常简短的答案是：如果你忘记面向对象设计，而是只专注于你的游戏状态（或你正在制作的任何东西）的数据表示，并且你努力不使事情比它真正需要的更复杂，事情实际上可以相当简单！这次演讲将缓慢地向一个简单的 Rust 中的 ECS 实现工作，并尝试为每一步提供理由，但不是 <em>所有</em> 步骤都是必要的。我甚至不认为使用某种特定的设计模式如 ECS 是必不可少的，我认为更重要的更大的点是放下一些习惯，至少 <em>我</em> 有这些习惯，使事情比它们需要的更困难，尤其是在 Rust 中。</p>
<p>对一些人来说，我在这次演讲中所说的可能 _显而易见_。如果这对你来说都是显而易见的，那很好，但这些对我来说并不总是显而易见的。事实上，我之所以如此喜欢 Rust 的部分原因是，我并不是通过尝试用 Rust 构建游戏学到这些教训的，我大部分是在第一次尝试 Rust 之前，从我早期在 Starbound 中犯的错误中学到的。我需要有人来指责以展示什么 <em>不</em> 应该做，所以非常方便的是，我有一个如此好的例子在我的过去。</p>
<p>我肯定会重复其他人已经给出的一些建议。事实上，其中一些已经变得众所周知，几乎已经成为陈词滥调：继承是坏的，面向对象大多是坏的，ECS 设计是好的，等等。希望在这些 <em>是</em> 真的程度上，我提供了更多的证据，并描述了为什么这些在借用检查器的存在下尤其重要，但希望我也能给这些增加一些细微差别，这对其他想要用 Rust 进行游戏开发的人也会有所帮助。</p>
<h2 id="你怎么甚至制作游戏"><a href="#你怎么甚至制作游戏" class="headerlink" title="你怎么甚至制作游戏"></a>你怎么甚至制作游戏</h2><p>当然，这些问题只会在你尝试从头开始设计游戏架构时出现，当然，许多人实际上不会这样做。事实上，通常给独立开发者的建议是 <em>永远</em> 不要制作你自己的引擎，如果你使用像 Unity 或 Unreal 这样的引擎来制作你的游戏，很多这些决定将为你做出。</p>
<p>我绝对 <em>没有</em> 遵循这个建议。事实上，我认为 Starbound 直接违反了你通常给新独立开发者的每一条建议：</p>
<ul>
<li><p>不要制作你自己的引擎<br>(Starbound 基本上是在 SDL &#x2F; libogg &#x2F; libvorbis &#x2F; libfreetype 等之上用裸 C++ 编写的)</p>
</li>
<li><p>总是制作一个原型，并计划扔掉它<br>(我用来演示两周的代码与 1.0 版本是同一血统)</p>
</li>
<li><p>说真的，不要制作你自己的引擎，只使用 Unity &#x2F; Unreal &#x2F; Godot 等<br>(我们甚至没有使用 boost！事实上，在某个时候我们添加了我们自己的 c++17 类的版本，比如 std::optional 和 std::variant，因为当时比开始依赖 boost 更容易。我们还自己想出了一种系统来做 2D 纹理图集，因为我们找不到一种好的方法来做如此多小纹理的离线纹理图集，这些小纹理不容易分组)</p>
</li>
<li><p>你的第一款游戏应该是简单的，你应该制作一些简单的东西，你可以在短时间内发布。<br>(在 Starbound 中，你可以有一个玩家持有的物品，运行它自己的 Lua 脚本，这会影响玩家的物理属性，可以与其他物品和玩家拥有的能力合作，这些能力也有自己的脚本，也可以影响玩家的物理属性（同时），同时给玩家脚本化的状态效果，这些效果可以向大多数实体都有的通用状态数据库添加他们自己的自定义统计数据，这些统计数据也可以从脚本中控制。还有一个完整的糟糕的 DSL，用于绘制材料块，这些块在视觉上以任意复杂的方式连接在一起)</p>
</li>
</ul>
<p>我绝对不是想告诉任何人制作 <em>任何</em> 类似我制作的第一款商业游戏的东西，不要跟随我的脚步，我不认为我会推荐给任何人。然而，实际上有很多独立开发者不使用 Unreal &#x2F; Unity 风格的游戏引擎，而是使用更多的“库”风格的游戏引擎，他们只使用单个库来提供特定功能，或者使用主要提供渲染，音频和输入的小“框架”，并自己创建他们制作的游戏的基本结构。（我曾经有一个移植公司称这种“旧学校”开发风格，这让我非常沮丧）</p>
<ul>
<li><p>任何使用 XNA 或 MonoGame 制作的游戏。XNA &#x2F; MonoGame 肯定在单个包中提供了很多（渲染、声音、输入），但它们不决定游戏本身的架构。这包括 Terraria 和 Stardew Valley，只是举两个例子。</p>
</li>
<li><p>任何由 Jonathan Blow 制作的游戏（Braid, The Witness）</p>
</li>
<li><p>任何由 Zach Barth 制作的游戏（Zachtronics）。他曾表示，当他开始开发游戏时，他从一个裸事件循环（输入 &#x2F; 更新 &#x2F; 渲染）开始。（注意：我找不到这个的来源，所以我希望我没有误解他，我认为他在我现在找不到的采访中说过）</p>
</li>
<li><p>任何由 Supergiant 制作的游戏（Bastion, Transistor, Pyre）</p>
</li>
<li><p>完全在内部制作的 Chucklefish 游戏：显然 Starbound，还有 Wargroove（使用通用 C++ 引擎 halley 制作，但引擎的主要开发人员是 Wargroove 的主要开发人员）。</p>
</li>
<li><p>还有很多很多我没有列出的，许多 2D 游戏是这样制作的，一些 3D 游戏也是如此。有 <em>几十个</em> 我们，我告诉你。</p>
</li>
</ul>
<p>显然，如果我的建议不适用，你决定使用像 Unity 或 Unreal 这样决定了大部分游戏结构的有偏见的游戏引擎，那么我并不是试图说服你离开。显然，如果你使用其中之一，并且你很高兴，那么我不会试图说服你离开。显然，如果你使用其中之一，Rust 可能就不可能了，除了非常非常外围的事情，但老实说，我仍然认为最终 Rust 会找到进入这些商业主流游戏引擎产品的方式，只是时间问题。</p>
<p>不过，目前，最有可能使用 Rust 并发现这次演讲有用的人是其他从头开始的独立类型，以及一些在内部制作大量技术的 AAA 工作室（Ready at Dawn!, EA SEED!）。我也相信，迟早会有使用 Rust 的 Unity 或 UE 竞争对手！</p>
<p>那么好吧，假设你决定制作一款游戏，你 <em>不打算</em> 使用像 Unreal 或 Unity 这样决定大部分游戏结构的有偏见的游戏引擎，你决定使用 Rust，那么这样的东西会是什么样子？</p>
<h2 id="过去是如何制作游戏的"><a href="#过去是如何制作游戏的" class="headerlink" title="过去是如何制作游戏的"></a>过去是如何制作游戏的</h2><p>所以，在过去，游戏主要是以“数据导向”的方式工程化的，这纯粹是出于必要。当你的目标控制台有 128KB 的 RAM（SNES）时，就没有多少抽象的余地。我将把这个时代称为视频游戏开发的“行动回放”时代。如果你不知道，这些是作弊设备，有点像“游戏精灵”或“游戏鲨鱼”，如果你知道的话，你可以在每一帧修补游戏的 RAM 状态。“游戏精灵”和类似的设备允许你修补游戏卡带的 ROM，但“行动回放”设备实际上让你插入钩子到比如说，VBlank 处理程序，覆盖每一帧的实际内存值，以比如说给你无限生命等。</p>
<p>这之所以有效，是因为显然在 128KB 的 RAM 中，你不太可能有 malloc 的实现！。每一字节的存储都是非常宝贵的，所以大多数这个时代的游戏都是设计得非常可预测的手动管理它们整个游戏状态在内存中。在 NES &#x2F; SNES 时代，内存如此之少，通常图形表示你的游戏（瓦片，精灵）和你的逻辑表示你的游戏是相同的，如果你眯着眼睛看，你会看到“实体”结构，但通常游戏可以跟踪的“事物”的最大数量是如此之少，以至于没有足够的空间用于任何通用性。这有时也被称为游戏开发的“场外治愈力”时代，因为一旦你离开屏幕，游戏关卡的那部分通常就被遗忘了（敌人神奇地被治愈了）。</p>
<p>想象一下，如果你要为 NES 编写一个 Rust 游戏（可能真的很难，但不是不可能？至少不比 C 难，C 同样真的很难。我相当确定基本上所有 SNES 时代的游戏都是用汇编语言编写的。），你可能会定义一个单一的静态数据结构，像这个完全虚构的例子：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">ProjectileType</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EnemyType</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EnemyBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">Tile</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PlayerProjectile</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> proj_type: ProjectileType,</span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Enemy</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> enemy_type: EnemyType,</span><br><span class="line">    <span class="keyword">pub</span> behavior: EnemyBehavior,</span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> player_pos: Vector2&lt;<span class="type">i16</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> player_vel: Vector2&lt;<span class="type">i8</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> player_health: <span class="type">i8</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你想要屏幕上超过 4 个炮弹？不行，如果玩家发射更多，清除最旧的以腾出空间，或者等到它们击中</span></span><br><span class="line">    <span class="comment">// 某些东西或移出屏幕（像洛克人一样）。</span></span><br><span class="line">    <span class="keyword">pub</span> player_projectiles: [<span class="type">Option</span>&lt;PlayerProjectile&gt;; <span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有关卡数据都存储在这个常量内存块中。</span></span><br><span class="line">    <span class="keyword">pub</span> level_tiles: [[Tile; <span class="number">64</span>]; <span class="number">64</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏幕上有 8 个敌人，之后，你必须等待敌人消失才能生成更多（在 Kirby&#x27;s Adventure 中，这在工具辅助速通中被高度滥用）</span></span><br><span class="line">    <span class="keyword">pub</span> enemies: [Enemy; <span class="number">8</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过这种方式了解软件的工作原理，即使你这是一个虚构的例子。</p>
<p>这里需要注意的一件事是，由于每个 SNES 游戏很可能是用汇编语言编写的，几乎可以肯定没有“数据隐藏”这样的事情，游戏的整个状态在任何时候都可以被更新循环访问。</p>
<p>这种每个内存位置都很宝贵，对象被仔细地放置在其中的时代实际上持续了很长时间，至少一直到 N64。</p>
<p>让我们看另一个我比较熟悉的例子，它仍然牢固地处于这个时代，但其设计在我看来更接近现代游戏引擎。我最喜欢的游戏之一：Mario 64。Mario 64 很有趣，因为它是 3D 的，除了低多边形简单图形外，它真的 <em>那么</em> 不同于现代 3D 平台游戏吗？然而，它仍然牢固地处于“行动回放”时代的游戏，当你进入一个“游戏世界”（你可以像马里奥一样奔跑和跳跃）时，你可以可靠地告诉（或多或少）所有的关卡数据将生活在 N64 的广阔，豪华的 4 个 MB 的 ram 中。有一个可预测的内存块用于关卡几何，用于许多不同的关卡标志等，但游戏中的大部分动态内容都以通用的“实体”（或“对象”）的形式存在，就像现代游戏引擎一样。在 Mario 64 中，实体结构都是完全 608 字节长，并且有一个硬限制为 240 个（有时这有点少，比如在 Bowser in the Fire Sea 中，限制为 232 个对象）。</p>
<p>我们实际上不知道 Mario 64 是用什么语言编写的，但它 <em>可能</em> 是 C，所以这可能是一个时代，如果你有一台时间机器和一个强烈的愿望想要一个更好的系统语言来自未来，你可以很容易地使用 Rust 制作商业 Nintendo 64 游戏。让我们采取很多艺术自由，并想象这样一个游戏的结构，尽可能直接地翻译成 Rust：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityAnimation</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="comment">// 这个实体是否初始化并且活跃，或者它是否死亡并且可以被覆盖。</span></span><br><span class="line">    <span class="keyword">pub</span> initialized: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，这真的很有趣。在 Mario 64 中，所有实体被划分为“重要”和“不重要”的实体。重要的实体是</span></span><br><span class="line">    <span class="comment">// 像马里奥自己，硬币，敌人等。不重要的实体是像风效果或从马里奥的屁股踩出来的星星</span></span><br><span class="line">    <span class="comment">// 这样的效果。当游戏用完实体插槽时，它将删除不重要的实体以为重要的实体腾出空间。如果游戏</span></span><br><span class="line">    <span class="comment">// 试图创建超过 240 个重要的实体（或在 BitFS 中为 232），它将挂起。</span></span><br><span class="line">    <span class="keyword">pub</span> important: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> position: Vector3&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> rotation: Vector3&lt;<span class="type">f32</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我认为在真正的 Mario 64 中，大多数这样的事情是指针，但它们也可以很容易地是索引。这</span></span><br><span class="line">    <span class="comment">// 被证明是相当重要的。</span></span><br><span class="line">    <span class="keyword">pub</span> animation: EntityAnimation,</span><br><span class="line">    <span class="keyword">pub</span> behavior: EntityBehavior,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> visible: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> damage_mario_on_touch: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> home_in_on_mario: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通用计时器，用于许多动画和游戏目的</span></span><br><span class="line">    <span class="keyword">pub</span> timer: <span class="type">u16</span>,</span><br><span class="line">    <span class="comment">// 通用动作，对不同的实体类型有不同的用途</span></span><br><span class="line">    <span class="keyword">pub</span> action: <span class="type">u8</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多的东西...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldRenderGeometry</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldCollisions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> world_render_geometry: WorldRenderGeometry,</span><br><span class="line">    <span class="keyword">pub</span> world_collisions: WorldCollisions,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真的，不超过 240</span></span><br><span class="line">    <span class="keyword">pub</span> entities: [Entity; <span class="number">240</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而不是指针，我们存储一个索引到实体数组中。</span></span><br><span class="line">    <span class="keyword">pub</span> mario_entity: EntityIndex,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多的东西...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这些表示的具体细节并不是真的很重要，重要的是：</p>
<ul>
<li><p>游戏状态的表示（尽管这里被极大地简化了）在真正的游戏中仍然非常 _简单_。它非常可预测，并且易于 RAM 值戳，这里并没有真正的“抽象”，一切都是相当字面和</p>
</li>
<li><p>专门建造的。</p>
<ul>
<li><p>我们不能确定 N64 时代所有游戏使用的语言，但我们知道至少有一些标题肯定是 C（Shadows of the Empire），并且很可能在大多数情况下是 C。游戏结构都倾向于像 Mario 64 那样简单和可预测，你可以想象游戏状态主要被表示为全局 C 结构或结构数组。</p>
</li>
<li><p>我在这里猜测，但 <em>可能</em> 没有太多的“数据隐藏”，你可以想象这些游戏的结构更像是一个巨大的静态全局结构，包含“所有游戏状态”，对游戏的所有代码都是可见的。</p>
</li>
<li><p>偶尔有指向函数的指针，但似乎没有太多的面向对象的东西。似乎没有 vtables，甚至没有多少像 vtables 这样的东西，或者类似的东西。这可能是纯粹的猜测，并且肯定只是非专家的意见，但从我对 SNES - N64 时代标题的内存布局和设计的“广泛”研究来看，通常感觉你可以从数据格式中想象出构成引擎的基本、无聊、专门制作的 C 代码。</p>
</li>
</ul>
<p>好的，想象一下你将以与最初设计非常相似的方式编写 Mario 64，但是在 Rust 中。你将有效地编写一个巨大的、程序化的、单一用途的游戏引擎，在一个更漂亮的 C 中，但在其核心，仍然像 C。有效地你的游戏引擎是类似于（即将到来的戏剧性过度简化）：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityAnimation</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EntityBehavior</span> = <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="comment">// ... 见上文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">u8</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldRenderGeometry</span>;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WorldCollisions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    <span class="comment">// ... 见上文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 所有的游戏状态，道德上是一个全局变量。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = GameState &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// 每一次这个循环都是 1 帧，对于一个 60fps 的游戏来说是 16ms。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们一次捕获整个输入，在一帧的开始。甚至真的不需要像输入事件这样复杂的东西，因为在</span></span><br><span class="line">        <span class="comment">// 像 Mario 64 这样的东西中，真正发生的读取控制器状态就是读取控制器状态的特定内存区域。在这里，</span></span><br><span class="line">        <span class="comment">// 我们只是在帧的开始这样做，在真正的 Mario 64 中我相信每一帧都会在不同的系统中分布。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让我们有一系列函数根据上一个游戏状态和输入改变游戏状态</span></span><br><span class="line">        <span class="comment">// 我们将这种非常简单的模式命名为一个“系统”。</span></span><br><span class="line">        <span class="comment">// 设置马里奥内部的状态标志以开始跳跃，或者也许设置一个标志来表示你是否暂停。</span></span><br><span class="line">        <span class="title function_ invoke__">input_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pos += vel * dt; 应用重力。对所有实体进行碰撞检测和响应</span></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每个实体运行实体逻辑，这可能会分派到 update_mario, update_baddies, update_platforms 等。</span></span><br><span class="line">        <span class="title function_ invoke__">entity_logic_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染当前的游戏状态。在 N64 时代，这在某些方面比现在简单得多，但即使在那时也可能仍然相当混乱和有状态的，所以也许我们的游戏状态包括加载的图形资源的状态。</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取实体的状态标志并触发新的音频，这和渲染一样混乱和有状态的。</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 VBlank</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vblank</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重复。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我不是推荐你以这种方式制作游戏！然而，即使你认为这 100% 是一个荒谬的过度简化，或者你认为即使你可以以这种方式制作一个大型复杂的游戏，它也会变成一个程序化的泥球，让我们来看一下这个一段时间，看看是否有任何优势，然后再完全否定它。显然有一个巨大的、明显的劣势，那就是整个游戏状态对所有系统都是可见和可变的，如果某些东西意外地改变了，你可能不知道去哪里查找以找出是什么在不当的方式改变游戏状态。没有人 <em>真的</em> 建议在现代时代编写软件，将所有状态作为实际上的全局变量。</p>
<p>然而，这里有一个优势，那就是通过一点点关心，你可以以 100% 安全的 Rust 编写游戏，几乎肯定不会遇到借用检查器的问题。你可能无法安全地使用 _指针_，因为 <em>肯定</em> 如果你使用指针，你的整个游戏状态将有内部指针指向自身，所以我们需要对 Mario 64 风格进行一个修改，那就是在所有会有指针的地方，改为存储到某个数组的索引。这个的经典例子是我们 GameState 中的“mario_entity”字段。这可能看起来过于限制性，但经过一些思考，它变得清晰，特别是如果你有常量限制（你甚至没有 malloc，记住！），你总是可以添加像 <code>all_the_textures: [TextureDescriptor; 256]</code> 这样的内容，并使用这个静态数组的整数索引来描述纹理，而不是像指针这样的东西。另一个原因是这在借用检查器方面是有帮助的，因为 Rust 非常擅长让你为不同的字段分割借用，所以既然我们假设的引擎中的一切都是一个巨大的嵌套公共结构体，你应该总是能够读取游戏状态并改变每个系统所需的确切部分。记住，大多数“行动回放”时代的游戏都是这样编写的，通常没有任何 malloc-ing，最多有一些非常有限的东西像“分配”只从一个固定数组中，而且大多数东西都或多或少地仔细地放置在某个静态结构中。</p>
<p>这种风格的另一个批评是，你可能会说使用索引而不是指针在严格意义上是“安全”的，但可能只是技术上的，你正在用指针的 UB 和潜在崩溃来换取“随机但未指定”的行为，如果你访问了错误的或过时的索引，可能会引发 panic。你说得对，顺便说一下！我们将稍后再讨论这个问题，但只是现在接受这是可能的和安全的，这种设计并没有直接反对借用检查器。</p>
<p>好的，现在我已经描述了一个你 <em>可能</em> 会用 Rust 编写游戏的方式，这种方式在道德上与最古老的游戏架构非常接近。我并不是在为你的下一款游戏或其他什么而提倡这个，但确实有一些现在编写的游戏比这更少，以直接的、单一用途的程序化风格编写。我不会叫出具体的游戏，但我见过很多以这种方式编写的游戏，通常包裹在一层薄薄的面向对象的外表中。我见过游戏源代码有一个单一的 <strong>12k</strong> 行世界生成函数。这不是对这种游戏的侮辱，甚至边际上也不是，做这些事情的人通常是绝对的天才，他们只是非常擅长知道关心什么和不关心什么。这里确实有真正的智慧！</p>
<p>但我仍然不是在提倡这个。让我们将这称为“UR-game-architecture”，我们将回到这一点。这是从底层接近“数据驱动！使用 ECS！”的答案，让我们现在从顶层接近这个。</p>
<h2 id="太多的面向对象"><a href="#太多的面向对象" class="headerlink" title="太多的面向对象"></a>太多的面向对象</h2><p>现在我们已经涵盖了可能最简单的混乱的过程化 C 风格的游戏引擎设计，让我们尝试应用面向对象设计的原则，看看这是否是一种改进。我将以 Starbound 或 Starbound 的某种简化为例，因为我有幸对它了解很多，并且手头有它的源代码，所以我在描述它时不会 <em>太</em> 多地撒谎。</p>
<p>面向对象的原则是什么？并不是每个人都完全同意面向对象是什么，但我会包括一些基本的、希望没有争议的要点：</p>
<ul>
<li>单一职责原则 - 对象应该有一个单一的逻辑集的职责，方法应该在这些职责集中执行一个操作。</li>
<li>封装 - 你应该将数据与操作它的函数绑定在一起，使它们免受外部干扰和误用。这允许你通过改变类的内部表示而不改变其行为来进行重构。</li>
<li>抽象，或“里斯科夫替代原则”，或类似的 - 你应该能够用一个派生类替换另一个，只要它们共享相同的基类并通过该基类（或接口，或其他什么）使用。</li>
<li>接口隔离，或最少耦合原则等 - 一个类对另一个类的依赖应该使用尽可能小的接口。</li>
</ul>
<p>在实际层面上，面向对象语言通常有一些重要的特性来支持面向对象设计，即对象方法、私有对象数据、继承、虚拟方法等。我主要会谈论 C++，因为它有很多面向对象的陷阱，它是我所知道的，并且它是超级流行的语言，用于“我要制作我自己的引擎”的游戏开发人群。</p>
<p>我们将尝试这些原则，并看看它们如何被误用于游戏开发，然后讨论即使它们经常失败于游戏开发（这现在是一个“众所周知”的状态），它们在 Rust 中失败得 <em>更</em> 壮观。用这些原则 <em>是</em> 可能制作游戏的，而且它们并不是 <em>全部</em> 都是普遍糟糕的想法。我并不是面向对象的 _支持者_，但至少有一些好的想法是与面向对象相关或从面向对象中产生的（所有这些 Rust 都有，并且可以很好地执行）。</p>
<ul>
<li><p>点运算符或“后缀函数”。如果你是 Haskeller，这是“类型导向名称解析”，而不是通常的情况，即“名称导向类型解析”。一种“强大”的方式，避免必须用非常短的公共名称来限定 100 个不同的函数，或者为所有事情都有 C 风格的前缀。对 IDE 也很棒！</p>
</li>
<li><p>具有法律（合同）的接口 - Rust traits！没有继承在望，它们最好时是小的，并且围绕它们有有意义的规则，但如果你看它们，它们有点像 C++ 纯虚类。它们 _很棒_，就像 Haskell 类型类很棒一样。 </p>
</li>
<li><p>数据隐藏 - 能够隐藏数据以维护不变性是非常宝贵的，没有它，就不可能安全地将接口暴露给不安全的</p>
</li>
<li><p>代码。在小范围内非常有用，以及与“库”代码一起使用。</p>
<p>所以只是为了记录，我不是在挑剔上面的好部分，这些是好的，甚至很棒。有了这个，让我们看看面向对象设计的其他部分如何失败于游戏开发。</p>
<p>所以，表面上游戏似乎很适合面向对象，因为当你试图想出面向对象的设计时，有一些明显的“对象”会跳出来。以 Starbound 为例，像“玩家”，“NPC”，“怪物”这样的事物是很容易理解的概念，是我们游戏中对象的明显候选者，让我们从这些开始。我们还将包括一个“世界”类，像 Mario 64 示例一样，是一些现场游戏场所的基本结构（我们故意跳过像接口、菜单等事情，专注于游戏引擎的核心部分）。我还将不得不切换到 C++，因为其中一些将很难用 Rust 表达。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line"></span><br><span class="line">    Vec2F aim_position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId focused_entity;</span><br><span class="line">    <span class="type">float</span> food_level;</span><br><span class="line">    <span class="type">bool</span> admin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有很多...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    MonsterAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId current_target;</span><br><span class="line">    DamageRegion damage_region;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line"></span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    Vec2F aim_position;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    <span class="comment">// 嗯，我们可能需要一个接口和向下转型？</span></span><br><span class="line">    HashMap&lt;EntityId, <span class="type">void</span>*&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>马上，我们看到了数据类型中的重复结构，可能这些应该是有自己的方法的子对象，让我们稍微勾画一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    Vec2F position;</span><br><span class="line">    Vec2F velocity;</span><br><span class="line">    <span class="type">float</span> mass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    HumanoidAnimationState animation_state;</span><br><span class="line">    HumanoidItem left_hand_item;</span><br><span class="line">    HumanoidItem right_hand_item;</span><br><span class="line">    Vec2F aim_position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line">    HumanoidState humanoid;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId focused_entity;</span><br><span class="line">    <span class="type">float</span> food_level;</span><br><span class="line">    <span class="type">bool</span> admin;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line"></span><br><span class="line">    MonsterAnimationState animation_state;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line">    EntityId current_target;</span><br><span class="line">    DamageRegion damage_region;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    Physics physics;</span><br><span class="line">    HumanoidState humanoid;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> health;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, <span class="type">void</span>*&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>到目前为止，这还不错，但这仍然只是描述了我们游戏中的数据结构。记住，我们谈论的面向对象原则之一是封装，你想要为这些结构（我们应该叫它们类！）暴露最小的接口和方法，并且只暴露必要的内容。另外，world 内部的 entities 中有一个 void 指针，我们可能不应该有这个，我们需要以某种方式存储我们的实体，让我们在这个时候制作一个 Entity 接口，同时我们也是在制作它的时候为所有实体的共同事物制作一个 Entity 接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> EntityId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先声明 World 以将其传递给 Entity</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InputState</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderState</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚接口！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 好吧，*肯定* 所有实体都会有一个位置，这可能是 const 的。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有实体都有速度吗？实际上可能不是，可能还有一些静态实体，所以我们跳过速度。还有</span></span><br><span class="line">    <span class="comment">// 其他共同的字段吗？老实说，可能有一些值得放在这里，但如果没有立即想到的案例，可能</span></span><br><span class="line">    <span class="comment">// 不会有*太多*，也许它们都会返回 Maybe 或者其他什么，但这听起来作为一个接口并不是很有用？我们将</span></span><br><span class="line">    <span class="comment">// 只是为这些制作更多的接口，坚持面向对象设计！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，我们肯定必须更新每个实体，可能还要渲染它，所以让我们为此定义一些方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 好吧，我们肯定必须将实体的世界传递给它的更新方法，因为例如玩家必须能够做</span></span><br><span class="line">    <span class="comment">// 像生成投射物实体这样的事情，怪物和 NPC 可能也是如此。另外，怪物必须知道玩家在哪里才能攻击他们！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让我们假设这些不是太状态化的和混乱的，每个实体都可以以某种合理的方式“自己渲染自己”。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 没有私有数据！我们肯定知道我们应该优先考虑组合而不是继承，因为我们以前听说过这个，所以只有纯</span></span><br><span class="line">    <span class="comment">// 虚拟接口给我们！这可能是面向对象设计的 *可能* 基本上已经死了的一个方面？我实际上不确定，但我知道这已经被讨论到死了，所以我们不必再打这个</span></span><br><span class="line">    <span class="comment">// 死马了。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line">    HumanoidState m_humanoid;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPC</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Physics m_physics;</span><br><span class="line">    HumanoidState m_humanoid;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorldTile</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br><span class="line"></span><br><span class="line">    MultiArray2D&lt;WorldTile&gt; tiles;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以在我们继续之前，为什么我在这里麻烦 <code>EntityId</code> 这些东西？这是 C++，我们不能用指针吗？好吧，事实证明这样做是非常 <em>不安全</em> 的，所以所有我见过的游戏引擎（在没有花哨垃圾收集器的语言中）都采用的是有一些形式的“实体 id”到实际实体指针的映射，并将这个映射保存在一个地方的模式。原因是，在 C++ 中，假设每个实体都保留一个 shared_ptr 或某种形式的 downcasted shared_ptr。那么问题就来了，World 现在是一个巨大的引用循环球，实体可能永远不会被销毁，这是一个巨大的问题。另一方面，如果它们保留了原始指针，它们将不断地失效，这往往会导致难以解决的短暂错误，所以几乎没有人这样做（至少，没有人保留原始指针 &#x2F; 引用很长时间）。你可以使用例如 weak_ptr，这有时被使用，但往往有其他原因使用 ids，因为它们对网络编程很有用，并且可以更容易地从磁盘保存和加载。这很有趣，因为这是我们在“UR-game-architecture”中必须做出的主要改变，以使其与 Rust 兼容，但这在游戏引擎中非常 <em>非常</em> 常见！</p>
<p>（在游戏引擎中，EntityId 通常是一个像 int 这样不断增加的东西，可能是一个不循环的 uint64_t 或者是一个循环的 uint32_t，这样做是为了让 EntityId 永远不会或很少被重新使用。这样，如果一个实体消失了，通常任何监控它的都会注意到它已经走了，而不是被其他实体立即取代。这里还有一个模式叫做“代际索引”，这很重要，我稍后会谈论）</p>
<p>好的，所以这似乎是… 真的可以制作一个复杂的游戏吗？我可以想象一个 <em>非常</em> 简单的游戏，你可以用这些类和接口制作，但让我们更详细地看看我们会碰到什么问题。</p>
<p>让我们想想一个怪物需要跟踪一个玩家。它们可能会遍历世界上所有的实体，过滤只有玩家，按距离排序（在现实中你会使用某种空间哈希 &#x2F; kd-tree），然后跟踪最近的一个。实际上这似乎基本上可能与这个一样！好的，新要求：怪物应该首先跟踪健康值最低的玩家。呃哦，好吧，玩家的健康是私有的，所以我们最好为这个做一个公共访问器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们 <em>可以</em> 只让健康公开，但面向对象设计！如果健康值降到某个值以下，就会触发某个动画状态怎么办？关于伤害呢？当然，单一职责原则说明一个 <em>怪物</em> 不应该负责设置一个 <em>玩家</em> 的健康。</p>
<p>好的，新要求：怪物不应该去追标记为“管理员”的玩家。好的，添加一个访问器！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_admin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好的，我们制作了一个小原型游戏，但还没有伤害发生，所以让我们开始设置伤害。嗯，玩家的伤害系统应该放在哪里？可能玩家应该减少他们的健康，因为这是 <em>他们</em> 的健康……或者怪物可以这样做，因为这是 <em>他们的</em> 伤害区域？我不知道，我会说这是玩家的工作。我猜这意味着我们需要怪物的访问器来获取他们的伤害区域：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : Entity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> DamageRegion&amp; <span class="title">damage_region</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这正在变成很多访问器。我们 <em>可以</em> 只开始公开更多的事情，但面向对象原则是什么？我们应该尽可能少和有限地暴露接口，这样我们就可以改变我们的实现而不需要重构。也许这不会 <em>那么</em> 糟糕。</p>
<p>好的，新要求：某些怪物只有在玩家靠近他们触摸地面时才会激怒。好的，这将需要更多的访问器，但因为我们一直在遵循关于代码重用的好的面向对象原则，我们有内部成员 m_physics 类型 <code>Physics</code>，它是唯一知道实体是否接触地面的东西。所以，我想 Physics 需要一个访问器来获取其内部状态 <code>Physics::onGround</code> 然后 <em>Player</em> 需要一个访问器 <code>Player::onGround</code> 这反过来将使用 <code>Physics::onGround</code>。好的，这正在变成 <em>很多</em> 访问器。</p>
<p>感觉就像每次有新需求进来，你都必须对可能曾经是合理的接口“再打更多的洞”。8 个月后，大部分半游戏都是这样建造的，有很多这些洞被戳穿。很多代码没有清晰的地方，因为它涉及到多个实体，很多逻辑上相似的功能被分散在几个文件中。“面向对象的问题在于一切都发生在别处”。</p>
<p>新需求来了：我有一个特殊物品的想法，当玩家拿着它靠近特定类型的敌人时，它会发光。触发这个的敌人应该害怕这个物品并后退，但有一种特殊的动画，他们被发光的物品迷住了。这只对达到某些特定任务目标的玩家有效。</p>
<p>你沮丧地举起双手，这将需要 4 个单独的模块来了解所有其他模块的内部（玩家、物品、怪物、动画）。你增加了更多的访问器和特殊接口。事情一团糟。</p>
<p>所以这些是虚构的例子，但它们与我 <em>很多</em> 经历的真实事情并没有太大的不同。这就是为什么现在普遍认为面向对象在游戏开发中 <em>大多数</em> 只是阻碍。数据隐藏在游戏之外的代码中除了在边缘保持不变性之外，几乎没有什么用处，其中事情更小，更有限。你的游戏中很多有趣的行为最终会跨越许多数据类型，并不自然地“属于”任何特定的实体。很多实体类型 80% 或 60% 与其他类型相似，很难重用代码，我们在实体中添加的模块越多，以帮助重用代码，就增加了更多的层次。与我们的 UR-架构相比，我们获得了什么？不是所有东西都对所有功能可见，即使我们不断增加更多的访问器，它也几乎是这样？也许在代码组织上稍微好一些，但有时 _更糟_？</p>
<p>好的，显然这在 C++ 中有很多缺点，并不是每个游戏都像 Starbound 那样有如此多的疯狂一次性功能。也许这只是一个极端的例子，通常这并不是那么糟糕的问题？让我们看看如果你尝试在 Rust 中这样做会发生什么！ _马上_，事情开始变得 _困难_。让我们回到 C++ 中最简单的面向对象版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedefs...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">const</span> InputState&amp; input_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(World* world)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(RenderState&amp; render_state)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entity definitions...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    List&lt;EntityId&gt; player_ids;</span><br><span class="line">    HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>部分翻译成 Rust：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">input</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, input_state: &amp;InputState);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, world: &amp;<span class="keyword">mut</span> World);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, render_state: &amp;<span class="keyword">mut</span> RenderState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    player_ids: <span class="type">Vec</span>&lt;EntityId&gt;,</span><br><span class="line">    entities: HashMap&lt;EntityId, Rc&lt;Entity&gt;&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使在这个很小的例子中，你已经可以看到这将是一个巨大的麻烦。首先，World 拥有每个 Entity，但每个 Entity 有一组可变的方法，其中之一必须接受一个 World 的可变引用。这不会起作用，因为你将可变地借用一个 Entity，然后必须再次可变地借用它以传递一个 World 引用（这可能会包含 self Entity）。为了做到这一点，可能 <em>每个</em> Entity 实现都需要内部可变性，否则它们将没有办法获取 World 引用，而且 World 可能也需要内部可变性，因为它也需要通过不可变引用传递。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">input</span>(&amp;<span class="keyword">self</span>, input_state: &amp;InputState);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update</span>(&amp;<span class="keyword">self</span>, world: &amp;World);</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>, render_state: &amp;<span class="keyword">mut</span> RenderState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    player_ids: RefCell&lt;<span class="type">Vec</span>&lt;EntityId&gt;&gt;,</span><br><span class="line">    entities: RefCell&lt;HashMap&lt;EntityId, Rc&lt;Entity&gt;&gt;&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，现在我们在实体更新期间不会有借用错误，但现在一切都必须在 RefCell 里面？也许我们可以将我们整个状态放在一个 RefCell 里面，这样就不会太难？我们已经讨论了复杂行为非常跨领域的倾向，如果有以下情况：</p>
<p>一个怪物伤害了一个玩家，这触发了玩家播放一个音效作为受伤的音效，但出于游戏原因，这也触发了一个逻辑声音，其他生物可以对它做出反应。也许有一些特定的怪物类型会有群体行为？所以，伤害一个玩家触发了一个外部突变（音频），内部突变（健康），然后可能触发怪物，它们有自己的内部突变（目标实体）。也许这一切都是从怪物开始的，所以控制流从怪物到玩家，然后 <em>回到</em> 怪物。如果你在调试怪物，现在你已经通过间接触发你自己结构体方法中的突变触发了 <em>诡异的动作在</em> 远处。除了，Rust 不允许这样做，（这甚至可能不会在 RefCell 中类型检查），所以在 Rust 中的版本是，你简单地得到了一个 RefCell panic。</p>
<p>让我们继续，假设实体有一些标签或动态标签集，让我们将这个添加到我们的 C++ Entity 接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> List&lt;Tag&gt; <span class="title">tags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设你分析了你的游戏，简单地返回一个 <code>List&lt;Tag&gt;</code> 的副本正在消耗大量的 CPU 时间，所以你将接口改为这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vec2F <span class="title">position</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> List&lt;Tag&gt;&amp; <span class="title">tags</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是假设这样的改变是可能的，不是一个等待发生的使用后释放错误，这通常是这种情况。好吧，Rust 应该能让我们免于使用后释放，如果你将这个翻译成 Rust 版本会发生什么：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">position</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Vec2F;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tags</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">Vec</span>&lt;Tag&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我使生命周期不省略，以使其明显，但这表明这个方法返回一个单一的 Vec 引用，它借用了 _整个实体_。那是.. 有帮助的，但如果你想要稍后调用任何可能发生变异的其他方法，那也没有帮助。如果这有内部可变性并且在 RefCell 里面，这也是不可能的，将不得不返回 <code>std::cell::Ref</code>。一切都很难，比在 C++ 中更难。你上 IRC 寻求帮助，你得到了一个好意但可能不太有帮助的答案：“你只是在与借用检查器战斗的阶段。”</p>
<p>情况可能会更糟。Entity 很稀疏，即使是 Starbound 中真正的 <code>Entity</code>，假设你将这些相同的原则应用到 <code>World</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tile</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, index: Vector2&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> WorldTile &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巨大的额外成员...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你有一个足够大的 <code>World</code> 结构，即使没有像纯虚拟接口（或在 Rust 中，特征）这样的东西，你仍然会遇到问题。访问一个瓦片应该借用 <em>整个世界</em> 吗？如果世界的所有字段都是公开的，事情会更容易，这样你就可以借一部分世界，从而允许你变异其他部分，这正是你可以做的，如果世界只是一个具有普通公共成员的结构体。这变得更加重要，世界越大，数据隐藏就越不重要，你越进入“应用”级别，情况就越糟，因为你的游戏随着你不断添加功能而变得越来越复杂。我们不是在写引擎，我们只是在 Rust 中直接写一个简单的游戏，所有的数据都必须去某个地方！</p>
<p>如果你正在写像这样的方法，更明显的是你可以使一个大型复合结构的字段公开，并且分割借用会有帮助，但想象一下你没有这样设计事情。想象一下你有 <em>两种</em> 世界，一个用于服务器，一个用于客户端。这正是 Starbound 的工作方式，并且有一个大型复杂的“世界”接口在客户端和服务器之间共享。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tile</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, index: Vector2&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> WorldTile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 巨大的额外特征方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 <em>不可能</em> “只让字段公开”，不管“面向对象”原则或不，就像 Entity。更多的“与借用检查器战斗”。面向对象原则指导你尽可能松散地耦合，一个很常见的策略是，不是让对象直接依赖于彼此，而是通过一个纯接口相互依赖。</p>
<p>Starbound <em>充满了</em> 这些，Entity 和 World 只是其中两个。它们 <em>放大</em> 了借用问题，通过 <em>放大</em> 你被迫借用的数量！</p>
<p>我不认为我 <em>完全</em> 能在我的 30 分钟演讲中完全证明我说的一切，这只是 <em>一点点</em> 表面，但希望我至少给了你 <em>一个</em> 我来自哪里 _的想法。我知道对你们中的一些人来说，这听起来会非常主观，可能只对特定类型的软件（游戏）听起来像有用的建议。另外，对你们中的许多人来说，这可能是无聊的，你已经都知道了，但它仍然希望看到这与一个并非每个人都参与的行业的关系。</p>
<p>但是，话虽如此，这里有一些我的收获：</p>
<ul>
<li><p>对于游戏，面向对象 <em>真的</em> 没有帮助。我列出的面向对象的有用部分是好的，但当你不是在写“库”代码，而是在写游戏时，数据隐藏 <em>一般</em> 不是有用的，只是浪费了大量的努力和时间。你的游戏数据越多，它就越会因为你不断尝试而改变，这就越糟糕。</p>
</li>
<li><p>思考“对象”与数据类型在游戏设计中听起来表面上很吸引人，但实际上是 <em>积极</em> 有害的。大多数行为并不“附加”到任何数据，如果你开始这样思考，可能会很难停止。不要将你游戏的数据表示与操作它的系统混为一谈！</p>
</li>
<li><p>有时我觉得，我宁愿处理一个单一的 12k 行巨型程序，也不愿处理一个纠缠不清的对象球。</p>
</li>
<li><p>Carmack 引用：“有时，优雅的实现只是一个函数。不是一个方法。不是一个类。不是一个框架。只是一个函数。”</p>
</li>
<li><p>有时，如果你必须写很多混乱的过程状态变化，只是 <em>诚实</em> 地处理它们，用长（也许不是 12k 行）的过程是最佳策略。诚实地面对正在发生的事情的混乱，隐藏在其他函数或方法中并不会有所帮助，它只会让事情出错时更加困惑。如果可以把事情拿出来，它们是简单和纯粹的函数，那就去做吧，但把混乱的过程真相保持原样！另一个 Carmack 的事情。</p>
</li>
<li><p>我发现思考决定游戏状态的结构类型非常容易，也很有启发性。你经常可以从代码库中学习几乎所有你需要知道的东西，只是看看所有的类型定义。如果你在看 C++，如果你只看结构成员及其关系并忽略所有的代码，这通常会告诉你比看函数名称更多的东西。我花了很多时间阅读 Haskell 代码，他们有一种模式，通常在 Rust 中被模仿，他们有一个模块叫做“Types”，只有……一些库所需的所有类型。我有点喜欢这个，我认为 Rust 非常适合这种编程。</p>
</li>
</ul>
<p>我在这里有点调皮，但什么告诉你更多，这个接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    <span class="function">List&lt;EntityPtr&gt; <span class="title">entityQuery</span><span class="params">(RectF <span class="type">const</span>&amp; boundBox)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是这个结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">World</span> &#123;</span><br><span class="line">    SpatialHash2D&lt;EntityId, <span class="type">float</span>, EntityPtr&gt; entitySpatialMap;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然，这里有很多信息来自类型的 _名称_，显然 <code>SpatialHash2D</code> 是它自己的结构，有自己的子类型，但如果你很好地命名你的类型，这个观点仍然成立，你看到一个明显的面包屑路径可以跟随，以理解接口可能隐藏了什么（你的空间实体查询可能会很快，你不应该期望查询会以实体数量的线性时间进行）。</p>
<p>我问过我们是否可以使用面向对象来改进我们的 UR-架构，令人惊讶的是，我们 _基本上不能_。除了像点运算符和数据隐藏这样有用的东西之外，这些在库代码中很有用，游戏的大规模结构并没有真正得到面向对象的帮助。我们需要一种方法来处理没有制造面向对象混乱的单个巨大可变公共嵌套结构的负面影响。我们现在从顶层接近 ECS 答案。</p>
<h2 id="回到开始。"><a href="#回到开始。" class="headerlink" title="回到开始。"></a>回到开始。</h2><p>我们的“面向对象架构”在 Rust 中完全失败了，让我们从我们知道会起作用的东西开始，我们的“UR-架构”，并尝试改进它。这是一个相当标准的 ECS 转换，你可能以前见过。</p>
<p>我读过很多 ECS 解释，我知道有一个相当好的解释，还有 <em>很多</em> 真正令人困惑的糟糕解释，希望我可以以一种很好的方式解释这个，专注于 <em>数据</em> 表示，并且对 Rust 特别有用。</p>
<p>让我们从我们的简单“Starbound”开始，再次写下我们游戏的状态表示，但这次是用 Rust。没有方法，没有函数，只有数据类型。这将与上面的 Mario 64 示例“UR-架构”非常相似，有一些小的添加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationState</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    animation_state: HumanoidAnimationState,</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    humanoid: HumanoidState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    animation_state: MonsterAnimationState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">    damage_region: DamageRegion,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Npc</span> &#123;</span><br><span class="line">    physics: Physics,</span><br><span class="line">    humanoid: HumanoidState,</span><br><span class="line"></span><br><span class="line">    health: <span class="type">f32</span>,</span><br><span class="line">    behavior: NpcBehavior,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Player</span>(Player),</span><br><span class="line">    <span class="title function_ invoke__">Monster</span>(Monster),</span><br><span class="line">    <span class="title function_ invoke__">Npc</span>(Npc),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entities: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Entity&gt;&gt;,</span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = <span class="title function_ invoke__">initial_game_state</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">player_control_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line">        <span class="title function_ invoke__">npc_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line">        <span class="title function_ invoke__">monster_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vsync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与 Mario 64 示例相比，这里有几个变化。首先，我们试图使用 Rust 功能，如枚举和像 Option 这样的数据类型，而不是如此努力地模仿 C。很棒的是，突然之间，我们游戏状态的结构有更少的可能无效状态！例如，如果我们试图使用一个统一的“Entity”与一个类型代码，像 Mario 64 那样，将会有必须手动保持的不变性，这些不变性表明某些字段的状态取决于实体的类型。现在，许多这些不变性自然地因为求和类型是如此伟大而消失了。这很有趣，因为它使封装变得不那么重要，即使一切都是公开的，也有一些不变的性不能被打破。还有一些不变的性不能以这种方式表达，例如，数组的玩家 ID 可能需要仅指向 Player 类型的实体！</p>
<p><code>entities: Vec&lt;Option&lt;Entity&gt;&gt;</code> 也很有趣。由于我们的一些实体将索引到这个数组作为对其他实体的“指针”，因此有意义我们不应该在数组中移动实体。如果我们分配了一堆实体然后删除了我们分配的第一个实体，我们不应该移动每个实体，而是将其设置为 None，这样数组的其余部分就会保持在原位。在分配时，我们可能会遍历数组寻找第一个 None 空槽，如果没有找到，将一个新的实体推到末尾。</p>
<p>这很有趣，因为它与“Mario 64”示例中的静态数组的工作方式非常相似。</p>
<p>除了这些变化，这并不是一个巨大的偏离。所有的游戏状态仍然在道德上是全局的，每个系统仍然可能是大的和程序化的。但这里的事情是……我真的不认为这很糟糕？</p>
<p>老实说，如果我正在做一个游戏制作比赛的游戏，这可能就是我会编写我的游戏的方式！</p>
<p>我不会编写底层图形或音频代码，但如果我正在做一个简单的 2D 游戏或非常简单的 3D 游戏，这对我来说是可行的。我的游戏状态可能是一个相当复杂的结构体，充满了其他结构体，我可能有很多“系统”（记住，这里只是普通函数）在不同的文件中，这很好。我会选择一个非常简单的图形 API，尽可能少的状态，以尽可能减少“加载”和“卸载”图形数据的麻烦，同样适用于音频 API，这将是游戏的结构。如果我必须使用一个非常混乱和有状态的图形或音频系统，我会在最初创建游戏状态时预加载所有内容，将所有内容都放在某个 Assets 结构体中，就这样。</p>
<p>有很多 Rust 的高级图形和声音 API 实际上使这变得非常容易。</p>
<p>但是，这种模式显然并不完美，除了一切都是全局公开的。首先，我们的每个实体类型中都有很多重复的数据，例如 <code>Physics</code> 在 Player、Monster 和 Npc 中重复。在我们的 <code>physics_system</code> 函数中，可能有一些共性，这进一步分解为另一个函数，但 <code>physics_system</code> 肯定 <em>肯定</em> 必须理解有 3 种不同的实体类型，它们都有物理。每当我们添加一个实体类型时，可能这个系统必须改变其实现，并且老实说，可能 <em>非常非常多</em> 的系统在添加实体类型时必须改变。</p>
<p>另外，随着我们添加更多的实体，我们可能会开始发现很大一部分将被一遍又一遍地重复。也许“Monster”太具体了，你将它分解为“FlyingMonster”和“GroundMonster”，但它们共享 80% 的相同字段，反过来，这两个又与 Player 共享 50% 的字段。</p>
<p>这在某些方面比拥有一个统一的实体类型要好，但在某些方面实际上更糟？这还不错，但让我们看看是否可以做得更好。让我们回到像 Mario 64 示例那样有一个统一的 Entity 类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有不同类型的字段，一个实体可以拥有，按逻辑分组...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItem</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MonsterAnimationState</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DamageRegion</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidState</span> &#123;</span><br><span class="line">    animation_state: HumanoidAnimation,</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterState</span> &#123;</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">    animation_state: MonsterAnimationState,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcState</span> &#123;</span><br><span class="line">    behavior: NpcBehavior,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实体是所有可能的实体字段的集合，我们让每个人都有一个选项。在这种情况下，</span></span><br><span class="line"><span class="comment">// 我们失去了一些类型安全性，因为这样可以表达更多的无效状态，其中一些组合可能没有意义。</span></span><br><span class="line"><span class="comment">// 另外，也许现在没有意义让一个实体缺少位置，所以即使在这里是可选的，所有实体都必须有物理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    physics: <span class="type">Option</span>&lt;Physics&gt;,</span><br><span class="line">    health: <span class="type">Option</span>&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    humanoid: <span class="type">Option</span>&lt;HumanoidState&gt;,</span><br><span class="line">    player: <span class="type">Option</span>&lt;PlayerState&gt;,</span><br><span class="line">    monster: <span class="type">Option</span>&lt;MonsterState&gt;,</span><br><span class="line">    npc: <span class="type">Option</span>&lt;NpcState&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entities: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;Entity&gt;&gt;,</span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">game_state</span> = <span class="title function_ invoke__">initial_game_state</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">input_state</span> = <span class="title function_ invoke__">capture_input_state</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">player_control_system</span>(&amp;<span class="keyword">mut</span> game_state, &amp;input_state);</span><br><span class="line">        <span class="title function_ invoke__">npc_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line">        <span class="title function_ invoke__">monster_behavior_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">physics_system</span>(&amp;<span class="keyword">mut</span> game_state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的系统</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">render_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line">        <span class="title function_ invoke__">audio_system</span>(&amp;<span class="keyword">mut</span> game);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">wait_vsync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好的，这很有趣。显然，我们在这里失去了一些不变性，因为更多的潜在无效实体可能会被创建，但有一些巨大的优势。一个突出的是，我们 <code>physics_system</code> 的实现可能大大简化了，只需循环遍历所有实体并突变 <code>physics</code> 字段（如果它们有的话）。这比循环遍历实体并匹配实体类型要简单得多。</p>
<p>仍然有一些结构仅对每种“逻辑”实体类型有效，显然，让某物同时是 NPC 和怪物是没有意义的，所以这是一个需要保持的不变性。这很有趣，因为每个“类型”的数据量变小了。让我们更进一步改变它，并分离出更多的字段：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Physics</span> &#123;</span><br><span class="line">    position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    velocity: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">    mass: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItems</span> &#123;</span><br><span class="line">    left_hand_item: HumanoidItem,</span><br><span class="line">    right_hand_item: HumanoidItem,</span><br><span class="line">    aim_position: Vector2&lt;<span class="type">f32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimation</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehavior</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Aggression</span> &#123;</span><br><span class="line">    current_target: EntityIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了对称，让我们让 Health 成为结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Health</span>(<span class="type">f32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hunger</span> &#123;</span><br><span class="line">    food_level: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerState</span> &#123;</span><br><span class="line">    focused_entity: EntityIndex,</span><br><span class="line">    admin: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    physics: <span class="type">Option</span>&lt;Physics&gt;,</span><br><span class="line">    huamnoid_animation: <span class="type">Option</span>&lt;HumanoidAnimation&gt;,</span><br><span class="line">    humanoid_items: <span class="type">Option</span>&lt;HumanoidItems&gt;,</span><br><span class="line">    monster_animation: <span class="type">Option</span>&lt;MonsterAnimation&gt;,</span><br><span class="line">    npc_behavior: <span class="type">Option</span>&lt;NpcBehavior&gt;,</span><br><span class="line">    health: <span class="type">Option</span>&lt;Health&gt;,</span><br><span class="line">    hunger: <span class="type">Option</span>&lt;Hunger&gt;,</span><br><span class="line">    player: <span class="type">Option</span>&lt;PlayerState&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以有很多方法可以表达每个实体可能包含的字段，它们都有优点和缺点。在这种情况下，通过以这种方式转换我们的字段类型，有几件事情变得可以表达，以前是不可能的！例如，由于我们将 <code>food_level</code> 字段从 Player 中分离出来并称之为 <code>Hunger</code>，我们现在可以表达不是 Player 但饥饿的实体，所以现在我们可以描述饥饿的 NPC。另外，在分离出 <code>Aggression</code> 之后，我们可以表达敌对的 NPC！</p>
<p>然而，也许我们可以表达具有怪物类型动画的东西，也可以携带人类物品，也许这实际上是逻辑上无效的，所以这里有一个取舍。尽管如此，这仍然很有趣，并解决了在需要重复代码来表达或从单一类型中提取的实体类型之间存在很多共同性的问题。</p>
<p>现在，可能已经很清楚我要去哪里了，但这种模式，其中实体由一个或多个命名部分组成，并且它们是按需指定的，是非常常见的。实际上，这些部分通常被称为“组件”！我们现在有了所有的实体、组件和系统，所以如果你眯着眼睛看，这就是一个“ECS”系统所需要的一切，但这实际上非常简单！通过专注于我们状态的数据表示，这与我们开始的没有太多步骤。</p>
<p>让我们再做一个实际上无关紧要的改变，但这将在一秒钟内帮助我们。此外，我们将开始称我们一直在定义的所有这些部分为“组件”，以强化这一点：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityIndex</span> = <span class="type">usize</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Assets</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有这些组件向量必须具有相同的长度，这是当前的实体数量。</span></span><br><span class="line">    physics_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;PhysicsComponent&gt;&gt;,</span><br><span class="line">    humanoid_animation_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HumanoidAnimationComponent&gt;&gt;,</span><br><span class="line">    humanoid_items_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HumanoidItemsComponent&gt;&gt;,</span><br><span class="line">    monster_animation_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;MonsterAnimationComponent&gt;&gt;,</span><br><span class="line">    npc_behavior_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;NpcBehaviorComponent&gt;&gt;,</span><br><span class="line">    aggression_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;AggressionComponent&gt;&gt;,</span><br><span class="line">    health_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HealthComponent&gt;&gt;,</span><br><span class="line">    hunger_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;HungerComponent&gt;&gt;,</span><br><span class="line">    player_components: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;PlayerComponent&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;EntityIndex&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是经典的“结构数组”到“数组结构”的转换。应该很清楚（几乎）完全相同的信息可以在这两种表示之间表达。有一些新的不变性需要维护，即每个组件 Vec 的长度必须相同，但并没有真正的新信息。当你像这样写出类型时，这些变化实际上看起来相当简单，而不是在我们的面向对象架构中，像这样的变化可能被认为是不可能的重构。显然我们还需要在这里改变很多系统，每次我们进行这些更改时，但能够独立思考数据是有价值的。</p>
<p>“数组结构”的转换通常是 ECS 介绍中真正关注的，然后他们开始谈论性能问题和缓存行为，这可能会有点令人困惑和不知所措。他们不是错了，但我不认为这是重要的部分。这就是为什么我以这种方式介绍 ECS，因为我认为很多解释都错过了这一点，从某种角度看，这些变化实际上相当无聊和正常。你可能有这种结构，或者你可能有之前的结构，也许一个比另一个性能更好，但你没有通过选择一个而不是另一个来彻底改变编程范式。从数据导向的角度来看，这些事情并不是颠覆性的，它们只是性能优化。这里还有很多其他的潜在优化可以做，但我认为我们已经达到了有人可能会称之为“ECS 系统”的最低限度。</p>
<p>这里有一些对 Rust 用户的一般性建议，不仅仅是游戏开发者：</p>
<ul>
<li><p>仅仅思考状态的结构是非常有力的，通常“方法”和“对象”会碍事。没有人会认为在结构体上拥有方法是“太多的面向对象”，但它确实将你的程序与你的耦合在一起，即使只是组织上的。数据结构设计和简单的模块组织都很重要，但不要将它们混为一谈！我确信“ECS 设计”在游戏开发中如此出色，是因为它迫使你思考你的数据而不是被卡在面向对象模式中，而不是“数组结构”的魔力。这是可以应用于 Rust 一般性的一个教训。</p>
</li>
<li><p>你可以用索引到 Vec 的方式做很多事情。这比自我借用或 Rc&lt;Ref</p>
</li>
<li><p>Cell&gt; 容易得多。</p>
<p>好的，让我们停下来谈谈 <code>EntityIndex</code>。我真的认为，大多数时候当你发现自己在 Rust 中遇到自我借用时，普通的 Vec 和索引应该是你首先使用的工具。还有其他工具，比如各种竞技场 crates，租赁等，但我认为通常你应该先尝试 Vec。一般来说，这些问题发生在你试图表示某种图结构时（ECS 只是一个非常平的图……有点），即使在 C++ 中，这通常也是给出的建议！（见 Andrei Alexandrescu 的性能演讲，他最喜欢的数据结构在世界上是 std::vector，“只使用 vector！”）像竞技场分配器这样的工具很棒，实际上非常高效，并且有可以与多种类型一起使用的版本，但它们不能是 ‘static 除非添加自我借用。自我借用解决方案像租赁是 _最后的手段_。这不值得，继续你的生活，只是使用 Vec 和索引。</p>
<p>话虽如此，它们确实有一些缺点。在我们的实体示例中，我们一直对如何找到“空闲” EntityIndexes 以及“删除”如何工作这个问题视而不见，因为实际上并不那么好。分配一个“实体”的成本不是恒定的，因为我们必须扫描 Vec 寻找空闲条目。删除实体更便宜，但它有不好的特性。我们可以删除一个实体，这会释放 Vec 中的一个插槽，但然后可能的情况是下一个分配的实体将使用相同的索引。如果我们在删除之前确保没有未解决的“索引引用”到这个实体，这很好，但如果我们搞砸了呢？我们将在不知不觉中得到一个“随机其他实体”，而无法告诉它实际上被从我们下面移除了！另外，这两种情况在“数组结构”转换后变得更糟，因为现在我们有多个数组而不是一个，以及我们如何管理“实体索引”现在是悬而未决的。我们将同时解决这两个问题。</p>
<h2 id="代际索引是很棒的。"><a href="#代际索引是很棒的。" class="headerlink" title="代际索引是很棒的。"></a>代际索引是很棒的。</h2><p>所以这是我最喜欢的模式之一，我不确定在 Rust 社区中是否广为人知，但我相信在游戏开发中广为人知。</p>
<p>我们一直在使用 <code>EntityIndex</code> 来识别和查找存储在 Vec 中的实体。这非常类似于我在 C++ mini-Starbound 中使用的模式，我使用了一个 <code>EntityId</code>，这是一个递增的整数 ID 来存储实体，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</span><br></pre></td></tr></table></figure>

<p>两者都是从整数到某些值的抽象映射。在 Vec 的情况下，它基本上是最快可能的数据结构，索引到数组，而在 <code>HashMap</code> 的情况下，它要慢得多，但 <code>HashMap</code> 要灵活得多！首先，只有总条目数的上限，而不是，比如说，索引的最大大小。<code>HashMap</code> 可以很好地工作，如果你从 1,000,000,000 或 1 开始键值。这在上述删除问题中很重要。如果我们使用 <code>HashMap</code> 和键类型 <code>u32</code> 或甚至 <code>u64</code> 来索引，我们可以只让新索引始终递增（最终会回绕）。这样，你可以或多或少地保证没有索引会被重新使用，或者至少在索引被重新使用之前会是“很长一段时间”。在 <code>u64</code> 的情况下，如果你重新使用了一个索引，你的游戏技术可能已经有“云”在名称中，所以你可能有更多的问题：)。但是 <code>HashMap</code> 比 Vec 慢 :(</p>
<p>是否有办法在使用整数索引到 Vec 的情况下获得这种属性？有，它被称为“代际索引”！</p>
<p>而不是只使用一个整数索引，我们制作一个“代际索引”类型，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你可以使用其他类型，如果这些类型对于 usize / u64 来说太大</span></span><br><span class="line"><span class="meta">#[derive(Eq, PartialEq, etc...)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndex</span> &#123;</span><br><span class="line">    index: <span class="type">usize</span>,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GenerationalIndex</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们制作一个叫做“代际索引分配器”的东西：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocatorEntry</span> &#123;</span><br><span class="line">    is_live: <span class="type">bool</span>,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndexAllocator</span> &#123;</span><br><span class="line">    entries: <span class="type">Vec</span>&lt;AllocatorEntry&gt;,</span><br><span class="line">    free: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">GenerationalIndexAllocator</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">allocate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> GenerationalIndex &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 true 如果索引之前被分配过，现在被释放了</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">deallocate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_live</span>(&amp;<span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（有更快的实现方式，但这一个实际上相当不错。另外注意，这是数据隐藏的一个明显好的用途）。</p>
<p>基本思想是你可以“分配”向量索引就像你有了 <code>Vec&lt;Option&lt;Entry&gt;&gt;</code>，但你会永远不重新使用索引。它的工作原理是这样的，你分配一个索引并得到一个带有真实索引 0 的 <code>GenerationalIndex</code>，它也会有“代”0。如果你删除那个索引，它会进入一个空闲索引池，所以下次你分配一个索引时，你可能会得到另一个带有真实索引 0 的代际索引，但关键是代际现在将是 1。代际索引永远不会被重新使用，因为代际总是会递增，然而“真实索引”将始终是“小的”，在最大总条目数的顺序上。这样，你可以使用快速索引到 Vec 而没有简单索引的许多“指针样”属性！</p>
<p>我说这种模式在 Rust 社区中不是广为人知，但至少有一点谎言，因为有一个最近发布的 crate 建立在这个想法上叫做“slotmap”，它很棒！但是，它缺少一个对我们的例子至关重要的功能，那就是在“slotmap”中，你只能为特定的 SlotMap 分配索引，你不能分配索引并重新使用它们用于不同的 SlotMaps。有用，但如果这些概念是分开的，就像我们在这里概述的那样，它将更有用得多。索引到 Vec 已经是在遇到“自我借用”时应该首先使用的工具，代际索引使它变得更好。“slotmap”比我先发布了一个 crate：(，所以这算是一个功能请求 :)</p>
<p>我们将继续制作一个比 <code>Vec&lt;Option&lt;T&gt;&gt;</code> 更易于使用的类型，以存储我们的实际数据：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayEntry</span>&lt;T&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">    generation: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 GenerationalIndex 到一些 Value T 的关联数组。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">GenerationalIndexArray</span>&lt;T&gt;(<span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;ArrayEntry&lt;T&gt;&gt;&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; GenerationalIndexArray&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 为某个代际索引设置值。可能会覆盖过去的代际值。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex, value: T) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个代际索引的值，代际必须匹配。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: GenerationalIndex) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以有了这个新的抽象，让我们再次改变我们的引擎：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们放弃了索引或 ID 后缀，因为没有其他“实体”类型会混淆。 但不要忘记，这并不“包含”</span></span><br><span class="line"><span class="comment">// 任何东西，它只是一种索引或 ID 或句柄或任何你想要的称呼。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 Entity 到某种类型 T 的映射</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line"></span><br><span class="line">    physics_components: EntityMap&lt;PhysicsComponent&gt;,</span><br><span class="line">    humanoid_animation_components: EntityMap&lt;HumanoidAnimationComponent&gt;,</span><br><span class="line">    humanoid_items_components: EntityMap&lt;HumanoidItemsComponent&gt;,</span><br><span class="line">    monster_animation_components: EntityMap&lt;MonsterAnimationComponent&gt;,</span><br><span class="line">    npc_behavior_components: EntityMap&lt;NpcBehaviorComponent&gt;,</span><br><span class="line">    aggression_components: EntityMap&lt;AggressionComponent&gt;,</span><br><span class="line">    health_components: EntityMap&lt;HealthComponent&gt;,</span><br><span class="line">    hunger_components: EntityMap&lt;HungerComponent&gt;,</span><br><span class="line">    player_components: EntityMap&lt;PlayerComponents&gt;,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;Entity&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>太棒了！我们现在几乎是一个完整的 ECS 系统。</p>
<p>对 Rust 用户的收获：显然代际索引是很棒的，但出于某种原因它们在 C++ 中更受欢迎，但它们可能对 Rust 更有用！对“slotmap”的作者，请将分配器单独公开，这非常有用！如果这不在你的范围或你想要的 API 提供，我可以发布一个类似的 crate，它可以做到这一点。</p>
<h2 id="动态类型在非常受控的数量中实际上是相当不错的。"><a href="#动态类型在非常受控的数量中实际上是相当不错的。" class="headerlink" title="动态类型在非常受控的数量中实际上是相当不错的。"></a>动态类型在非常受控的数量中实际上是相当不错的。</h2><p>好的，我们现在非常接近一个“真正的” ECS 系统（像 specs！）可能的工作方式。我们还没有解决的最大问题仍然是一切都是相当全局的。更重要的是，每个“系统”（对我们来说，仍然只是一个普通函数的花哨名称）都依赖于我们游戏状态中的 <em>所有</em> 类型，这可能是相当大的。大多数游戏将生活在一个 crate 中，这些模块之间的依赖关系图表真的没有什么好担心的，但仍然改变“GameState”中的任何内容至少 <em>理论上</em> 会影响每个系统。</p>
<p>让我们看看我们能做些什么？</p>
<p>我想强调一下，在我们继续之前，这是 _可选的_。你可能会觉得这是不必要的复杂性，你可能是对的！这确实是大多数 ECS 实现中的东西，所以它值得涵盖，只是为了理解它们，并且当试图构建一个库来做到这一点时，它是 <em>或多或少</em> 无法避免的。</p>
<p>为此，我们需要 <code>anymap</code> crate，但 <code>mopa</code> crate 也会起作用。我们需要一个容器，可以存储我们放入其中的 <em>每种</em> 类型的一个精确副本：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AnyMap</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AnyMap</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, t: T) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;T&gt; &#123; ... &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们如何使用这个来存储我们的组件？</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PhysicsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HumanoidItemsComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonsterAnimationComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NpcBehaviorComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AggressionComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HungerComponent</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerComponent</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameState</span> &#123;</span><br><span class="line">    assets: Assets,</span><br><span class="line"></span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line">    <span class="comment">// 我们假设这将只包含 `EntityMap&lt;T&gt;` 类型的类型。 这是动态的，所以类型系统在这里不再有帮助，</span></span><br><span class="line">    <span class="comment">// 你可以使用 `mopa` crate 使这稍微更好。</span></span><br><span class="line">    entity_components: AnyMap,</span><br><span class="line"></span><br><span class="line">    players: <span class="type">Vec</span>&lt;Entity&gt;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，而不是存储游戏特定的数据，让我们继续使用动态类型！我们将说我们的游戏状态是一个动态集合的实体与组件，并且 <em>也</em> 是其他类型的动态集合，每种类型一个。我们将这些称为“资源”。我们还将 <code>GameState</code> 的名称更改为更准确的东西。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Entity</span> = GenerationalIndex;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EntityMap</span>&lt;T&gt; = GenerationalIndexArray&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ECS</span> &#123;</span><br><span class="line">    entity_allocator: GenerationalIndexAllocator,</span><br><span class="line">    <span class="comment">// 充满了像 `EntityMap&lt;T&gt;` 这样的类型。</span></span><br><span class="line">    entity_components: AnyMap,</span><br><span class="line"></span><br><span class="line">    resources: AnyMap,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们到达了一个实际的 ECS 数据结构可能看起来的样子。</p>
<p>我添加了一个“资源” AnyMap，因为这也是很常见的模式，它意味着你的整个游戏状态可以在这个“ECS”结构中表达。我们称它为“ECS”，但重要的是，真的没有提到“系统”。我实际上不喜欢通过谈论行为来描述 ECS，因为我认为虽然它可能很重要，但它真的是次要的。如果我们的“系统”是纯函数在一个循环中，或者它们是更花哨的东西，这两种都捕捉到了 ECS 设计的重要部分。</p>
<p>所以，你现在可能会对动态类型的引入感到不满和突然。让我们停下来想想这给我们带来了什么。假设你为你的游戏得到了一个新的功能请求，比如说你需要一个新的疯狂的特殊怪物，它有一些内部的计数器。每次你杀死怪物时，它会将自己复制成两个并递减计数器，像九头蛇的头一样复制。这意味着你可能需要一个新的组件类型，比如说 <code>EnemyDuplicationLevel</code> 或其他什么。有了动态类型，你可以添加这个组件而不会“打扰”你的其他系统，因为如果没有导入新模块，它们不可能“看到”ECS 有这样一个组件。资源也是如此，你可以向你的模型添加新数据类型而不会“打扰”现有的系统。</p>
<p>这种论证的理由可能看起来相当薄弱，而且确实如此。为了获得完整的画面，我们需要更进一步。我将加快速度，这样我们可以到达结尾，我可以展示一个完整的画面，我认为这是一个“现代”游戏引擎设计，你可能用于中型或大型项目。它实际上并不比这更远，但最后几个功能都是相关的，单独使用它们并不那么有用。</p>
<h2 id="“注册表”模式"><a href="#“注册表”模式" class="headerlink" title="“注册表”模式"></a>“注册表”模式</h2><p>现在我们已经引入了动态类型，这里有一个我喜欢的设计模式，我认为在 Rust 中还没有真正看到过（我确定它存在，我只是没有看到）。我将称其为“注册表模式”。</p>
<p>在像 specs 这样的 ECS 实现中，有一个步骤，你“注册”一个类型与你的 ECS，这会在某个 AnyMap 或相当于 AnyMap 的地方插入一个条目。使用未注册的组件类型通常是一个错误。让我们再进一步，不要将“注册”与 ECS 本身联系起来，让我们制作我们自己的“注册表”。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ComponentRegistry</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ComponentRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 注册一个组件，组件必须实现一个特殊特征才能允许</span></span><br><span class="line">    <span class="comment">// 例如从 JSON 配置中加载。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register_component</span>&lt;T: Component&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为所有注册的组件设置 ECS 的条目</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup_ecs</span>(&amp;<span class="keyword">self</span>, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从给定的配置中加载一个实体到给定的 ECS</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_entity</span>(&amp;<span class="keyword">self</span>, config: Json, ecs: &amp;<span class="keyword">mut</span> ECS) <span class="punctuation">-&gt;</span> Entity &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也将为“资源”做一个</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ResourceRegistry</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ResourceRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// 资源特征提供从 JSON 和其他东西中加载。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">register_resource</span>&lt;T: Resource&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为所有注册的资源设置 ECS 的条目</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup_ecs</span>(&amp;<span class="keyword">self</span>, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过从给定的配置中加载来向给定的 ECS 添加资源。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_resource</span>(&amp;<span class="keyword">self</span>, config: Json, ecs: &amp;<span class="keyword">mut</span> ECS) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们将它们在一个大型的全局常量中使用 lazy_static 绑定在一起！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当我们向项目中添加一个组件时，有两个步骤。首先，将组件添加到某个地方作为一个 Rust 模块，然后将其添加到这个列表中。为了增加便利性，这个函数可以放在包含组件模块本身的 lib.rs 中。如果你非常花哨，你也可以有一些“插件架构”来实现这一点，将相关的组件 / 资源组合在一起成为“插件”。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">load_component_registry</span>() <span class="punctuation">-&gt;</span> ComponentRegistry &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">component_registry</span> = ComponentRegistry::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    component_registry.register::&lt;PhysicsComponent&gt;();</span><br><span class="line">    component_registry.register::&lt;PlayerComponent&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">load_resource_registry</span>() <span class="punctuation">-&gt;</span> ResourceRegistry &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: ComponentRegistry,</span><br><span class="line">    <span class="keyword">pub</span> resources: ResourceRegistry,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> REGISTRY: Registry = Registry &#123;</span><br><span class="line">        components: <span class="title function_ invoke__">load_component_registry</span>(),</span><br><span class="line">        resources: <span class="title function_ invoke__">load_resource_registry</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我喜欢这种模式，因为如果你眯着眼睛看，这几乎就像你在 Java 中可能找到的全局类型注册表。它感觉有点“企业级”，但非常有用！它也类似于具有内置编辑器的全功能、全面的引擎，你可能会通过某些菜单或 GUI 添加组件类型，它最终会存储在某些项目配置文件中。在这种情况下，而不是项目配置文件，它只是一个辅助的 Rust 代码。</p>
<p>这种模式最终非常有用！想象一下你有一些可以从 JSON 配置文件中加载的游戏状态。每个资源和组件都可以从 JSON 中加载，所以你只需要添加一个组件或资源类型，然后添加条目到数据格式，加载游戏并看到它（除了你需要一个新的系统来理解新类型，我们会在几秒钟内到达）。</p>
<p>所以到目前为止，这是一个正在变成“真正的”ECS 游戏引擎的东西的草图。我喜欢这个，因为到目前为止，除了一些必要的库功能外，我几乎没有谈论过函数或系统！我之所以这样做，是因为我不喜欢通过谈论行为来引入这个概念，我真的认为考虑我们如何描述我们的状态是一种更有用的方法来接近这个。</p>
<p>有了这个，很容易看出你如何也可以很容易地添加一个 <code>SystemRegistry</code> 与之相匹配。我们的系统只是函数，所以这将允许你以稍微更复杂的方式将函数添加到你的主循环中。这里可能的一个补充是允许系统有一些配置，这样你也许可以为它们配置可调参数，甚至使用相同的函数多次，但具有不同的参数。然而，通常建议尽量不要给你的系统 _状态_，这样你可以将你的游戏状态限制为组件和资源。如果你的游戏状态只是组件和资源，你通常可以做一些很酷的事情，比如克隆它们（像模拟器一样保存状态！）或轻松地序列化它，这在像系统闭包这样的东西中更难实现。</p>
<p>对普通 Rust 的收获：注册表模式实际上相当不错。在 Starbound 中有一个“根”对象，它有点像这个，每个类型都注册了，但它比这里描述的更具有状态性。它是只读的，但它是通过读取资产构建的。我实际上喜欢“类型注册表”的想法，当你想使用 AnyMap 这样的动态类型时，这是必要的，这两种模式很好地结合在一起，以限制“一切都依赖于一切”的问题。</p>
<h2 id="ECS-是游戏的-SQL"><a href="#ECS-是游戏的-SQL" class="headerlink" title="ECS 是游戏的 SQL"></a>ECS 是游戏的 SQL</h2><p>让我稍微揭开帷幕。我们到目前为止描述了什么：一种声明特殊类型键（实体）的方式，以及与这些键相关联的一系列记录（组件），另外还有定义不与这些键配对的记录的方式（资源）。我们引入了动态类型，并展示了一种模式，让你可以在一个地方定义你拥有的所有记录类型（有点像模式）。在我构建的真正的 ECS 中，我甚至有执行组件的原始“查询”的方式，比如说“给我所有具有位置的实体，可选具有速度，但不具有质量”。</p>
<p>这听起来可能非常熟悉，如果确实如此，有很好的理由。ECS 就是游戏的 SQL。一个非常、非常、非常有限的 SQL 形式，但精神上非常相似。定义你的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据模式，加载它，对它进行查询，然后更新它。非常有限的 SQL，其中每个查询可能必须在不超过几微秒的时间内运行。</p>
<p>我早些时候说过我读过很多糟糕的 ECS 介绍和一个好介绍。我不是第一个提到 ECS 和 SQL 之间平行的人，早在 2009 年，就有一篇文章关注 MMO 的这一点。</p>
<p>所以，如果这是真的，我们为什么不能只使用像 sqlite 这样的来存储我们的游戏状态？有趣的是，你可能真的可以做到这一点，但很难在 16 毫秒内运行查询足够快。让我们想想这将带来什么好处！哦，天哪，我需要为游戏制作一个保存格式..不，它是 SQL，我已经完成了。哦，我需要更新每个人的保存文件格式..写一些外部 SQL 更新脚本，你已经完成了！</p>
<p>哦，我想给游戏的任意状态保存的能力？完成了。我注意到一个错误，我想将游戏状态回滚到 30 秒前，然后逐步通过它，运行查询以查看何时产生了一个坏状态？完成了。所有这些仔细引入的代际索引概念，SQL 已经有了，它们是具有自动递增的键（更像是 <code>HashMap&lt;EntityId, T&gt;</code> 真的）。</p>
<p>那时，你的每个系统基本上将是一系列查询，从 SQL 中获取数据，进行一些更新，然后将其写回 SQL。我们已经将性感的游戏开发变成了无聊的老式 web 开发！（web 开发可以是性感的，游戏开发可以是无聊的，只是记录）</p>
<p>唯一的问题是我 <em>相当</em> 确定它慢了大约两个数量级，无法工作，但它是一个不错的想法，并且它是有用的，可以进行比较！</p>
<p>我认为这很重要，因为我看到很多关于“什么使某物成为纯粹的 ECS”的辩论，我认为这最终是非常愚蠢的。</p>
<ul>
<li><p>如果实体可以有多个组件，它是 ECS 吗？好吧，多个组件和只包含 Vec 的组件之间的差异非常非常少，但它仍然是 ECS。如果你有两个表是 1 到 N 而不是 1 到 1，它仍然是 SQL 吗？是的，当然。</p>
</li>
<li><p>如果我的组件有方法，它仍然是 ECS 吗？是的，添加组件方法并不是世界末日，特别是如果有一个小的局部不变性需要维护。SQL 是关于数据的，但它也有存储过程来维护不变性。</p>
</li>
<li><p>如果我需要两个不同的 ECS 集合，或者我把很多数据放入资源中，它仍然是 ECS 吗？我应该使用“单例实体”还是资源？它仍然是 SQL 如果我有两个不同的数据库，或者分开一个顶级表吗？是的，当然！</p>
</li>
</ul>
<p>……等等</p>
<p>这个类比不是完美的，但我认为这确实是一种启示。目前正在进行有关如何使更有能力的 ECS 系统具有组件图和组件与实体之间的子关系等的研究，当然这是可以的。SQL 已经有了所有这些，它是一种语言和一套软件，用于表达 <em>所有种类</em> 的数据关系，只是游戏通常有更简单的需求，将基本上总是在内存中，并且有纳秒或微秒的时间要求，所以我们妥协并制作了新工具。</p>
<p>这是另一个我做这次演讲的原因，帮助进一步揭开“ECS”的神秘面纱，并展示我们是如何来到这里的，并给出一些观点。</p>
<h2 id="一切都出错的地方"><a href="#一切都出错的地方" class="headerlink" title="一切都出错的地方"></a>一切都出错的地方</h2><p>（注意：我不知道我是否需要这一段，我只是在兜售我想要做的 <em>其他</em> 演讲。也许这不重要？这次演讲已经可能非常非常长了）</p>
<p>我一开始就声称，我见过的态度对借用检查器过于怀疑，认为它太限制性，这是胡说八道。我仍然绝对相信这一点，但我想快速谈谈我不断遇到问题的唯一地方，我真的 <em>只有</em> 遇到麻烦的地方，我不断感到受限。当然，随着项目规模的增长，<em>某些事情</em> 必须出错，对吧？好吧，我有一个例子，尽管这个问题并不局限于 Rust，它只是更 <em>立即</em> 痛苦（注意到一个模式？）。</p>
<p>语言边界很难。</p>
<p>所以，这里的问题都很难简洁地解释。我不确定我能否像以前一样提出小而有限的例子，而不深入到细节中，并使这次演讲的长度翻倍。我写了一个完整的 crate（rlua）来尝试解决这个问题，经过大量的工作，我可以自信地说我 <em>某种程度上</em> 只解决了一半。</p>
<p>我有一个组件的表示，你可以选择读取或写入每个组件（它们存储在 RwLocks 中以实现系统并发）。我想让 Lua 能够读取一组系统，所以我有一个 Lua 脚本对 ECS 存储执行“查询”。我所需要做的就是能够将 Lua 传递“RwLockReadGuard”（实际上是包含这个的结构）的查询返回，但是……</p>
<p>RwLockReadGuard 不是静态的。哦，我猜我只能在查询 API 中而不是在开始时一次性传递 Lua 查询锁定……那将是非常慢的，也不安全，查询应该在整个时间内锁定。我猜我可以使用租赁 crate……哦，天哪，租赁 crate 很难，这太可怕了。（后来我能够使用 rlua 的“范围”系统解决这个问题，但仍然很糟糕）。</p>
<p>最好你的系统不要有状态，对吧？通常系统应该将数据存储在它们操作的组件中，如果它们逻辑上相关，或者可能存储在自定义资源中，或者简单地存储一些缓存值，但要准备好如果系统重新加载，缓存将被重置。不要依赖不能被保存 &#x2F; 恢复 &#x2F; 序列化的数据。这很棒，直到你写了一个 Lua 系统，因为将值从 Lua 中提取出来实际上是真的很难。你不能将 Lua 状态存储在资源中，因为它不是 Sync，你也不能将 Lua 数据与状态分开存储，因为 Lua 内部状态和外部句柄真的不是 Sync。你可以使用一些神奇的 Lua 注册表键来解决这个问题，但如果你每个系统都有自己的 Lua 实例，如果你尝试在错误的上下文中使用 Lua 值，你就制造了一个脚枪，而且它们也不是可序列化的。</p>
<p>你可以制作一个数据类型，它仅限于数据而不是内部 Lua 类型，但然后你必须在它和非 lua 表示之间编写编组，所以每次你的脚本系统读取或写入这个存储，它都是 <em>非常慢</em> 的。一些慢速是来自复制数据，但大部分是来自本质上的 Lua API 慢速。</p>
<p>一切都很难，如果你真的尝试，它是可以工作的，但你感觉它应该比这更简单。这甚至比 C++ 中的等价物更难，但 C++ 中的等价物实际上和这一样糟糕，你只是在 Rust 中更快地注意到它。</p>
<p>至少没有不断的崩溃和 shared_ptr 循环了？</p>
<p>看起来有点类似于我们之前的情况，我们尝试了面向对象的错误方法。不幸的是，在 rlua 的情况下，有一些基于 Lua 内部 C API 如何工作的硬性限制，它可能接近我能提供的最好的东西。</p>
<p>语言边界很难，尤其是当它们有非常不同的限制集合的语言之间，比如 Rust 和 Lua（或 C++ 和 Lua）。特别是当被包含语言中的垃圾收集器与宿主语言中的垃圾收集器接触时，一切都不会工作，什么都不会被收集。（在 C++ &#x2F; Rust 中，这是 shared_ptr &#x2F; Arc，是的，这些是一种垃圾收集器）</p>
<p>我提到这个是因为我认为 Lua 非常受游戏开发者的欢迎，我经常收到关于如何将 rlua 与像 specs 这样的东西结合的问题，我认为这真的很难，并且违背了我在这次演讲中提出的更大观点。我认为这可能是 <em>独特地</em> 难，因为语言边界非常棘手，情况并不比 C++ 中的更糟或更好，它稍微更难，但更安全，只是稍微更难不是一个很好的答案，当在 C++ 中它仍然非常困难时。</p>
<p>我还提到这个，因为我可能很快就会有一个答案！我考虑做的 <em>另一个</em> 演讲是描述我认为是一种新颖的方式，在 Rust 中安全地实现语言运行时，它们有垃圾收集，并且是零成本的，并且具有快速、大部分无痛（或尽可能）的绑定体验。</p>
<p>与此同时，在你添加游戏引擎的脚本层之前，请仔细考虑。问题是，我 <em>爱</em> 游戏引擎中的脚本层（出于可修改性和许多其他原因），所以我无论如何都会这样做，但这不是一个轻松的决定，它可以消耗大量的时间和精力。我想让这更无痛，并且使一个安全、快速的 Lua 在 Rust 中感觉像家一样，就像 PUC-Rio 的 Lua 在 C 中感觉像家一样。我将来会谈论这个！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我这次演讲有多个目的：</p>
<ul>
<li>为那些只有小规模项目经验的人，走过一个中等规模 Rust 项目的设计理念。</li>
<li>展示一些陷阱的例子，人们可能会陷入其中，从而“与借用检查器战斗”，并帮助更具体地了解如何至少部分地越过这个阶段。</li>
<li>展示数据导向编程有多么棒，以及它对游戏和 Rust 是多么合适的</li>
<li>展示在 Rust 中应用的游戏开发模式，这些模式在 Rust 出现之前就已经出现了，仍然似乎是一个很好的选择。</li>
</ul>
<p>我谈论了很多在其他语言中经过艰苦斗争的模式，只有在费力地探索了最终不成功的解决方案的空间后才会出现。有趣的是，那些最终效果不佳的解决方案通常会更快地在 Rust 中引起痛苦，它们更响亮，更烦人。我认为这是一件好事，我喜欢有工具让糟糕的模式感觉和它们一样糟糕。Rust 在这方面 _很棒_。</p>
<p>但你可以把这里的大部分教训同样容易地应用在 C++ 中吗？在 C 中吗？是的，绝对可以。即使你是那种即使没有这种语言压力也不会犯这些错误的人（你比我强多了），还有很多其他的好处。</p>
<p>我实际上没有机会谈论 Rust 的所有好处或谈论我使用 Rust 的一般经验，因为我只有 30 分钟，而这一点可能已经超过了 30 分钟。</p>
]]></content>
  </entry>
</search>
